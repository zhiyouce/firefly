{"0": {
    "doc": "pages.advanced_cli_usage",
    "title": "Advanced CLI Usage",
    "content": " ",
    "url": "/firefly/head/contributors/advanced_cli_usage.html#advanced-cli-usage",
    "relUrl": "/contributors/advanced_cli_usage.html#advanced-cli-usage"
  },"1": {
    "doc": "pages.advanced_cli_usage",
    "title": "Table of contents",
    "content": ". | Advanced CLI Usage . | Understanding how the CLI uses FireFly releases | The manifest.json file | Default CLI behavior for releases | Running a specific release of FireFly | Running an unreleased version of one or more services . | Build a new image of fabconnect locally | Edit your manifest.json file | Initialize the stack with the custom manifest.json file | . | Running a locally built FireFly Core image . | Build a new image of FireFly locally | Initialize the stack with the custom manifest.json file | . | . | . This page details some of the more advanced options of the FireFly CLI . ",
    "url": "/firefly/head/contributors/advanced_cli_usage.html#table-of-contents",
    "relUrl": "/contributors/advanced_cli_usage.html#table-of-contents"
  },"2": {
    "doc": "pages.advanced_cli_usage",
    "title": "Understanding how the CLI uses FireFly releases",
    "content": " ",
    "url": "/firefly/head/contributors/advanced_cli_usage.html#understanding-how-the-cli-uses-firefly-releases",
    "relUrl": "/contributors/advanced_cli_usage.html#understanding-how-the-cli-uses-firefly-releases"
  },"3": {
    "doc": "pages.advanced_cli_usage",
    "title": "The manifest.json file",
    "content": "FireFly has a manifest.json file in the root of the repo. This file contains a list of versions (both tag and sha) for each of the microservices that should be used with this specific commit. Here is an example of what the manifest.json looks like: . { \"ethconnect\": { \"image\": \"ghcr.io/hyperledger/firefly-ethconnect\", \"tag\": \"v3.0.4\", \"sha\": \"0b7ce0fb175b5910f401ff576ced809fe6f0b83894277c1cc86a73a2d61c6f41\" }, \"fabconnect\": { \"image\": \"ghcr.io/hyperledger/firefly-fabconnect\", \"tag\": \"v0.9.0\", \"sha\": \"a79a4c66b0a2551d5122d019c15c6426e8cdadd6566ce3cbcb36e008fb7861ca\" }, \"dataexchange-https\": { \"image\": \"ghcr.io/hyperledger/firefly-dataexchange-https\", \"tag\": \"v0.9.0\", \"sha\": \"0de5b1db891a02871505ba5e0507821416d9fa93c96ccb4b1ba2fac45eb37214\" }, \"tokens-erc1155\": { \"image\": \"ghcr.io/hyperledger/firefly-tokens-erc1155\", \"tag\": \"v0.9.0-20211019-01\", \"sha\": \"aabc6c483db408896838329dab5f4b9e3c16d1e9fa9fffdb7e1ff05b7b2bbdd4\" } } . ",
    "url": "/firefly/head/contributors/advanced_cli_usage.html#the-manifestjson-file",
    "relUrl": "/contributors/advanced_cli_usage.html#the-manifestjson-file"
  },"4": {
    "doc": "pages.advanced_cli_usage",
    "title": "Default CLI behavior for releases",
    "content": "When creating a new stack, the CLI will by default, check the latest non-pre-release version of FireFly and look at its manifest.json file that was part of that commit. It will then use the Docker images referenced in that file to determine which images it should pull for the new stack. The specific image tag and sha is written to the docker-compose.yml file for that stack, so restarting or resetting a stack will never pull a newer image. ",
    "url": "/firefly/head/contributors/advanced_cli_usage.html#default-cli-behavior-for-releases",
    "relUrl": "/contributors/advanced_cli_usage.html#default-cli-behavior-for-releases"
  },"5": {
    "doc": "pages.advanced_cli_usage",
    "title": "Running a specific release of FireFly",
    "content": "If you need to run some other version that is not the latest release of FireFly, you can tell the FireFly CLI which release to use by using the --release or -r flag. For example, to explicitly use v0.9.0 run this command to initialize the stack: . ff init -r v0.9.0 . ",
    "url": "/firefly/head/contributors/advanced_cli_usage.html#running-a-specific-release-of-firefly",
    "relUrl": "/contributors/advanced_cli_usage.html#running-a-specific-release-of-firefly"
  },"6": {
    "doc": "pages.advanced_cli_usage",
    "title": "Running an unreleased version of one or more services",
    "content": "If you need to run an unreleased version of FireFly or one of its microservices, you can point the CLI to a specific manifest.json on your local disk. To do this, use the --manifest or -m flag. For example, if you have a file at ~/firefly/manifest.json: . ff init -m ~/firefly/manifest.json . If you need to test a locally built docker image of a specific service, you’ll want to edit the manifest.json before running ff init. Let’s look at an example where we want to run a locally built version of fabconnect. The same steps apply to any of FireFly’s microservices. Build a new image of fabconnect locally . From the fabconnect project directory, build and tag a new Docker image: . docker build -t ghcr.io/hyperledger/firefly-fabconnect . Edit your manifest.json file . Next, edit the fabconnect section of the manifest.json file. You’ll want to remove the tag and sha and a \"local\": true field, so it looks like this: ... \"fabconnect\": { \"image\": \"ghcr.io/hyperledger/firefly-fabconnect\", \"local\": true }, ... Initialize the stack with the custom manifest.json file . ff init local-test -b fabric -m ~/Code/hyperledger/firefly/manifest.json ff start local-test . If you are iterating on changes locally, you can get the CLI to use an updated image by doing the following: . | Whenever the CLI does its first time setup, it will use your newly built local docker image | If you’ve already run the stack, you can run ff reset &lt;stack_name&gt; and ff start &lt;stack_name&gt; to reset the data, and use the newer image | . ",
    "url": "/firefly/head/contributors/advanced_cli_usage.html#running-an-unreleased-version-of-one-or-more-services",
    "relUrl": "/contributors/advanced_cli_usage.html#running-an-unreleased-version-of-one-or-more-services"
  },"7": {
    "doc": "pages.advanced_cli_usage",
    "title": "Running a locally built FireFly Core image",
    "content": "You may have noticed that FireFly core is actually not listed in the manifest.json file. If you want to run a locally built image of FireFly Core, you can follow the same steps above, but instead of editing an existing section in the file, we’ll add a new one for FireFly. Build a new image of FireFly locally . From the firefly project directory, build and tag a new Docker image: . make docker . Initialize the stack with the custom manifest.json file . ff init local-test -m ~/Code/hyperledger/firefly/manifest.json ff start local-test . ",
    "url": "/firefly/head/contributors/advanced_cli_usage.html#running-a-locally-built-firefly-core-image",
    "relUrl": "/contributors/advanced_cli_usage.html#running-a-locally-built-firefly-core-image"
  },"8": {
    "doc": "pages.advanced_cli_usage",
    "title": "pages.advanced_cli_usage",
    "content": " ",
    "url": "/firefly/head/contributors/advanced_cli_usage.html",
    "relUrl": "/contributors/advanced_cli_usage.html"
  },"9": {
    "doc": "pages.api_post_syntax",
    "title": "API POST Syntax",
    "content": " ",
    "url": "/firefly/head/reference/api_post_syntax.html#api-post-syntax",
    "relUrl": "/reference/api_post_syntax.html#api-post-syntax"
  },"10": {
    "doc": "pages.api_post_syntax",
    "title": "Table of contents",
    "content": ". | Syntax Overview | Example API Call | . ",
    "url": "/firefly/head/reference/api_post_syntax.html#table-of-contents",
    "relUrl": "/reference/api_post_syntax.html#table-of-contents"
  },"11": {
    "doc": "pages.api_post_syntax",
    "title": "Syntax Overview",
    "content": "Endpoints that allow submitting a transaction allow an optional query parameter called confirm. When confirm=true is set in the query string, FireFly will wait to send an HTTP response until the message has been confirmed. This means, where a blockchain transaction is involved, the HTTP request will not return until the blockchain transaction is complete. This is useful for endpoints such as registration, where the client app cannot proceed until the transaction is complete and the member/node is registered. Rather than making a request to register a member/node and then repeatedly polling the API to check to see if it succeeded, an HTTP client can use this query parameter and block until registration is complete. NOTE: This does not mean that any other member of the network has received, processed, or responded to the message. It just means that the transaction is complete from the perspective of the FireFly node to which the transaction was submitted. ",
    "url": "/firefly/head/reference/api_post_syntax.html#syntax-overview",
    "relUrl": "/reference/api_post_syntax.html#syntax-overview"
  },"12": {
    "doc": "pages.api_post_syntax",
    "title": "Example API Call",
    "content": "POST /api/v1/messages/broadcast?confirm=true . This will broadcast a message and wait for the message to be confirmed before returning. ",
    "url": "/firefly/head/reference/api_post_syntax.html#example-api-call",
    "relUrl": "/reference/api_post_syntax.html#example-api-call"
  },"13": {
    "doc": "pages.api_post_syntax",
    "title": "pages.api_post_syntax",
    "content": " ",
    "url": "/firefly/head/reference/api_post_syntax.html",
    "relUrl": "/reference/api_post_syntax.html"
  },"14": {
    "doc": "pages.api_query_syntax",
    "title": "API Query Syntax",
    "content": " ",
    "url": "/firefly/head/reference/api_query_syntax.html#api-query-syntax",
    "relUrl": "/reference/api_query_syntax.html#api-query-syntax"
  },"15": {
    "doc": "pages.api_query_syntax",
    "title": "Table of contents",
    "content": ". | Syntax Overview | Example API Call . | Operators | Modifiers | . | Detailed examples | . ",
    "url": "/firefly/head/reference/api_query_syntax.html#table-of-contents",
    "relUrl": "/reference/api_query_syntax.html#table-of-contents"
  },"16": {
    "doc": "pages.api_query_syntax",
    "title": "Syntax Overview",
    "content": "REST collections provide filter, skip, limit and sort support. | The field in the message is used as the query parameter . | Syntax: field=[modifiers][operator]match-string | . | When multiple query parameters are supplied these are combined with AND | When the same query parameter is supplied multiple times, these are combined with OR | . ",
    "url": "/firefly/head/reference/api_query_syntax.html#syntax-overview",
    "relUrl": "/reference/api_query_syntax.html#syntax-overview"
  },"17": {
    "doc": "pages.api_query_syntax",
    "title": "Example API Call",
    "content": "GET /api/v1/messages?confirmed=&gt;0&amp;type=broadcast&amp;topic=t1&amp;topic=t2&amp;context=@someprefix&amp;sort=sequence&amp;descending&amp;skip=100&amp;limit=50 . This states: . | Filter on confirmed greater than 0 | Filter on type exactly equal to broadcast | Filter on topic exactly equal to t1 or t2 | Filter on context containing the case-sensitive string someprefix | Sort on sequence in descending order | Paginate with limit of 50 and skip of 100 (e.g. get page 3, with 50/page) | . Table of filter operations, which must be the first character of the query string (after the = in the above URL path example) . Operators . Operators are a type of comparison operation to perform against the match string. | Operator | Description | . | = | Equal | . | (none) | Equal (shortcut) | . | @ | Containing | . | ^ | Starts with | . | $ | Ends with | . | &lt;&lt; | Less than | . | &lt; | Less than (shortcut) | . | &lt;= | Less than or equal | . | &gt;&gt; | Greater than | . | &gt; | Greater than (shortcut) | . | &gt;= | Greater than or equal | . Shortcuts are only safe to use when your match string starts with a-z, A-Z, 0-9, - or _. Modifiers . Modifiers can appear before the operator, to change its behavior. | Modifier | Description | . | ! | Not - negates the match | . | : | Case insensitive | . | ? | Treat empty match string as null | . ",
    "url": "/firefly/head/reference/api_query_syntax.html#example-api-call",
    "relUrl": "/reference/api_query_syntax.html#example-api-call"
  },"18": {
    "doc": "pages.api_query_syntax",
    "title": "Detailed examples",
    "content": "| Example | Description | . | cat | Equals “cat” | . | =cat | Equals “cat” (same) | . | !=cat | Not equal to “cat” | . | :=cat | Equal to “CAT”, “cat”, “CaT etc. | . | !:cat | Not equal to “CAT”, “cat”, “CaT etc. | . | =!cat | Equal to “!cat” (! is after operator) | . | ^cats/ | Starts with “cats/” | . | $_cat | Ends with with “_cat” | . | !:^cats/ | Does not start with “cats/”, “CATs/” etc. | . | !$-cat | Does not end with “-cat” | . | ?= | Is null | . | !?= | Is not null | . ",
    "url": "/firefly/head/reference/api_query_syntax.html#detailed-examples",
    "relUrl": "/reference/api_query_syntax.html#detailed-examples"
  },"19": {
    "doc": "pages.api_query_syntax",
    "title": "pages.api_query_syntax",
    "content": " ",
    "url": "/firefly/head/reference/api_query_syntax.html",
    "relUrl": "/reference/api_query_syntax.html"
  },"20": {
    "doc": "pages.arbitrum",
    "title": "Arbitrum Testnet",
    "content": " ",
    "url": "/firefly/head/tutorials/chains/arbitrum.html#arbitrum-testnet",
    "relUrl": "/tutorials/chains/arbitrum.html#arbitrum-testnet"
  },"21": {
    "doc": "pages.arbitrum",
    "title": "Table of contents",
    "content": ". | Previous steps: Install the FireFly CLI | Create an evmconnect.yml config file | Creating a new stack | Start the stack | Get some Aribitrum . | Confirm the transaction on Bscscan | . | Use the public testnet | . Starting with FireFly v1.1, it’s easy to connect to public Ethereum chains. This guide will walk you through the steps to create a local FireFly development environment and connect it to the Arbitrum Nitro Goerli Rollup Testnet. ",
    "url": "/firefly/head/tutorials/chains/arbitrum.html#table-of-contents",
    "relUrl": "/tutorials/chains/arbitrum.html#table-of-contents"
  },"22": {
    "doc": "pages.arbitrum",
    "title": "Previous steps: Install the FireFly CLI",
    "content": "If you haven’t set up the FireFly CLI already, please go back to the Getting Started guide and read the section on how to Install the FireFly CLI. ← ① Install the FireFly CLI . ",
    "url": "/firefly/head/tutorials/chains/arbitrum.html#previous-steps-install-the-firefly-cli",
    "relUrl": "/tutorials/chains/arbitrum.html#previous-steps-install-the-firefly-cli"
  },"23": {
    "doc": "pages.arbitrum",
    "title": "Create an evmconnect.yml config file",
    "content": "In order to connect to the Binance Smart Chain testnet, you will need to set a few configuration options for the evmconnect blockchain connector. Create a text file called evmconnect.yml with the following contents: . confirmations: required: 4 # choose the number of confirmations you require policyengine.simple: fixedGasPrice: null gasOracle: mode: connector . For more info about confirmations, see Public vs. Permissioned . For this tutorial, we will assume this file is saved at ~/Desktop/evmconnect.yml. If your path is different, you will need to adjust the path in the next command below. ",
    "url": "/firefly/head/tutorials/chains/arbitrum.html#create-an-evmconnectyml-config-file",
    "relUrl": "/tutorials/chains/arbitrum.html#create-an-evmconnectyml-config-file"
  },"24": {
    "doc": "pages.arbitrum",
    "title": "Creating a new stack",
    "content": "To create a local FireFly development stack and connect it to the Arbitrum testnet, we will use command line flags to customize the following settings: . | Create a new stack named arbitrum with 1 member | Disable multiparty mode. We are going to be using this FireFly node as a Web3 gateway, and we don’t need to communicate with a consortium here | Connect to an ethereum network | Use the evmconnect blockchain connector | Use an remote RPC node. This will create a signer locally, so that our signing key never leaves the development machine. | See the Arbitrum docs and select an HTTPS RPC endpoint. | Set the chain ID to 421613 (the correct ID for the Binance Smart Chain testnet) | Merge the custom config created above with the generated evmconnect config file | . To do this, run the following command: . ff init arbitrum 1 \\ --multiparty=false \\ -b ethereum \\ -c evmconnect \\ -n remote-rpc \\ --remote-node-url &lt;selected RPC endpoint&gt; \\ --chain-id 421613 \\ --connector-config ~/Desktop/evmconnect.yml . ",
    "url": "/firefly/head/tutorials/chains/arbitrum.html#creating-a-new-stack",
    "relUrl": "/tutorials/chains/arbitrum.html#creating-a-new-stack"
  },"25": {
    "doc": "pages.arbitrum",
    "title": "Start the stack",
    "content": "Now you should be able to start your stack by running: . ff start arbitrum . After some time it should print out the following: . Web UI for member '0': http://127.0.0.1:5000/ui Sandbox UI for member '0': http://127.0.0.1:5109 To see logs for your stack run: ff logs arbitrum . ",
    "url": "/firefly/head/tutorials/chains/arbitrum.html#start-the-stack",
    "relUrl": "/tutorials/chains/arbitrum.html#start-the-stack"
  },"26": {
    "doc": "pages.arbitrum",
    "title": "Get some Aribitrum",
    "content": "At this point you should have a working FireFly stack, talking to a public chain. However, you won’t be able to run any transactions just yet, because you don’t have any way to pay for gas. First, you will need to know what signing address your FireFly node is using. To check that, you can run: . ff accounts list arbitrum [ { \"address\": \"0x225764d1be1f137be23ddfc426b819512b5d0f3e\", \"privateKey\": \"...\" } ] . Copy the address listed in the output from this command. Next, check out this article https://medium.com/offchainlabs/new-g%C3%B6rli-testnet-and-getting-rinkeby-ready-for-nitro-3ff590448053 and follow the instructions to send a tweet to the developers. Make sure to change the address to the one in the CLI. Confirm the transaction on Bscscan . You should be able to go lookup your account on https://goerli-rollup-explorer.arbitrum.io/ and see that you now have a balance of 0.001 ether. Simply paste in your account address to search for it. ",
    "url": "/firefly/head/tutorials/chains/arbitrum.html#get-some-aribitrum",
    "relUrl": "/tutorials/chains/arbitrum.html#get-some-aribitrum"
  },"27": {
    "doc": "pages.arbitrum",
    "title": "Use the public testnet",
    "content": "Now that you have everything set up, you can follow one of the other FireFly guides such as Using Tokens or Custom Smart Contracts. For detailed instructions on deploying a custom smart contract to Binance Smart Chain, please see the Arbitrum docs for instructions using various tools. ",
    "url": "/firefly/head/tutorials/chains/arbitrum.html#use-the-public-testnet",
    "relUrl": "/tutorials/chains/arbitrum.html#use-the-public-testnet"
  },"28": {
    "doc": "pages.arbitrum",
    "title": "pages.arbitrum",
    "content": " ",
    "url": "/firefly/head/tutorials/chains/arbitrum.html",
    "relUrl": "/tutorials/chains/arbitrum.html"
  },"29": {
    "doc": "pages.avalanche",
    "title": "Avalanche Testnet",
    "content": " ",
    "url": "/firefly/head/tutorials/chains/avalanche.html#avalanche-testnet",
    "relUrl": "/tutorials/chains/avalanche.html#avalanche-testnet"
  },"30": {
    "doc": "pages.avalanche",
    "title": "Table of contents",
    "content": ". | Previous steps: Install the FireFly CLI | Create an evmconnect.yml config file | Creating a new stack | Start the stack | Get some AVAX . | Confirm the transaction on Snowtrace | . | Use the public testnet | . Starting with FireFly v1.1, it’s easy to connect to public Ethereum chains. This guide will walk you through the steps to create a local FireFly development environment and connect it to the Avalanche C-Chain Fuji testnet. ",
    "url": "/firefly/head/tutorials/chains/avalanche.html#table-of-contents",
    "relUrl": "/tutorials/chains/avalanche.html#table-of-contents"
  },"31": {
    "doc": "pages.avalanche",
    "title": "Previous steps: Install the FireFly CLI",
    "content": "If you haven’t set up the FireFly CLI already, please go back to the Getting Started guide and read the section on how to Install the FireFly CLI. ← ① Install the FireFly CLI . ",
    "url": "/firefly/head/tutorials/chains/avalanche.html#previous-steps-install-the-firefly-cli",
    "relUrl": "/tutorials/chains/avalanche.html#previous-steps-install-the-firefly-cli"
  },"32": {
    "doc": "pages.avalanche",
    "title": "Create an evmconnect.yml config file",
    "content": "In order to connect to the Avalanche testnet, you will need to set a few configuration options for the evmconnect blockchain connector. Create a text file called evmconnect.yml with the following contents: . confirmations: required: 4 # choose the number of confirmations you require policyengine.simple: fixedGasPrice: null gasOracle: mode: connector . For more info about confirmations, see Public vs. Permissioned . For this tutorial, we will assume this file is saved at ~/Desktop/evmconnect.yml. If your path is different, you will need to adjust the path in the next command below. ",
    "url": "/firefly/head/tutorials/chains/avalanche.html#create-an-evmconnectyml-config-file",
    "relUrl": "/tutorials/chains/avalanche.html#create-an-evmconnectyml-config-file"
  },"33": {
    "doc": "pages.avalanche",
    "title": "Creating a new stack",
    "content": "To create a local FireFly development stack and connect it to the Avalanche Fuji testnet, we will use command line flags to customize the following settings: . | Create a new stack named avalanche with 1 member | Disable multiparty mode. We are going to be using this FireFly node as a Web3 gateway, and we don’t need to communicate with a consortium here | Connect to an ethereum network | Use the evmconnect blockchain connector | Use an remote RPC node. This will create a signer locally, so that our signing key never leaves the development machine. | See the Avalance docs and select and HTTPS RPC endpoint. | Set the chain ID to 43113 (the correct ID for the Avalanche Fuji testnet) | Merge the custom config created above with the generated evmconnect config file | . To do this, run the following command: . ff init avalanche 1 \\ --multiparty=false \\ -b ethereum \\ -c evmconnect \\ -n remote-rpc \\ --remote-node-url &lt;selected RPC endpoint&gt; \\ --chain-id 43113 \\ --connector-config ~/Desktop/evmconnect.yml . ",
    "url": "/firefly/head/tutorials/chains/avalanche.html#creating-a-new-stack",
    "relUrl": "/tutorials/chains/avalanche.html#creating-a-new-stack"
  },"34": {
    "doc": "pages.avalanche",
    "title": "Start the stack",
    "content": "Now you should be able to start your stack by running: . ff start avalanche . After some time it should print out the following: . Web UI for member '0': http://127.0.0.1:5000/ui Sandbox UI for member '0': http://127.0.0.1:5109 To see logs for your stack run: ff logs avalanche . ",
    "url": "/firefly/head/tutorials/chains/avalanche.html#start-the-stack",
    "relUrl": "/tutorials/chains/avalanche.html#start-the-stack"
  },"35": {
    "doc": "pages.avalanche",
    "title": "Get some AVAX",
    "content": "At this point you should have a working FireFly stack, talking to a public chain. However, you won’t be able to run any transactions just yet, because you don’t have any way to pay for gas. A testnet faucet can give us some AVAX, the native token for Avalanche. First, you will need to know what signing address your FireFly node is using. To check that, you can run: . ff accounts list avalanche [ { \"address\": \"0x6688e14f719766cc2a5856ccef63b069703d86f7\", \"privateKey\": \"...\" } ] . Copy the address listed in the output from this command. Go to https://faucet.avax.network/ and paste the address in the form. Make sure that the network you select is Fuji (C-Chain). Click the Request 2 AVAX button. Confirm the transaction on Snowtrace . You should be able to go lookup your account on Snowtrace for the Fuji testnet and see that you now have a balance of 2 AVAX. Simply paste in your account address or transaction ID to search for it. ",
    "url": "/firefly/head/tutorials/chains/avalanche.html#get-some-avax",
    "relUrl": "/tutorials/chains/avalanche.html#get-some-avax"
  },"36": {
    "doc": "pages.avalanche",
    "title": "Use the public testnet",
    "content": "Now that you have everything set up, you can follow one of the other FireFly guides such as Using Tokens or Custom Smart Contracts. For detailed instructions on deploying a custom smart contract to Avalanche, please see the Avalanche docs for instructions using various tools. ",
    "url": "/firefly/head/tutorials/chains/avalanche.html#use-the-public-testnet",
    "relUrl": "/tutorials/chains/avalanche.html#use-the-public-testnet"
  },"37": {
    "doc": "pages.avalanche",
    "title": "pages.avalanche",
    "content": " ",
    "url": "/firefly/head/tutorials/chains/avalanche.html",
    "relUrl": "/tutorials/chains/avalanche.html"
  },"38": {
    "doc": "Batch",
    "title": "Batch",
    "content": " ",
    "url": "/firefly/head/reference/types/batch.html",
    "relUrl": "/reference/types/batch.html"
  },"39": {
    "doc": "Batch",
    "title": "Table of contents",
    "content": ". | Batch . | Example | Field Descriptions | . | BatchPayload | TransactionRef | . ",
    "url": "/firefly/head/reference/types/batch.html#table-of-contents",
    "relUrl": "/reference/types/batch.html#table-of-contents"
  },"40": {
    "doc": "Batch",
    "title": "Batch",
    "content": "A batch bundles a number of off-chain messages, with associated data, into a single payload for broadcast or private transfer. This allows the transfer of many messages (hundreds) to be backed by a single blockchain transaction. Thus making very efficient use of the blockchain. The same benefit also applies to the off-chain transport mechanism. Shared storage operations benefit from the same optimization. In IPFS for example chunks are 256Kb in size, so there is a great throughput benefit in packaging many small messages into a single large payload. For a data exchange transport, there is often cryptography and transport overhead for each individual transport level send between participants. This is particularly true if using a data exchange transport with end-to-end payload encryption, using public/private key cryptography for the envelope. Example . { \"id\": \"894bc0ea-0c2e-4ca4-bbca-b4c39a816bbb\", \"type\": \"private\", \"namespace\": \"ns1\", \"node\": \"5802ab80-fa71-4f52-9189-fb534de93756\", \"group\": \"cd1fedb69fb83ad5c0c62f2f5d0b04c59d2e41740916e6815a8e063b337bd32e\", \"created\": \"2022-05-16T01:23:16Z\", \"author\": \"did:firefly:org/example\", \"key\": \"0x0a989907dcd17272257f3ebcf72f4351df65a846\", \"hash\": \"78d6861f860c8724468c9254b99dc09e7d9fd2d43f26f7bd40ecc9ee47be384d\", \"payload\": { \"tx\": { \"type\": \"private\", \"id\": \"04930d84-0227-4044-9d6d-82c2952a0108\" }, \"messages\": [], \"data\": [] } } . Field Descriptions . | Field Name | Description | Type | . | id | The UUID of the batch | UUID | . | type | The type of the batch | FFEnum:\"broadcast\"\"private\" | . | namespace | The namespace of the batch | string | . | node | The UUID of the node that generated the batch | UUID | . | group | The privacy group the batch is sent to, for private batches | Bytes32 | . | created | The time the batch was sealed | FFTime | . | author | The DID of identity of the submitter | string | . | key | The on-chain signing key used to sign the transaction | string | . | hash | The hash of the manifest of the batch | Bytes32 | . | payload | Batch.payload | BatchPayload | . ",
    "url": "/firefly/head/reference/types/batch.html",
    "relUrl": "/reference/types/batch.html"
  },"41": {
    "doc": "Batch",
    "title": "BatchPayload",
    "content": "| Field Name | Description | Type | . | tx | BatchPayload.tx | TransactionRef | . | messages | BatchPayload.messages | Message[] | . | data | BatchPayload.data | Data[] | . ",
    "url": "/firefly/head/reference/types/batch.html#batchpayload",
    "relUrl": "/reference/types/batch.html#batchpayload"
  },"42": {
    "doc": "Batch",
    "title": "TransactionRef",
    "content": "| Field Name | Description | Type | . | type | The type of the FireFly transaction | FFEnum: | . | id | The UUID of the FireFly transaction | UUID | . ",
    "url": "/firefly/head/reference/types/batch.html#transactionref",
    "relUrl": "/reference/types/batch.html#transactionref"
  },"43": {
    "doc": "pages.binance_smart_chain",
    "title": "Binance Smartchain Testnet",
    "content": " ",
    "url": "/firefly/head/tutorials/chains/binance_smart_chain.html#binance-smartchain-testnet",
    "relUrl": "/tutorials/chains/binance_smart_chain.html#binance-smartchain-testnet"
  },"44": {
    "doc": "pages.binance_smart_chain",
    "title": "Table of contents",
    "content": ". | Previous steps: Install the FireFly CLI | Create an evmconnect.yml config file | Creating a new stack | Start the stack | Get some BNB . | Confirm the transaction on Bscscan | . | Use the public testnet | . Starting with FireFly v1.1, it’s easy to connect to public Ethereum chains. This guide will walk you through the steps to create a local FireFly development environment and connect it to the public Binance Smart Chain testnet. ",
    "url": "/firefly/head/tutorials/chains/binance_smart_chain.html#table-of-contents",
    "relUrl": "/tutorials/chains/binance_smart_chain.html#table-of-contents"
  },"45": {
    "doc": "pages.binance_smart_chain",
    "title": "Previous steps: Install the FireFly CLI",
    "content": "If you haven’t set up the FireFly CLI already, please go back to the Getting Started guide and read the section on how to Install the FireFly CLI. ← ① Install the FireFly CLI . ",
    "url": "/firefly/head/tutorials/chains/binance_smart_chain.html#previous-steps-install-the-firefly-cli",
    "relUrl": "/tutorials/chains/binance_smart_chain.html#previous-steps-install-the-firefly-cli"
  },"46": {
    "doc": "pages.binance_smart_chain",
    "title": "Create an evmconnect.yml config file",
    "content": "In order to connect to the Binance Smart Chain testnet, you will need to set a few configuration options for the evmconnect blockchain connector. Create a text file called evmconnect.yml with the following contents: . confirmations: required: 4 # choose the number of confirmations you require policyengine.simple: fixedGasPrice: null gasOracle: mode: connector . For more info about confirmations, see Public vs. Permissioned . For this tutorial, we will assume this file is saved at ~/Desktop/evmconnect.yml. If your path is different, you will need to adjust the path in the next command below. ",
    "url": "/firefly/head/tutorials/chains/binance_smart_chain.html#create-an-evmconnectyml-config-file",
    "relUrl": "/tutorials/chains/binance_smart_chain.html#create-an-evmconnectyml-config-file"
  },"47": {
    "doc": "pages.binance_smart_chain",
    "title": "Creating a new stack",
    "content": "To create a local FireFly development stack and connect it to the Binance Smart Chain testnet, we will use command line flags to customize the following settings: . | Create a new stack named bsc with 1 member | Disable multiparty mode. We are going to be using this FireFly node as a Web3 gateway, and we don’t need to communicate with a consortium here | Connect to an ethereum network | Use the evmconnect blockchain connector | Use an remote RPC node. This will create a signer locally, so that our signing key never leaves the development machine. | See the Binance BscScan docs and select an HTTPS RPC endpoint. | Set the chain ID to 97 (the correct ID for the Binance Smart Chain testnet) | Merge the custom config created above with the generated evmconnect config file | . To do this, run the following command: . ff init bsc 1 \\ --multiparty=false \\ -b ethereum \\ -c evmconnect \\ -n remote-rpc \\ --remote-node-url &lt;selected RPC endpoint&gt; \\ --chain-id 97 \\ --connector-config ~/Desktop/evmconnect.yml . ",
    "url": "/firefly/head/tutorials/chains/binance_smart_chain.html#creating-a-new-stack",
    "relUrl": "/tutorials/chains/binance_smart_chain.html#creating-a-new-stack"
  },"48": {
    "doc": "pages.binance_smart_chain",
    "title": "Start the stack",
    "content": "Now you should be able to start your stack by running: . ff start bsc . After some time it should print out the following: . Web UI for member '0': http://127.0.0.1:5000/ui Sandbox UI for member '0': http://127.0.0.1:5109 To see logs for your stack run: ff logs bsc . ",
    "url": "/firefly/head/tutorials/chains/binance_smart_chain.html#start-the-stack",
    "relUrl": "/tutorials/chains/binance_smart_chain.html#start-the-stack"
  },"49": {
    "doc": "pages.binance_smart_chain",
    "title": "Get some BNB",
    "content": "At this point you should have a working FireFly stack, talking to a public chain. However, you won’t be able to run any transactions just yet, because you don’t have any way to pay for gas. A testnet faucet can give us some BNB, the native token for Binance Smart Chain. First, you will need to know what signing address your FireFly node is using. To check that, you can run: . ff accounts list bsc [ { \"address\": \"0x235461d246ab95d367925b4e91bd2755a921fdd8\", \"privateKey\": \"...\" } ] . Copy the address listed in the output from this command. Go to https://testnet.binance.org/faucet-smart and paste the address in the form. Go through the CAPTCH form and click the Give me BNB button. Confirm the transaction on Bscscan . You should be able to go lookup your account on Bscscan for the testnet https://testnet.bscscan.com/ and see that you now have a balance of 0.5 BNB. Simply paste in your account address to search for it. ",
    "url": "/firefly/head/tutorials/chains/binance_smart_chain.html#get-some-bnb",
    "relUrl": "/tutorials/chains/binance_smart_chain.html#get-some-bnb"
  },"50": {
    "doc": "pages.binance_smart_chain",
    "title": "Use the public testnet",
    "content": "Now that you have everything set up, you can follow one of the other FireFly guides such as Using Tokens or Custom Smart Contracts. For detailed instructions on deploying a custom smart contract to Binance Smart Chain, please see the Binance docs for instructions using various tools. ",
    "url": "/firefly/head/tutorials/chains/binance_smart_chain.html#use-the-public-testnet",
    "relUrl": "/tutorials/chains/binance_smart_chain.html#use-the-public-testnet"
  },"51": {
    "doc": "pages.binance_smart_chain",
    "title": "pages.binance_smart_chain",
    "content": " ",
    "url": "/firefly/head/tutorials/chains/binance_smart_chain.html",
    "relUrl": "/tutorials/chains/binance_smart_chain.html"
  },"52": {
    "doc": "pages.blockchain_protocols",
    "title": "Blockchain protocols",
    "content": " ",
    "url": "/firefly/head/overview/blockchain_protocols.html#blockchain-protocols",
    "relUrl": "/overview/blockchain_protocols.html#blockchain-protocols"
  },"53": {
    "doc": "pages.blockchain_protocols",
    "title": "Table of contents",
    "content": ". | Supporting multiple blockchain protocols | Core constructs and custom on-chain logic | Blockchain interface plugins | Need help choosing the right blockchain ledger technology? | . ",
    "url": "/firefly/head/overview/blockchain_protocols.html#table-of-contents",
    "relUrl": "/overview/blockchain_protocols.html#table-of-contents"
  },"54": {
    "doc": "pages.blockchain_protocols",
    "title": "Supporting multiple blockchain protocols",
    "content": "A blockchain DLT technology is usually the beating heart of a multi-party system, critical to the new trust and privacy models being established. The FireFly API provides an interface for the blockchain tier that is fully pluggable. So you can choose the blockchain ecosystem that best meets the functional and non-functional requirements of your business network, and still benefit from the developer friendly APIs, event-driven programming model, and on-chain/off-chain coordination provided by FireFly. ",
    "url": "/firefly/head/overview/blockchain_protocols.html#supporting-multiple-blockchain-protocols",
    "relUrl": "/overview/blockchain_protocols.html#supporting-multiple-blockchain-protocols"
  },"55": {
    "doc": "pages.blockchain_protocols",
    "title": "Core constructs and custom on-chain logic",
    "content": "Core blockchain programming patterns like pinning proofs to the chain, fungible tokens, and non-fungible tokens are abstracted into a common API, so that higher level services can be provided on top of those - such as transaction history for tokens, or on-chain/off-chain pinning of data. You can think of these a little like the core CRUD interfaces of a traditional database technology. They are the foundation actions that any developer needs to build a multi-party system, without necessarily being a blockchain specialist. Wherever possible, reference implementations of the on-chain logic should be used, that have been peer reviewed through open source collaboration and/or wide production adoption. For fully custom smart contract logic outside of these foundation constructs, FireFly provides a passthrough mechanism. This means your applications can use the FireFly API and reliable events for simple access to the blockchain technology, while interacting with rich on-chain logic. So application developers get REST APIs that still abstract away the mechanics of how transaction submission and events work in the low level RPC interfaces of the blockchain technologies. However, the on-chain logic can be anything supported by the blockchain itself. You can think of these a little like the stored procedures of a traditional database technology. These allow execution of an exact piece of logic to be performed with a deterministic outcome, using only data stored inside of the blockchain itself. One well established way of assuring mutual agreement on an outcome in a multi-party system. Development of custom smart contracts is usually done by a specialist team that understands the technology in detail. They are often subject to additional specialist scrutiny such as multi-party review, and external code audit. FireFly is deliberately one step detached from the deployment, upgrade, and maintenance of this on-chain logic. This approach applies to both the foundational constructs, and the fully custom on-chain logic. We leave the best practice on this specialist activity to the the individual blockchain communities. However, the CLI for developers does automate deployment of a reference set of contracts to get you started. A popular approach to innovation in enterprise use cases, is to make small internal customizations to the operation of standardized peer-reviewed logic (such as token contracts), without updating the interface. This can allow you to still give the full FireFly API experience to Web/API use case developers (such as a cached transaction history API for tokens), while allowing the kinds of innovation only possible by updating the logic on-chain. ",
    "url": "/firefly/head/overview/blockchain_protocols.html#core-constructs-and-custom-on-chain-logic",
    "relUrl": "/overview/blockchain_protocols.html#core-constructs-and-custom-on-chain-logic"
  },"56": {
    "doc": "pages.blockchain_protocols",
    "title": "Blockchain interface plugins",
    "content": "Different blockchains provide different features, such as multiple separate ledgers (Fabric channels etc.) or private transaction execution (Tessera etc.). These are mapped to high-level core constructs in the FireFly model, but with protocol specific configuration that can be passed through from the FireFly API to the blockchain interface. There are sub-communities building the blockchain interfaces for each of the “big 3”: . | Ethereum (Hyperledger Besu, Quorum, Go-ethereum) . | Status: Mature | Repo: hyperledger/firefly-ethconnect | . | Hyperledger Fabric . | Status: Mature | Repo: hyperledger/firefly-fabconnect | . | Corda . | Status: Core model proven. Requires bespoke customization to each CorDapp | Repo: hyperledger/firefly-cordaconnect | . | . ",
    "url": "/firefly/head/overview/blockchain_protocols.html#blockchain-interface-plugins",
    "relUrl": "/overview/blockchain_protocols.html#blockchain-interface-plugins"
  },"57": {
    "doc": "pages.blockchain_protocols",
    "title": "Need help choosing the right blockchain ledger technology?",
    "content": "The following article might help you compare and contrast: . | Enterprise Blockchain Protocols: A Technical Analysis of Ethereum vs Fabric vs Corda | . ",
    "url": "/firefly/head/overview/blockchain_protocols.html#need-help-choosing-the-right-blockchain-ledger-technology",
    "relUrl": "/overview/blockchain_protocols.html#need-help-choosing-the-right-blockchain-ledger-technology"
  },"58": {
    "doc": "pages.blockchain_protocols",
    "title": "pages.blockchain_protocols",
    "content": " ",
    "url": "/firefly/head/overview/blockchain_protocols.html",
    "relUrl": "/overview/blockchain_protocols.html"
  },"59": {
    "doc": "BlockchainEvent",
    "title": "BlockchainEvent",
    "content": " ",
    "url": "/firefly/head/reference/types/blockchainevent.html",
    "relUrl": "/reference/types/blockchainevent.html"
  },"60": {
    "doc": "BlockchainEvent",
    "title": "Table of contents",
    "content": ". | BlockchainEvent . | Protocol ID | Example | Field Descriptions | . | BlockchainTransactionRef | . ",
    "url": "/firefly/head/reference/types/blockchainevent.html#table-of-contents",
    "relUrl": "/reference/types/blockchainevent.html#table-of-contents"
  },"61": {
    "doc": "BlockchainEvent",
    "title": "BlockchainEvent",
    "content": "Blockchain Events are detected by the blockchain plugin: . | When a ContractListener has been configured against any custom smart contract through the FireFly API | Indirectly via a Token Connector, which understands the correct events to listen to for a Token Pool configured against a standard such as ERC-20/ERC-721/ERC-1155 | Automatically by FireFly core, for the BatchPin contract that can be used for high throughput batched pinning of off-chain data transfers to the blockchain (complementary to using your own smart contracts). | . Protocol ID . Each Blockchain Event (once final) exists in an absolute location somewhere in the transaction history of the blockchain. A particular slot, in a particular block. How to describe that position contains blockchain specifics - depending on how a particular blockchain represents transactions, blocks and events (or “logs”). So FireFly is flexible with a string protocolId in the core object to represent this location, and then there is a convention that is adopted by the blockchain plugins to try and create some consistency. An example protocolId string is: 000000000041/000020/000003 . | 000000000041 - this is the block number | 000020 - this is the transaction index within that block | 000003 - this is the event (/log) index within that transaction | . The string is alphanumerically sortable as a plain string; . Sufficient zero padding is included at each layer to support future expansion without creating a string that would no longer sort correctly. Example . { \"id\": \"e9bc4735-a332-4071-9975-b1066e51ab8b\", \"source\": \"ethereum\", \"namespace\": \"ns1\", \"name\": \"MyEvent\", \"listener\": \"c29b4595-03c2-411a-89e3-8b7f27ef17bb\", \"protocolId\": \"000000000048/000000/000000\", \"output\": { \"addr1\": \"0x55860105d6a675dbe6e4d83f67b834377ba677ad\", \"value2\": \"42\" }, \"info\": { \"address\": \"0x57A9bE18CCB50D06B7567012AaF6031D669BBcAA\", \"blockHash\": \"0xae7382ef2573553f517913b927d8b9691ada8d617266b8b16f74bb37aa78cae8\", \"blockNumber\": \"48\", \"logIndex\": \"0\", \"signature\": \"Changed(address,uint256)\", \"subId\": \"sb-e4d5efcd-2eba-4ed1-43e8-24831353fffc\", \"timestamp\": \"1653048837\", \"transactionHash\": \"0x34b0327567fefed09ac7b4429549bc609302b08a9cbd8f019a078ec44447593d\", \"transactionIndex\": \"0x0\" }, \"timestamp\": \"2022-05-16T01:23:15Z\", \"tx\": { \"blockchainId\": \"0x34b0327567fefed09ac7b4429549bc609302b08a9cbd8f019a078ec44447593d\" } } . Field Descriptions . | Field Name | Description | Type | . | id | The UUID assigned to the event by FireFly | UUID | . | source | The blockchain plugin or token service that detected the event | string | . | namespace | The namespace of the listener that detected this blockchain event | string | . | name | The name of the event in the blockchain smart contract | string | . | listener | The UUID of the listener that detected this event, or nil for built-in events in the system namespace | UUID | . | protocolId | An alphanumerically sortable string that represents this event uniquely on the blockchain (convention for plugins is zero-padded values BLOCKNUMBER/TXN_INDEX/EVENT_INDEX) | string | . | output | The data output by the event, parsed to JSON according to the interface of the smart contract | JSONObject | . | info | Detailed blockchain specific information about the event, as generated by the blockchain connector | JSONObject | . | timestamp | The time allocated to this event by the blockchain. This is the block timestamp for most blockchain connectors | FFTime | . | tx | If this blockchain event is coorelated to FireFly transaction such as a FireFly submitted token transfer, this field is set to the UUID of the FireFly transaction | BlockchainTransactionRef | . ",
    "url": "/firefly/head/reference/types/blockchainevent.html",
    "relUrl": "/reference/types/blockchainevent.html"
  },"62": {
    "doc": "BlockchainEvent",
    "title": "BlockchainTransactionRef",
    "content": "| Field Name | Description | Type | . | type | The type of the FireFly transaction | FFEnum: | . | id | The UUID of the FireFly transaction | UUID | . | blockchainId | The blockchain transaction ID, in the format specific to the blockchain involved in the transaction. Not all FireFly transactions include a blockchain | string | . ",
    "url": "/firefly/head/reference/types/blockchainevent.html#blockchaintransactionref",
    "relUrl": "/reference/types/blockchainevent.html#blockchaintransactionref"
  },"63": {
    "doc": "pages.broadcast_shared_data",
    "title": "Broadcast / shared data",
    "content": " ",
    "url": "/firefly/head/overview/broadcast.html#broadcast--shared-data",
    "relUrl": "/overview/broadcast.html#broadcast--shared-data"
  },"64": {
    "doc": "pages.broadcast_shared_data",
    "title": "Table of contents",
    "content": ". | Introduction | Blockchain backed broadcast | Shared data | FireFly built-in broadcasts | Network Registry | . ",
    "url": "/firefly/head/overview/broadcast.html#table-of-contents",
    "relUrl": "/overview/broadcast.html#table-of-contents"
  },"65": {
    "doc": "pages.broadcast_shared_data",
    "title": "Introduction",
    "content": "Multi-party systems are about establishing a shared source of truth, and often that needs to include certain reference data that is available to all parties in the network. The data needs to be “broadcast” to all members, and also need to be available to new members that join the network . ",
    "url": "/firefly/head/overview/broadcast.html#introduction",
    "relUrl": "/overview/broadcast.html#introduction"
  },"66": {
    "doc": "pages.broadcast_shared_data",
    "title": "Blockchain backed broadcast",
    "content": "In order to maintain a complete history of all broadcast data for new members joining the network, FireFly uses the blockchain to sequence the broadcasts with pinning transactions referring to the data itself. Using the blockchain also gives a global order of events for these broadcasts, which allows them to be processed by each member in a way that allows them to derive the same result - even though the processing logic on the events themselves is being performed independently by each member. For more information see Global sequencing. ",
    "url": "/firefly/head/overview/broadcast.html#blockchain-backed-broadcast",
    "relUrl": "/overview/broadcast.html#blockchain-backed-broadcast"
  },"67": {
    "doc": "pages.broadcast_shared_data",
    "title": "Shared data",
    "content": "The data included in broadcasts is not recorded on the blockchain. Instead a pluggable shared storage mechanism is used to contain the data itself. The on-chain transaction just contains a hash of the data that is stored off-chain. This is because the data itself might be too large to be efficiently stored and transferred via the blockchain itself, or subject to deletion at some point in the future through agreement by the members in the network. While the data should be reliably stored with visibility to all members of the network, the data can still be secured from leakage outside of the network. The InterPlanetary File System (IPFS) is an example of a distributed technology for peer-to-peer storage and distribution of such data in a decentralized multi-party system. It provides secure connectivity between a number of nodes, combined with a decentralized index of data that is available, and native use of hashes within the technology as the way to reference data by content. ",
    "url": "/firefly/head/overview/broadcast.html#shared-data",
    "relUrl": "/overview/broadcast.html#shared-data"
  },"68": {
    "doc": "pages.broadcast_shared_data",
    "title": "FireFly built-in broadcasts",
    "content": "FireFly uses the broadcast mechanism internally to distribute key information to all parties in the network: . | Network map . | Organizational identities | Nodes | See Identity for more information | . | Datatype definitions . | See Agreed datatypes for more information | . | Namespaces . | See Namespaces for more information | . | . These definitions rely on the same assurances provided by blockchain backed broadcast that FireFly applications do. | Verification of the identity of the party in the network that performed the broadcast | Deterministic assignment of a namespace+name to an unique item of data . | If two parties in the network broadcast the same data at similar times, the same one “wins” for all parties in the network (including the broadcaster) | . | . ",
    "url": "/firefly/head/overview/broadcast.html#firefly-built-in-broadcasts",
    "relUrl": "/overview/broadcast.html#firefly-built-in-broadcasts"
  },"69": {
    "doc": "pages.broadcast_shared_data",
    "title": "Network Registry",
    "content": "Work in progress . Using a permissioned blockchain and shared data network provides a security mechanism to protect against broadcast data being published from outside of the network. However, some networks might have additional permissioning and security requirements on joining the network. As such FireFly defines a plug-point for a Network Registry that defines a way to establish authorization to perform a broadcast (that is decoupled from the blockchain and shared data tiers themselves). ",
    "url": "/firefly/head/overview/broadcast.html#network-registry",
    "relUrl": "/overview/broadcast.html#network-registry"
  },"70": {
    "doc": "pages.broadcast_shared_data",
    "title": "pages.broadcast_shared_data",
    "content": " ",
    "url": "/firefly/head/overview/broadcast.html",
    "relUrl": "/overview/broadcast.html"
  },"71": {
    "doc": "pages.broadcast_data",
    "title": "Broadcast data",
    "content": " ",
    "url": "/firefly/head/tutorials/broadcast_data.html#broadcast-data",
    "relUrl": "/tutorials/broadcast_data.html#broadcast-data"
  },"72": {
    "doc": "pages.broadcast_data",
    "title": "Table of contents",
    "content": ". | Quick reference | Additional info | Example 1: Inline string data | Example message response | Example 2: Inline object data to a topic (no datatype verification) | Notes on why setting a topic is important | Example 3: Upload a blob with metadata and broadcast . | Multipart form post of a file | Example data response from Blob upload | Broadcast the uploaded data | . | Broadcasting Messages using the Sandbox | . ",
    "url": "/firefly/head/tutorials/broadcast_data.html#table-of-contents",
    "relUrl": "/tutorials/broadcast_data.html#table-of-contents"
  },"73": {
    "doc": "pages.broadcast_data",
    "title": "Quick reference",
    "content": ". | Sends a message visible to all parties in the network . | The message describes who sent it, and exactly what data was sent | . | A message has one or more attached pieces of business data . | Can be sent in-line, uploaded in advanced, or received from other parties | Can include smaller JSON payloads suitable for database storage . | These can be verified against a datatype | . | Can include references to large (multi megabyte/gigabyte) Blob data | . | Sequenced via the blockchain . | The blockchain does not contain any data, just a hash pin | . | Batched for efficiency . | One batch can pin hundreds of message broadcasts | The whole batch is written to the shared storage | . | . ",
    "url": "/firefly/head/tutorials/broadcast_data.html#quick-reference",
    "relUrl": "/tutorials/broadcast_data.html#quick-reference"
  },"74": {
    "doc": "pages.broadcast_data",
    "title": "Additional info",
    "content": ". | Key Concepts: Broadcast / shared data | Swagger Reference: POST /api/v1/namespaces/{ns}/messages/broadcast | . ",
    "url": "/firefly/head/tutorials/broadcast_data.html#additional-info",
    "relUrl": "/tutorials/broadcast_data.html#additional-info"
  },"75": {
    "doc": "pages.broadcast_data",
    "title": "Example 1: Inline string data",
    "content": "POST /api/v1/namespaces/default/messages/broadcast . { \"data\": [ { \"value\": \"a string\" } ] } . ",
    "url": "/firefly/head/tutorials/broadcast_data.html#example-1-inline-string-data",
    "relUrl": "/tutorials/broadcast_data.html#example-1-inline-string-data"
  },"76": {
    "doc": "pages.broadcast_data",
    "title": "Example message response",
    "content": "{ \"header\": { \"id\": \"607e22ad-04fa-434a-a073-54f528ca14fb\", // uniquely identifies this broadcast message \"type\": \"broadcast\", // set automatically \"txtype\": \"batch_pin\", // message will be batched, and sequenced via the blockchain \"author\": \"0x0a65365587a65ce44938eab5a765fe8bc6532bdf\", // set automatically in this example to the node org \"created\": \"2021-07-01T18:06:24.5817016Z\", // set automatically \"namespace\": \"default\", // the 'default' namespace was set in the URL \"topics\": [ \"default\" // the default topic that the message is published on, if no topic is set ], // datahash is calculated from the data array below \"datahash\": \"5a7bbc074441fa3231d9c8fc942d68ef9b9b646dd234bb48c57826dc723b26fd\" }, \"hash\": \"81acf8c8f7982dbc49258535561461601cbe769752fecec0f8ce0358664979e6\", // hash of the header \"state\": \"ready\", // this message is stored locally but not yet confirmed \"data\": [ // one item of data was stored { \"id\": \"8d8635e2-7c90-4963-99cc-794c98a68b1d\", // can be used to query the data in the future \"hash\": \"c95d6352f524a770a787c16509237baf7eb59967699fb9a6d825270e7ec0eacf\" // sha256 hash of `\"a string\"` } ] } . ",
    "url": "/firefly/head/tutorials/broadcast_data.html#example-message-response",
    "relUrl": "/tutorials/broadcast_data.html#example-message-response"
  },"77": {
    "doc": "pages.broadcast_data",
    "title": "Example 2: Inline object data to a topic (no datatype verification)",
    "content": "It is very good practice to set a tag and topic in each of your messages: . | tag should tell the apps receiving the broadcast (including the local app), what to do when it receives the message. Its the reason for the broadcast - an application specific type for the message. | topic should be something like a well known identifier that relates to the information you are publishing. It is used as an ordering context, so all broadcasts on a given topic are assured to be processed in order. | . POST /api/v1/namespaces/default/messages/broadcast . { \"header\": { \"tag\": \"new_widget_created\", \"topics\": [\"widget_id_12345\"] }, \"data\": [ { \"value\": { \"id\": \"widget_id_12345\", \"name\": \"superwidget\" } } ] } . ",
    "url": "/firefly/head/tutorials/broadcast_data.html#example-2-inline-object-data-to-a-topic-no-datatype-verification",
    "relUrl": "/tutorials/broadcast_data.html#example-2-inline-object-data-to-a-topic-no-datatype-verification"
  },"78": {
    "doc": "pages.broadcast_data",
    "title": "Notes on why setting a topic is important",
    "content": "The FireFly aggregator uses the topic (obfuscated on chain) to determine if a message is the next message in an in-flight sequence for any groups the node is involved in. If it is, then that message must receive all off-chain private data and be confirmed before any subsequent messages can be confirmed on the same sequence. So if you use the same topic in every message, then a single failed send on one topic blocks delivery of all messages between those parties, until the missing data arrives. Instead it is best practice to set the topic on your messages to a value that identifies an ordered stream of business processing. Some examples: . | A long-running business process instance identifier assigned at initiation | A real-world business transaction identifier used off-chain | The agreed identifier of an asset you are attaching a stream of evidence to | An NFT identifier that is assigned to an asset (digital twin scenarios) | An agreed primary key for a data resource being reconciled between multiple parties | . The topic field is an array, because there are cases (such as merging two identifiers) where you need a message to be deterministically ordered across multiple sequences. However, this is an advanced use case and you are likely to set a single topic on the vast majority of your messages. ",
    "url": "/firefly/head/tutorials/broadcast_data.html#notes-on-why-setting-a-topic-is-important",
    "relUrl": "/tutorials/broadcast_data.html#notes-on-why-setting-a-topic-is-important"
  },"79": {
    "doc": "pages.broadcast_data",
    "title": "Example 3: Upload a blob with metadata and broadcast",
    "content": "Here we make two API calls. 1) Create the data object explicitly, using a multi-party form upload . | You can also just post JSON to this endpoint | . 2) Broadcast a message referring to that data . | The Blob attachment gets published to shared storage . | This happens the first time a broadcast happens on a data attachment | . | A pin goes to the blockchain | The metadata goes into a batch with the message | . Multipart form post of a file . Example curl command (Linux/Mac) to grab an image from the internet, and pipe it into a multi-part form post to FireFly. Note we use autometa to cause FireFly to automatically add the filename, and size, to the JSON part of the data object for us. curl -sLo - https://github.com/hyperledger/firefly/raw/main/docs/firefly_logo.png \\ | curl --form autometa=true --form file=@- \\ http://localhost:5000/api/v1/namespaces/default/data . Example data response from Blob upload . Status: 200 OK - your data is uploaded to your local FireFly node . At this point the data has not be shared with anyone else in the network . { // A uniquely generated ID, we can refer to when sending this data to other parties \"id\": \"97eb750f-0d0b-4c1d-9e37-1e92d1a22bb8\", \"validator\": \"json\", // the \"value\" part is JSON \"namespace\": \"default\", // from the URL // The hash is a combination of the hash of the \"value\" metadata, and the // hash of the blob \"hash\": \"997af6a9a19f06cc8a46872617b8bf974b106f744b2e407e94cc6959aa8cf0b8\", \"created\": \"2021-07-01T20:20:35.5462306Z\", \"value\": { \"filename\": \"-\", // dash is how curl represents the filename for stdin \"size\": 31185 // the size of the blob data }, \"blob\": { // A hash reference to the blob \"hash\": \"86e6b39b04b605dd1b03f70932976775962509d29ae1ad2628e684faabe48136\" // Note at this point there is no public reference. The only place // this data has been uploaded to is our own private data exchange. // It's ready to be published to everyone (broadcast), or privately // transferred (send) to other parties in the network. But that hasn't // happened yet. } } . Broadcast the uploaded data . Just include a reference to the id returned from the upload. POST /api/v1/namespaces/default/messages/broadcast . { \"data\": [ { \"id\": \"97eb750f-0d0b-4c1d-9e37-1e92d1a22bb8\" } ] } . ",
    "url": "/firefly/head/tutorials/broadcast_data.html#example-3-upload-a-blob-with-metadata-and-broadcast",
    "relUrl": "/tutorials/broadcast_data.html#example-3-upload-a-blob-with-metadata-and-broadcast"
  },"80": {
    "doc": "pages.broadcast_data",
    "title": "Broadcasting Messages using the Sandbox",
    "content": "All of the functionality discussed above can be done through the FireFly Sandbox. To get started, open up the Web UI and Sanbox UI for at least one of your members. The URLs for these were printed in your terminal when you started your FireFly stack. In the sandbox, enter your message into the message field as seen in the screenshot below. Notice how the data field in the center panel updates in real time. Click the blue Run button. This should return a 202 response immediately in the Server Response section and will populate the right hand panel with transaction information after a few seconds. Go back to the FireFly UI (the URL for this would have been shown in the terminal when you started the stack) and you’ll see your successful blockchain transaction . ",
    "url": "/firefly/head/tutorials/broadcast_data.html#broadcasting-messages-using-the-sandbox",
    "relUrl": "/tutorials/broadcast_data.html#broadcasting-messages-using-the-sandbox"
  },"81": {
    "doc": "pages.broadcast_data",
    "title": "pages.broadcast_data",
    "content": " ",
    "url": "/firefly/head/tutorials/broadcast_data.html",
    "relUrl": "/tutorials/broadcast_data.html"
  },"82": {
    "doc": "pages.code_hierarchy",
    "title": "Firefly Code Hierarchy",
    "content": " ",
    "url": "/firefly/head/contributors/code_hierarchy.html#firefly-code-hierarchy",
    "relUrl": "/contributors/code_hierarchy.html#firefly-code-hierarchy"
  },"83": {
    "doc": "pages.code_hierarchy",
    "title": "Table of contents",
    "content": ". Use the following diagram to better understand the hierarchy amongst the core FireFly components, plugins and utility frameworks: . ┌──────────┐ ┌───────────────┐ │ cmd ├──┤ firefly [Ff]│ - CLI entry point └──────────┘ │ │ - Creates parent context │ │ - Signal handling └─────┬─────────┘ │ ┌──────────┐ ┌─────┴─────────┐ - HTTP listener (Gorilla mux) │ internal ├──┤ api [As]│ * TLS (SSL), CORS configuration etc. └──────────┘ │ server │ * WS upgrade on same port │ │ - REST route definitions └─────┬─────────┘ * Simple routing logic only, all processing deferred to orchestrator │ ┌─────┴─────────┐ - REST route definition framework │ openapi [Oa]│ * Standardizes Body, Path, Query, Filter semantics │ spec | - OpenAPI 3.0 (Swagger) generation └─────┬─────────┘ * Including Swagger. UI │ ┌─────┴─────────┐ - WebSocket server │ [Ws]│ * Developer friendly JSON based protocol business app development │ websockets │ * Reliable sequenced delivery └─────┬─────────┘ * _Event interface [Ei] supports lower level integration with other compute frameworks/transports_ │ ┌─────┴─────────┐ - Extension point interface to listen for database change events │ admin [Ae]│ * For building microservice extensions to the core that run externally │ events | * Used by the Transaction Manager component └─────┬─────────┘ * Filtering to specific object types │ ┌─────┴─────────┐ - Core data types │ fftypes [Ft]│ * Used for API and Serialization │ │ * APIs can mask fields on input via router definition └─────┬─────────┘ │ ┌─────┴─────────┐ - Core runtime server. Initializes and owns instances of: │ [Or]│ * Components: Implement features ┌───────┬───┤ orchestrator │ * Plugins: Pluggable infrastructure services │ │ │ │ - Exposes actions to router │ │ └───────────────┘ * Processing starts here for all API calls │ │ │ Components: Components do the heavy lifting within the engine │ │ │ │ ┌───────────────┐ - Integrates with Blockchain Smart Contract logic across blockchain technologies │ ├───┤ contract [Cm]│ * Generates OpenAPI 3 / Swagger definitions for smart contracts, and propagates to network │ │ │ manager │ * Manages listeners for native Blockchain events, and routes those to application events │ │ └───────────────┘ * Convert to/from native Blockchain interfaces (ABI etc.) and FireFly Interface [FFI] format │ │ │ │ ┌───────────────┐ - Maintains a view of the entire network │ ├───┤ network [Nm]│ * Integrates with network permissioning [NP] plugin │ │ │ map │ * Integrates with broadcast plugin │ │ └───────────────┘ * Handles hierarchy of member identity, node identity and signing identity │ │ │ │ ┌───────────────┐ - Broadcast of data to all parties in the network │ ├───┤ broadcast [Bm]│ * Implements dispatcher for batch component │ │ │ manager | * Integrates with shared storage interface [Ss] plugin │ │ └───────────────┘ * Integrates with blockchain interface [Bi] plugin │ │ │ │ ┌───────────────┐ - Send private data to individual parties in the network │ ├───┤ private [Pm]│ * Implements dispatcher for batch component │ │ │ messaging | * Integrates with the data exchange [Dx] plugin │ │ └──────┬────────┘ * Messages can be pinned and sequenced via the blockchain, or just sent │ │ │ │ │ ┌──────┴────────┐ - Groups of parties, with isolated data and/or blockchains │ │ │ group [Gm]│ * Integrates with data exchange [Dx] plugin │ │ │ manager │ * Integrates with blockchain interface [Bi] plugin │ │ └───────────────┘ │ │ │ │ ┌───────────────┐ - Private data management and validation │ ├───┤ data [Dm]│ * Implements dispatcher for batch component │ │ │ manager │ * Integrates with data exchange [Dx] plugin │ │ └──────┬────────┘ * Integrates with blockchain interface [Bi] plugin │ │ │ │ │ ┌──────┴────────┐ - JSON data schema management and validation (architecture extensible to XML and more) │ │ │ json [Jv]│ * JSON Schema validation logic for outbound and inbound messages │ │ │ validator │ * Schema propagation │ │ └──────┬────────┘ * Integrates with broadcast plugin │ │ │ │ │ ┌──────┴────────┐ - Binary data addressable via ID or Hash │ │ │ blobstore [Bs]│ * Integrates with data exchange [Dx] plugin │ │ │ │ * Hashes data, and maintains mapping to payload references in blob storage │ │ └───────────────┘ * Integrates with blockchain interface [Bi] plugin │ │ │ │ ┌───────────────┐ - Download from shared storage │ ├───┤ shared [Sd]│ * Parallel asynchronous download │ │ │ download │ * Resilient retry and crash recovery │ │ └───────────────┘ * Notification to event aggregator on completion │ │ │ │ ┌───────────────┐ │ ├───┤ identity [Im] │ - Central identity management service across components │ │ │ manager │ * Resolves API input identity + key combos (short names, formatting etc.) │ │ │ │ * Resolves registered on-chain signing keys back to identities │ │ └───────────────┘ * Integrates with Blockchain Interface and pluggable Identity Interface (TBD) │ │ │ │ ┌───────────────┐ - Keeps track of all operations performed against external components via plugins │ ├───┤ operation [Om]│ * Updates database with inputs/outputs │ │ │ manager │ * Provides consistent retry semantics across plugins │ │ └───────────────┘ │ │ │ │ ┌───────────────┐ - Private data management and validation │ ├───┤ event [Em]│ * Implements dispatcher for batch component │ │ │ manager │ * Integrates with data exchange [Dx] plugin │ │ └──────┬────────┘ * Integrates with blockchain interface [Bi] plugin │ │ │ │ │ ┌──────┴────────┐ - Handles incoming external data │ │ │ [Ag]│ * Integrates with data exchange [Dx] plugin │ │ │ aggregator │ * Integrates with shared storage interface [Ss] plugin │ │ │ │ * Integrates with blockchain interface [Bi] plugin │ │ │ │ - Ensures valid events are dispatched only once all data is available │ │ └──────┬────────┘ * Context aware, to prevent block-the-world scenarios │ │ │ │ │ ┌──────┴────────┐ - Subscription manager │ │ │ [Sm]│ * Creation and management of subscriptions │ │ │ subscription │ * Creation and management of subscriptions │ │ │ manager │ * Message to Event matching logic │ │ └──────┬────────┘ │ │ │ │ │ ┌──────┴────────┐ - Manages delivery of events to connected applications │ │ │ event [Ed]│ * Integrates with data exchange [Dx] plugin │ │ │ dispatcher │ * Integrates with blockchain interface [Bi] plugin │ │ └───────────────┘ │ │ │ │ ┌───────────────┐ - Token creation/transfer initiation, indexing and coordination │ ├───┤ asset [Am]│ * Fungible tokens: Digitized value/settlement (coins) │ │ │ manager │ * Non-fungible tokens: NFTs / globally uniqueness / digital twins │ │ └───────────────┘ * Full indexing of transaction history │ │ [REST/WebSockets] │ │ ┌─────┴─────────────┐ ┌──────────┐ ┌─ │ │ │ ERC-20 / ERC-721 ├───┤ ERC-1155 ├───┤ Simple framework for building token connectors │ │ └───────────────────┘ └──────────┘ └─ │ │ │ │ ┌───────────────┐ │ ├───┤ sync / [Sa] │ - Sync/Async Bridge │ │ │ async bridge │ * Provides synchronous request/reply APIs │ │ │ │ * Translates to underlying event-driven API │ │ └───────────────┘ │ │ │ │ ┌───────────────┐ - Aggregates messages and data, with rolled up hashes for pinning │ ├───┤ batch [Ba]│ * Pluggable dispatchers │ │ │ manager │ - Database decoupled from main-line API processing │ │ │ │ * See architecture diagrams for more info on active/active sequencing │ │ └──────┬────────┘ - Manages creation of batch processor instances │ │ │ │ │ ┌──────┴────────┐ - Short lived agent spun up to assemble batches on demand │ │ │ batch [Bp]│ * Coupled to an author+type of messages │ │ │ processor │ - Builds batches of 100s messages for efficient pinning │ │ │ │ * Aggregates messages and data, with rolled up hashes for pinning │ │ └───────────────┘ - Shuts down automatically after a configurable inactivity period │ ... more TBD │ Plugins: Each plugin comprises a Go shim, plus a remote agent microservice runtime (if required) │ │ ┌───────────────┐ - Blockchain Interface ├───────────┤ [Bi]│ * Transaction submission - including signing key management │ │ blockchain │ * Event listening │ │ interface │ * Standardized operations, and custom on-chain coupling │ └─────┬─────────┘ │ │ │ ├─────────────────────┬───────────────────┐ │ ┌─────┴─────────┐ ┌───────┴───────┐ ┌───────┴────────┐ │ │ ethereum │ │ fabric │ │ corda/cordapps │ │ └─────┬─────────┘ └───────────────┘ └────────────────┘ │ [REST/WebSockets] │ ┌─────┴────────────────────┐ ┌────────────────────────┐ ┌─ │ │ transaction manager [Tm] ├───┤ Connector API [ffcapi] ├───┤ Simple framework for building blockchain connectors │ └──────────────────────────┘ └────────────────────────┘ └─ │ │ ┌───────────────┐ - Token interface ├───────────┤ tokens [Ti]│ * Standardizes core concepts: token pools, transfers, approvals │ │ interface │ * Pluggable across token standards │ └───────────────┘ * Supports simple implementation of custom token standards via microservice connector │ [REST/WebSockets] │ ┌─────┴─────────────┐ ┌──────────┐ ┌─ │ │ ERC-20 / ERC-721 ├───┤ ERC-1155 ├───┤ Simple framework for building token connectors │ └───────────────────┘ └──────────┘ └─ │ │ ┌───────────────┐ - P2P Content Addresssed Filesystem ├───────────┤ shared [Si]│ * Payload upload / download │ │ storage │ * Payload reference management │ │ interface │ │ └─────┬─────────┘ │ │ │ ├───────── ... extensible to any shared storage sytem, accessible to all members │ ┌─────┴─────────┐ │ │ ipfs │ │ └───────────────┘ │ │ ┌───────────────┐ - Private Data Exchange ├───────────┤ data [Dx]│ * Blob storage │ │ exchange │ * Private secure messaging │ └─────┬─────────┘ * Secure file transfer │ │ │ ├─────────────────────┬────────── ... extensible to any private data exchange tech │ ┌─────┴─────────┐ ┌───────┴───────┐ │ │ https / MTLS │ │ Kaleido │ │ └───────────────┘ └───────────────┘ │ │ ┌───────────────┐ - API Authentication and Authorization Interface ├───────────┤ api auth [Aa]│ * Authenticates security credentials (OpenID Connect id token JWTs etc.) │ │ │ * Extracts API/user identity (for identity interface to map) │ └─────┬─────────┘ * Enforcement point for fine grained API access control │ │ │ ├─────────────────────┬────────── ... extensible other single sign-on technologies │ ┌─────┴─────────┐ ┌───────┴───────┐ │ │ apikey │ │ jwt │ │ └───────────────┘ └───────────────┘ │ │ ┌───────────────┐ - Database Interactions ├───────────┤ database [Di]│ * Create, Read, Update, Delete (CRUD) actions │ │ interace │ * Filtering and update definition interace │ └─────┬─────────┘ * Migrations and Indexes │ │ │ ├───────── ... extensible to NoSQL (CouchDB / MongoDB etc.) │ ┌─────┴─────────┐ │ │ sqlcommon │ │ └─────┬─────────┘ │ ├───────────────────────┬───────── ... extensible other SQL databases │ ┌─────┴─────────┐ ┌───────┴────────┐ │ │ postgres │ │ sqlite3 │ │ └───────────────┘ └────────────────┘ │ │ ┌───────────────┐ - Connects the core event engine to external frameworks and applications ├───────────┤ event [Ei]│ * Supports long-lived (durable) and ephemeral event subscriptions │ │ interface │ * Batching, filtering, all handled in core prior to transport │ └─────┬─────────┘ * Interface supports connect-in (websocket) and connect-out (broker runtime style) plugins │ │ │ ├───────────────────────┬────────── ... extensible to additional event buses (Kafka, NATS, AMQP etc.) │ ┌─────┴─────────┐ ┌───────┴────────┐ │ │ websockets │ │ webhooks │ │ └───────────────┘ └────────────────┘ │ ... more TBD Additional utility framworks ┌───────────────┐ - REST API client │ rest [Re]│ * Provides convenience and logging │ client │ * Standardizes auth, config and retry logic └───────────────┘ * Built on Resty ┌───────────────┐ - WebSocket client │ wsclient [Wc]│ * Provides convenience and logging │ │ * Standardizes auth, config and reconnect logic └───────────────┘ * Built on Gorilla WebSockets ┌───────────────┐ - Translation framework │ i18n [In]│ * Every translations must be added to `en_translations.json` - with an `FF10101` key │ │ * Errors are wrapped, providing extra features from the `errors` package (stack etc.) └───────────────┘ * Description translations also supported, such as OpenAPI description ┌───────────────┐ - Logging framework │ log [Lo]│ * Logging framework (logrus) integrated with context based tagging │ │ * Context is used throughout the code to pass API invocation context, and logging context └───────────────┘ * Example: Every API call has an ID that can be traced, as well as a timeout ┌───────────────┐ - Configuration │ config [Co]│ * File and Environment Variable based logging framework (viper) │ │ * Primary config keys all defined centrally └───────────────┘ * Plugins integrate by returning their config structure for unmarshaling (JSON tags) . ",
    "url": "/firefly/head/contributors/code_hierarchy.html#table-of-contents",
    "relUrl": "/contributors/code_hierarchy.html#table-of-contents"
  },"84": {
    "doc": "pages.code_hierarchy",
    "title": "pages.code_hierarchy",
    "content": " ",
    "url": "/firefly/head/contributors/code_hierarchy.html",
    "relUrl": "/contributors/code_hierarchy.html"
  },"85": {
    "doc": "pages.code_overview",
    "title": "Firefly Code Overview",
    "content": " ",
    "url": "/firefly/head/contributors/code_overview.html#firefly-code-overview",
    "relUrl": "/contributors/code_overview.html#firefly-code-overview"
  },"86": {
    "doc": "pages.code_overview",
    "title": "Table of contents",
    "content": ". | Developer Intro | Directories | . ",
    "url": "/firefly/head/contributors/code_overview.html#table-of-contents",
    "relUrl": "/contributors/code_overview.html#table-of-contents"
  },"87": {
    "doc": "pages.code_overview",
    "title": "Developer Intro",
    "content": "FireFly is a second generation implementation re-engineered from the ground up to improve developer experience, runtime performance, and extensibility. This means a simplified REST/WebSocket programming model for app development, and a wider range of infrastructure options for deployment. It also means a focus on an architecture and code structure for a vibrant open source community. A few highlights: . | Golang codebase . | Strong coding standards, including unit test coverage, translation support, logging and more | Fast starting, low memory footprint, multi-threaded runtime | . | OpenAPI 3.0 API specification (Swagger) . | Generated from the API router code, to avoid divergence with the implementation | . | Active/active HA architecture for the core runtime . | Deferring to the core database for state high availability | Exploiting leader election where required | . | Fully pluggable architecture . | Everything from Database through to Blockchain, and Compute | Golang plugin infrastructure to decouple the core code from the implementation | Remote Agent model to decouple code languages, and HA designs | . | Updated API resource model . | Asset, Data, Message, Event, Topic, Transaction | . | Added flexibility, with simplified the developer experience: . | Versioning of data definitions | Introducing a first class Context construct link related events into a single sequence | Allow many pieces of data to be attached to a single message, and be automatically re-assembled on arrival | Clearer separation of concerns between the FireFly DB and the Application DB | Better search, filter and query support | . ",
    "url": "/firefly/head/contributors/code_overview.html#developer-intro",
    "relUrl": "/contributors/code_overview.html#developer-intro"
  },"88": {
    "doc": "pages.code_overview",
    "title": "Directories",
    "content": "| internal: The core Golang implementation code | pkg: Interfaces intended for external project use | cmd: The command line entry point | smart_contracts: smart contract code for FireFly’s onchain logic | . ",
    "url": "/firefly/head/contributors/code_overview.html#directories",
    "relUrl": "/contributors/code_overview.html#directories"
  },"89": {
    "doc": "pages.code_overview",
    "title": "pages.code_overview",
    "content": " ",
    "url": "/firefly/head/contributors/code_overview.html",
    "relUrl": "/contributors/code_overview.html"
  },"90": {
    "doc": "pages.code_repositories",
    "title": "Code Repositories",
    "content": " ",
    "url": "/firefly/head/contributors/code_repositories.html#code-repositories",
    "relUrl": "/contributors/code_repositories.html#code-repositories"
  },"91": {
    "doc": "pages.code_repositories",
    "title": "Table of contents",
    "content": ". FireFly has a plugin based architecture design, with a microservice runtime footprint. As such there are a number of repos, and the list will grow as the community evolves. But not to worry, one of those repos is a CLI designed to get you running with all the components you need in minutes! . | CLI / Developer experience | FireFly Samples | UI Explorer | Core | HTTP Data Exchange | Ethereum (Hyperledger Besu / Quorum) connector | Corda connector | Hyperledger Fabric connector | Token connector reference implementation (ERC1155) | . Note only the projects that are primarily built to support FireFly are listed here, not all of the ecosystem of projects that integrate underneath the plugins. ",
    "url": "/firefly/head/contributors/code_repositories.html#table-of-contents",
    "relUrl": "/contributors/code_repositories.html#table-of-contents"
  },"92": {
    "doc": "pages.code_repositories",
    "title": "pages.code_repositories",
    "content": " ",
    "url": "/firefly/head/contributors/code_repositories.html",
    "relUrl": "/contributors/code_repositories.html"
  },"93": {
    "doc": "Configuration Reference",
    "title": "Configuration Reference",
    "content": ". ",
    "url": "/firefly/head/reference/config.html",
    "relUrl": "/reference/config.html"
  },"94": {
    "doc": "Configuration Reference",
    "title": "admin",
    "content": "| Key | Description | Type | Default Value | . | enabled | Deprecated - use spi.enabled instead | boolean | &lt;nil&gt; | . ",
    "url": "/firefly/head/reference/config.html#admin",
    "relUrl": "/reference/config.html#admin"
  },"95": {
    "doc": "Configuration Reference",
    "title": "api",
    "content": "| Key | Description | Type | Default Value | . | defaultFilterLimit | The maximum number of rows to return if no limit is specified on an API request | int | &lt;nil&gt; | . | maxFilterLimit | The largest value of limit that an HTTP client can specify in a request | int | &lt;nil&gt; | . | requestMaxTimeout | The maximum amount of time that an HTTP client can specify in a Request-Timeout header to keep a specific request open | time.Duration | &lt;nil&gt; | . | requestTimeout | The maximum amount of time that a request is allowed to remain open | time.Duration | &lt;nil&gt; | . ",
    "url": "/firefly/head/reference/config.html#api",
    "relUrl": "/reference/config.html#api"
  },"96": {
    "doc": "Configuration Reference",
    "title": "asset.manager",
    "content": "| Key | Description | Type | Default Value | . | keyNormalization | Mechanism to normalize keys before using them. Valid options are blockchain_plugin - use blockchain plugin (default) or none - do not attempt normalization (deprecated - use namespaces.predefined[].asset.manager.keyNormalization) | string | &lt;nil&gt; | . ",
    "url": "/firefly/head/reference/config.html#assetmanager",
    "relUrl": "/reference/config.html#assetmanager"
  },"97": {
    "doc": "Configuration Reference",
    "title": "batch.manager",
    "content": "| Key | Description | Type | Default Value | . | minimumPollDelay | The minimum time the batch manager waits between polls on the DB - to prevent thrashing | time.Duration | &lt;nil&gt; | . | pollTimeout | How long to wait without any notifications of new messages before doing a page query | time.Duration | &lt;nil&gt; | . | readPageSize | The size of each page of messages read from the database into memory when assembling batches | int | &lt;nil&gt; | . ",
    "url": "/firefly/head/reference/config.html#batchmanager",
    "relUrl": "/reference/config.html#batchmanager"
  },"98": {
    "doc": "Configuration Reference",
    "title": "batch.retry",
    "content": "| Key | Description | Type | Default Value | . | factor | The retry backoff factor | boolean | &lt;nil&gt; | . | initDelay | The initial retry delay | time.Duration | &lt;nil&gt; | . | maxDelay | The maximum retry delay | time.Duration | &lt;nil&gt; | . ",
    "url": "/firefly/head/reference/config.html#batchretry",
    "relUrl": "/reference/config.html#batchretry"
  },"99": {
    "doc": "Configuration Reference",
    "title": "blobreceiver.retry",
    "content": "| Key | Description | Type | Default Value | . | factor | The retry backoff factor | boolean | &lt;nil&gt; | . | initialDelay | The initial retry delay | time.Duration | &lt;nil&gt; | . | maxDelay | The maximum retry delay | time.Duration | &lt;nil&gt; | . ",
    "url": "/firefly/head/reference/config.html#blobreceiverretry",
    "relUrl": "/reference/config.html#blobreceiverretry"
  },"100": {
    "doc": "Configuration Reference",
    "title": "blobreceiver.worker",
    "content": "| Key | Description | Type | Default Value | . | batchMaxInserts | The maximum number of items the blob receiver worker will insert in a batch | int | &lt;nil&gt; | . | batchTimeout | The maximum amount of the the blob receiver worker will wait | time.Duration | &lt;nil&gt; | . | count | The number of blob receiver workers | int | &lt;nil&gt; | . ",
    "url": "/firefly/head/reference/config.html#blobreceiverworker",
    "relUrl": "/reference/config.html#blobreceiverworker"
  },"101": {
    "doc": "Configuration Reference",
    "title": "blockchain",
    "content": "| Key | Description | Type | Default Value | . | type | A string defining which type of blockchain plugin to use. This tells FireFly which type of configuration to load for the rest of the blockchain section | string | &lt;nil&gt; | . ",
    "url": "/firefly/head/reference/config.html#blockchain",
    "relUrl": "/reference/config.html#blockchain"
  },"102": {
    "doc": "Configuration Reference",
    "title": "blockchain.ethereum.addressResolver",
    "content": "| Key | Description | Type | Default Value | . | bodyTemplate | The body go template string to use when making HTTP requests | Go Template string | &lt;nil&gt; | . | connectionTimeout | The maximum amount of time that a connection is allowed to remain with no data transmitted | time.Duration | 30s | . | expectContinueTimeout | See ExpectContinueTimeout in the Go docs | time.Duration | 1s | . | headers | Adds custom headers to HTTP requests | string | &lt;nil&gt; | . | idleTimeout | The max duration to hold a HTTP keepalive connection between calls | time.Duration | 475ms | . | maxIdleConns | The max number of idle connections to hold pooled | int | 100 | . | method | The HTTP method to use when making requests to the Address Resolver | string | GET | . | requestTimeout | The maximum amount of time that a request is allowed to remain open | time.Duration | 30s | . | responseField | The name of a JSON field that is provided in the response, that contains the ethereum address (default address) | string | address | . | retainOriginal | When true the original pre-resolved string is retained after the lookup, and passed down to Ethconnect as the from address | boolean | &lt;nil&gt; | . | tlsHandshakeTimeout | The maximum amount of time to wait for a successful TLS handshake | time.Duration | 10s | . | url | The URL of the Address Resolver | string | &lt;nil&gt; | . | urlTemplate | The URL Go template string to use when calling the Address Resolver | Go Template string | &lt;nil&gt; | . ",
    "url": "/firefly/head/reference/config.html#blockchainethereumaddressresolver",
    "relUrl": "/reference/config.html#blockchainethereumaddressresolver"
  },"103": {
    "doc": "Configuration Reference",
    "title": "blockchain.ethereum.addressResolver.auth",
    "content": "| Key | Description | Type | Default Value | . | password | Password | string | &lt;nil&gt; | . | username | Username | string | &lt;nil&gt; | . ",
    "url": "/firefly/head/reference/config.html#blockchainethereumaddressresolverauth",
    "relUrl": "/reference/config.html#blockchainethereumaddressresolverauth"
  },"104": {
    "doc": "Configuration Reference",
    "title": "blockchain.ethereum.addressResolver.proxy",
    "content": "| Key | Description | Type | Default Value | . | url | Optional HTTP proxy server to use when connecting to the Address Resolver | URL string | &lt;nil&gt; | . ",
    "url": "/firefly/head/reference/config.html#blockchainethereumaddressresolverproxy",
    "relUrl": "/reference/config.html#blockchainethereumaddressresolverproxy"
  },"105": {
    "doc": "Configuration Reference",
    "title": "blockchain.ethereum.addressResolver.retry",
    "content": "| Key | Description | Type | Default Value | . | count | The maximum number of times to retry | int | 5 | . | enabled | Enables retries | boolean | false | . | initWaitTime | The initial retry delay | time.Duration | 250ms | . | maxWaitTime | The maximum retry delay | time.Duration | 30s | . ",
    "url": "/firefly/head/reference/config.html#blockchainethereumaddressresolverretry",
    "relUrl": "/reference/config.html#blockchainethereumaddressresolverretry"
  },"106": {
    "doc": "Configuration Reference",
    "title": "blockchain.ethereum.ethconnect",
    "content": "| Key | Description | Type | Default Value | . | batchSize | The number of events Ethconnect should batch together for delivery to FireFly core. Only applies when automatically creating a new event stream | int | 50 | . | batchTimeout | How long Ethconnect should wait for new events to arrive and fill a batch, before sending the batch to FireFly core. Only applies when automatically creating a new event stream | time.Duration | 500 | . | connectionTimeout | The maximum amount of time that a connection is allowed to remain with no data transmitted | time.Duration | 30s | . | expectContinueTimeout | See ExpectContinueTimeout in the Go docs | time.Duration | 1s | . | fromBlock | The first event this FireFly instance should listen to from the BatchPin smart contract. Default=0. Only affects initial creation of the event stream (deprecated - use namespaces.predefined[].multiparty.contract[].location.firstEvent) | Address string | 0 | . | headers | Adds custom headers to HTTP requests | map[string]string | &lt;nil&gt; | . | idleTimeout | The max duration to hold a HTTP keepalive connection between calls | time.Duration | 475ms | . | instance | The Ethereum address of the FireFly BatchPin smart contract that has been deployed to the blockchain (deprecated - use namespaces.predefined[].multiparty.contract[].location.address) | Address string | &lt;nil&gt; | . | maxIdleConns | The max number of idle connections to hold pooled | int | 100 | . | prefixLong | The prefix that will be used for Ethconnect specific HTTP headers when FireFly makes requests to Ethconnect | string | firefly | . | prefixShort | The prefix that will be used for Ethconnect specific query parameters when FireFly makes requests to Ethconnect | string | fly | . | requestTimeout | The maximum amount of time that a request is allowed to remain open | time.Duration | 30s | . | tlsHandshakeTimeout | The maximum amount of time to wait for a successful TLS handshake | time.Duration | 10s | . | topic | The websocket listen topic that the node should register on, which is important if there are multiple nodes using a single ethconnect | string | &lt;nil&gt; | . | url | The URL of the Ethconnect instance | URL string | &lt;nil&gt; | . ",
    "url": "/firefly/head/reference/config.html#blockchainethereumethconnect",
    "relUrl": "/reference/config.html#blockchainethereumethconnect"
  },"107": {
    "doc": "Configuration Reference",
    "title": "blockchain.ethereum.ethconnect.auth",
    "content": "| Key | Description | Type | Default Value | . | password | Password | string | &lt;nil&gt; | . | username | Username | string | &lt;nil&gt; | . ",
    "url": "/firefly/head/reference/config.html#blockchainethereumethconnectauth",
    "relUrl": "/reference/config.html#blockchainethereumethconnectauth"
  },"108": {
    "doc": "Configuration Reference",
    "title": "blockchain.ethereum.ethconnect.proxy",
    "content": "| Key | Description | Type | Default Value | . | url | Optional HTTP proxy server to use when connecting to Ethconnect | URL string | &lt;nil&gt; | . ",
    "url": "/firefly/head/reference/config.html#blockchainethereumethconnectproxy",
    "relUrl": "/reference/config.html#blockchainethereumethconnectproxy"
  },"109": {
    "doc": "Configuration Reference",
    "title": "blockchain.ethereum.ethconnect.retry",
    "content": "| Key | Description | Type | Default Value | . | count | The maximum number of times to retry | int | 5 | . | enabled | Enables retries | boolean | false | . | initWaitTime | The initial retry delay | time.Duration | 250ms | . | maxWaitTime | The maximum retry delay | time.Duration | 30s | . ",
    "url": "/firefly/head/reference/config.html#blockchainethereumethconnectretry",
    "relUrl": "/reference/config.html#blockchainethereumethconnectretry"
  },"110": {
    "doc": "Configuration Reference",
    "title": "blockchain.ethereum.ethconnect.ws",
    "content": "| Key | Description | Type | Default Value | . | heartbeatInterval | The amount of time to wait between heartbeat signals on the WebSocket connection | time.Duration | 30s | . | initialConnectAttempts | The number of attempts FireFly will make to connect to the WebSocket when starting up, before failing | int | 5 | . | path | The WebSocket sever URL to which FireFly should connect | WebSocket URL string | &lt;nil&gt; | . | readBufferSize | The size in bytes of the read buffer for the WebSocket connection | BytesSize | 16Kb | . | writeBufferSize | The size in bytes of the write buffer for the WebSocket connection | BytesSize | 16Kb | . ",
    "url": "/firefly/head/reference/config.html#blockchainethereumethconnectws",
    "relUrl": "/reference/config.html#blockchainethereumethconnectws"
  },"111": {
    "doc": "Configuration Reference",
    "title": "blockchain.ethereum.fftm",
    "content": "| Key | Description | Type | Default Value | . | connectionTimeout | The maximum amount of time that a connection is allowed to remain with no data transmitted | time.Duration | 30s | . | expectContinueTimeout | See ExpectContinueTimeout in the Go docs | time.Duration | 1s | . | headers | Adds custom headers to HTTP requests | map[string]string | &lt;nil&gt; | . | idleTimeout | The max duration to hold a HTTP keepalive connection between calls | time.Duration | 475ms | . | maxIdleConns | The max number of idle connections to hold pooled | int | 100 | . | requestTimeout | The maximum amount of time that a request is allowed to remain open | time.Duration | 30s | . | tlsHandshakeTimeout | The maximum amount of time to wait for a successful TLS handshake | time.Duration | 10s | . | url | The URL of the FireFly Transaction Manager runtime, if enabled | string | &lt;nil&gt; | . ",
    "url": "/firefly/head/reference/config.html#blockchainethereumfftm",
    "relUrl": "/reference/config.html#blockchainethereumfftm"
  },"112": {
    "doc": "Configuration Reference",
    "title": "blockchain.ethereum.fftm.auth",
    "content": "| Key | Description | Type | Default Value | . | password | Password | string | &lt;nil&gt; | . | username | Username | string | &lt;nil&gt; | . ",
    "url": "/firefly/head/reference/config.html#blockchainethereumfftmauth",
    "relUrl": "/reference/config.html#blockchainethereumfftmauth"
  },"113": {
    "doc": "Configuration Reference",
    "title": "blockchain.ethereum.fftm.proxy",
    "content": "| Key | Description | Type | Default Value | . | url | Optional HTTP proxy server to use when connecting to the Transaction Manager | string | &lt;nil&gt; | . ",
    "url": "/firefly/head/reference/config.html#blockchainethereumfftmproxy",
    "relUrl": "/reference/config.html#blockchainethereumfftmproxy"
  },"114": {
    "doc": "Configuration Reference",
    "title": "blockchain.ethereum.fftm.retry",
    "content": "| Key | Description | Type | Default Value | . | count | The maximum number of times to retry | int | 5 | . | enabled | Enables retries | boolean | false | . | initWaitTime | The initial retry delay | time.Duration | 250ms | . | maxWaitTime | The maximum retry delay | time.Duration | 30s | . ",
    "url": "/firefly/head/reference/config.html#blockchainethereumfftmretry",
    "relUrl": "/reference/config.html#blockchainethereumfftmretry"
  },"115": {
    "doc": "Configuration Reference",
    "title": "blockchain.fabric.fabconnect",
    "content": "| Key | Description | Type | Default Value | . | batchSize | The number of events Fabconnect should batch together for delivery to FireFly core. Only applies when automatically creating a new event stream | int | 50 | . | batchTimeout | The maximum amount of time to wait for a batch to complete | time.Duration | 500 | . | chaincode | The name of the Fabric chaincode that FireFly will use for BatchPin transactions (deprecated - use namespaces.predefined[].multiparty.contract[].location.chaincode) | string | &lt;nil&gt; | . | channel | The Fabric channel that FireFly will use for BatchPin transactions (deprecated - use namespaces.predefined[].multiparty.contract[].location.channel) | string | &lt;nil&gt; | . | connectionTimeout | The maximum amount of time that a connection is allowed to remain with no data transmitted | time.Duration | 30s | . | expectContinueTimeout | See ExpectContinueTimeout in the Go docs | time.Duration | 1s | . | headers | Adds custom headers to HTTP requests | map[string]string | &lt;nil&gt; | . | idleTimeout | The max duration to hold a HTTP keepalive connection between calls | time.Duration | 475ms | . | maxIdleConns | The max number of idle connections to hold pooled | int | 100 | . | prefixLong | The prefix that will be used for Fabconnect specific HTTP headers when FireFly makes requests to Fabconnect | string | firefly | . | prefixShort | The prefix that will be used for Fabconnect specific query parameters when FireFly makes requests to Fabconnect | string | fly | . | requestTimeout | The maximum amount of time that a request is allowed to remain open | time.Duration | 30s | . | signer | The Fabric signing key to use when submitting transactions to Fabconnect | string | &lt;nil&gt; | . | tlsHandshakeTimeout | The maximum amount of time to wait for a successful TLS handshake | time.Duration | 10s | . | topic | The websocket listen topic that the node should register on, which is important if there are multiple nodes using a single Fabconnect | string | &lt;nil&gt; | . | url | The URL of the Fabconnect instance | URL string | &lt;nil&gt; | . ",
    "url": "/firefly/head/reference/config.html#blockchainfabricfabconnect",
    "relUrl": "/reference/config.html#blockchainfabricfabconnect"
  },"116": {
    "doc": "Configuration Reference",
    "title": "blockchain.fabric.fabconnect.auth",
    "content": "| Key | Description | Type | Default Value | . | password | Password | string | &lt;nil&gt; | . | username | Username | string | &lt;nil&gt; | . ",
    "url": "/firefly/head/reference/config.html#blockchainfabricfabconnectauth",
    "relUrl": "/reference/config.html#blockchainfabricfabconnectauth"
  },"117": {
    "doc": "Configuration Reference",
    "title": "blockchain.fabric.fabconnect.proxy",
    "content": "| Key | Description | Type | Default Value | . | url | Optional HTTP proxy server to use when connecting to Fabconnect | URL string | &lt;nil&gt; | . ",
    "url": "/firefly/head/reference/config.html#blockchainfabricfabconnectproxy",
    "relUrl": "/reference/config.html#blockchainfabricfabconnectproxy"
  },"118": {
    "doc": "Configuration Reference",
    "title": "blockchain.fabric.fabconnect.retry",
    "content": "| Key | Description | Type | Default Value | . | count | The maximum number of times to retry | int | 5 | . | enabled | Enables retries | boolean | false | . | initWaitTime | The initial retry delay | time.Duration | 250ms | . | maxWaitTime | The maximum retry delay | time.Duration | 30s | . ",
    "url": "/firefly/head/reference/config.html#blockchainfabricfabconnectretry",
    "relUrl": "/reference/config.html#blockchainfabricfabconnectretry"
  },"119": {
    "doc": "Configuration Reference",
    "title": "blockchain.fabric.fabconnect.ws",
    "content": "| Key | Description | Type | Default Value | . | heartbeatInterval | The amount of time to wait between heartbeat signals on the WebSocket connection | time.Duration | 30s | . | initialConnectAttempts | The number of attempts FireFly will make to connect to the WebSocket when starting up, before failing | int | 5 | . | path | The WebSocket sever URL to which FireFly should connect | WebSocket URL string | &lt;nil&gt; | . | readBufferSize | The size in bytes of the read buffer for the WebSocket connection | BytesSize | 16Kb | . | writeBufferSize | The size in bytes of the write buffer for the WebSocket connection | BytesSize | 16Kb | . ",
    "url": "/firefly/head/reference/config.html#blockchainfabricfabconnectws",
    "relUrl": "/reference/config.html#blockchainfabricfabconnectws"
  },"120": {
    "doc": "Configuration Reference",
    "title": "broadcast.batch",
    "content": "| Key | Description | Type | Default Value | . | agentTimeout | How long to keep around a batching agent for a sending identity before disposal | string | &lt;nil&gt; | . | payloadLimit | The maximum payload size of a batch for broadcast messages | BytesSize | &lt;nil&gt; | . | size | The maximum number of messages that can be packed into a batch | int | &lt;nil&gt; | . | timeout | The timeout to wait for a batch to fill, before sending | time.Duration | &lt;nil&gt; | . ",
    "url": "/firefly/head/reference/config.html#broadcastbatch",
    "relUrl": "/reference/config.html#broadcastbatch"
  },"121": {
    "doc": "Configuration Reference",
    "title": "cache",
    "content": "| Key | Description | Type | Default Value | . | enabled | Enables caching, defaults to true | boolean | &lt;nil&gt; | . ",
    "url": "/firefly/head/reference/config.html#cache",
    "relUrl": "/reference/config.html#cache"
  },"122": {
    "doc": "Configuration Reference",
    "title": "cache.addressresolver",
    "content": "| Key | Description | Type | Default Value | . | limit | Max number of cached items for address resolver | int | &lt;nil&gt; | . | ttl | Time to live of cached items for address resolver | string | &lt;nil&gt; | . ",
    "url": "/firefly/head/reference/config.html#cacheaddressresolver",
    "relUrl": "/reference/config.html#cacheaddressresolver"
  },"123": {
    "doc": "Configuration Reference",
    "title": "cache.batch",
    "content": "| Key | Description | Type | Default Value | . | limit | Max number of cached items for batches | int | &lt;nil&gt; | . | ttl | Time to live of cache items for batches | string | &lt;nil&gt; | . ",
    "url": "/firefly/head/reference/config.html#cachebatch",
    "relUrl": "/reference/config.html#cachebatch"
  },"124": {
    "doc": "Configuration Reference",
    "title": "cache.blockchain",
    "content": "| Key | Description | Type | Default Value | . | limit | Max number of cached items for blockchain | int | &lt;nil&gt; | . | ttl | Time to live of cached items for blockchain | string | &lt;nil&gt; | . ",
    "url": "/firefly/head/reference/config.html#cacheblockchain",
    "relUrl": "/reference/config.html#cacheblockchain"
  },"125": {
    "doc": "Configuration Reference",
    "title": "cache.blockchainevent",
    "content": "| Key | Description | Type | Default Value | . | limit | Max number of cached blockchain events for transactions | int | &lt;nil&gt; | . | ttl | Time to live of cached blockchain events for transactions | string | &lt;nil&gt; | . ",
    "url": "/firefly/head/reference/config.html#cacheblockchainevent",
    "relUrl": "/reference/config.html#cacheblockchainevent"
  },"126": {
    "doc": "Configuration Reference",
    "title": "cache.eventlistenertopic",
    "content": "| Key | Description | Type | Default Value | . | limit | Max number of cached items for blockchain listener topics | int | &lt;nil&gt; | . | ttl | Time to live of cached items for blockchain listener topics | string | &lt;nil&gt; | . ",
    "url": "/firefly/head/reference/config.html#cacheeventlistenertopic",
    "relUrl": "/reference/config.html#cacheeventlistenertopic"
  },"127": {
    "doc": "Configuration Reference",
    "title": "cache.group",
    "content": "| Key | Description | Type | Default Value | . | limit | Max number of cached items for groups | int | &lt;nil&gt; | . | ttl | Time to live of cached items for groups | string | &lt;nil&gt; | . ",
    "url": "/firefly/head/reference/config.html#cachegroup",
    "relUrl": "/reference/config.html#cachegroup"
  },"128": {
    "doc": "Configuration Reference",
    "title": "cache.identity",
    "content": "| Key | Description | Type | Default Value | . | limit | Max number of cached identities for identity manager | int | &lt;nil&gt; | . | ttl | Time to live of cached identities for identity manager | string | &lt;nil&gt; | . ",
    "url": "/firefly/head/reference/config.html#cacheidentity",
    "relUrl": "/reference/config.html#cacheidentity"
  },"129": {
    "doc": "Configuration Reference",
    "title": "cache.message",
    "content": "| Key | Description | Type | Default Value | . | size | Max size of cached messages for data manager | BytesSize | &lt;nil&gt; | . | ttl | Time to live of cached messages for data manager | string | &lt;nil&gt; | . ",
    "url": "/firefly/head/reference/config.html#cachemessage",
    "relUrl": "/reference/config.html#cachemessage"
  },"130": {
    "doc": "Configuration Reference",
    "title": "cache.operations",
    "content": "| Key | Description | Type | Default Value | . | limit | Max number of cached items for operations | int | &lt;nil&gt; | . | ttl | Time to live of cached items for operations | string | &lt;nil&gt; | . ",
    "url": "/firefly/head/reference/config.html#cacheoperations",
    "relUrl": "/reference/config.html#cacheoperations"
  },"131": {
    "doc": "Configuration Reference",
    "title": "cache.signingkey",
    "content": "| Key | Description | Type | Default Value | . | limit | Max number of cached signing keys for identity manager | int | &lt;nil&gt; | . | ttl | Time to live of cached signing keys for identity manager | string | &lt;nil&gt; | . ",
    "url": "/firefly/head/reference/config.html#cachesigningkey",
    "relUrl": "/reference/config.html#cachesigningkey"
  },"132": {
    "doc": "Configuration Reference",
    "title": "cache.transaction",
    "content": "| Key | Description | Type | Default Value | . | size | Max size of cached transactions | BytesSize | &lt;nil&gt; | . | ttl | Time to live of cached transactions | string | &lt;nil&gt; | . ",
    "url": "/firefly/head/reference/config.html#cachetransaction",
    "relUrl": "/reference/config.html#cachetransaction"
  },"133": {
    "doc": "Configuration Reference",
    "title": "cache.validator",
    "content": "| Key | Description | Type | Default Value | . | size | Max size of cached validators for data manager | BytesSize | &lt;nil&gt; | . | ttl | Time to live of cached validators for data manager | string | &lt;nil&gt; | . ",
    "url": "/firefly/head/reference/config.html#cachevalidator",
    "relUrl": "/reference/config.html#cachevalidator"
  },"134": {
    "doc": "Configuration Reference",
    "title": "cors",
    "content": "| Key | Description | Type | Default Value | . | credentials | CORS setting to control whether a browser allows credentials to be sent to this API | boolean | true | . | debug | Whether debug is enabled for the CORS implementation | boolean | false | . | enabled | Whether CORS is enabled | boolean | true | . | headers | CORS setting to control the allowed headers | string | [*] | . | maxAge | The maximum age a browser should rely on CORS checks | time.Duration | 600 | . | methods | CORS setting to control the allowed methods | string | [GET POST PUT PATCH DELETE] | . | origins | CORS setting to control the allowed origins | string | [*] | . ",
    "url": "/firefly/head/reference/config.html#cors",
    "relUrl": "/reference/config.html#cors"
  },"135": {
    "doc": "Configuration Reference",
    "title": "database",
    "content": "| Key | Description | Type | Default Value | . | type | The type of the database interface plugin to use | int | &lt;nil&gt; | . ",
    "url": "/firefly/head/reference/config.html#database",
    "relUrl": "/reference/config.html#database"
  },"136": {
    "doc": "Configuration Reference",
    "title": "database.postgres",
    "content": "| Key | Description | Type | Default Value | . | maxConnIdleTime | The maximum amount of time a database connection can be idle | time.Duration | 1m | . | maxConnLifetime | The maximum amount of time to keep a database connection open | time.Duration | &lt;nil&gt; | . | maxConns | Maximum connections to the database | int | 50 | . | maxIdleConns | The maximum number of idle connections to the database | int | &lt;nil&gt; | . | url | The PostgreSQL connection string for the database | string | &lt;nil&gt; | . ",
    "url": "/firefly/head/reference/config.html#databasepostgres",
    "relUrl": "/reference/config.html#databasepostgres"
  },"137": {
    "doc": "Configuration Reference",
    "title": "database.postgres.migrations",
    "content": "| Key | Description | Type | Default Value | . | auto | Enables automatic database migrations | boolean | false | . | directory | The directory containing the numerically ordered migration DDL files to apply to the database | string | ./db/migrations/postgres | . ",
    "url": "/firefly/head/reference/config.html#databasepostgresmigrations",
    "relUrl": "/reference/config.html#databasepostgresmigrations"
  },"138": {
    "doc": "Configuration Reference",
    "title": "database.sqlite3",
    "content": "| Key | Description | Type | Default Value | . | maxConnIdleTime | The maximum amount of time a database connection can be idle | time.Duration | 1m | . | maxConnLifetime | The maximum amount of time to keep a database connection open | time.Duration | &lt;nil&gt; | . | maxConns | Maximum connections to the database | int | 1 | . | maxIdleConns | The maximum number of idle connections to the database | int | &lt;nil&gt; | . | url | The SQLite connection string for the database | string | &lt;nil&gt; | . ",
    "url": "/firefly/head/reference/config.html#databasesqlite3",
    "relUrl": "/reference/config.html#databasesqlite3"
  },"139": {
    "doc": "Configuration Reference",
    "title": "database.sqlite3.migrations",
    "content": "| Key | Description | Type | Default Value | . | auto | Enables automatic database migrations | boolean | false | . | directory | The directory containing the numerically ordered migration DDL files to apply to the database | string | ./db/migrations/sqlite | . ",
    "url": "/firefly/head/reference/config.html#databasesqlite3migrations",
    "relUrl": "/reference/config.html#databasesqlite3migrations"
  },"140": {
    "doc": "Configuration Reference",
    "title": "dataexchange",
    "content": "| Key | Description | Type | Default Value | . | type | The Data Exchange plugin to use | string | &lt;nil&gt; | . ",
    "url": "/firefly/head/reference/config.html#dataexchange",
    "relUrl": "/reference/config.html#dataexchange"
  },"141": {
    "doc": "Configuration Reference",
    "title": "dataexchange.ffdx",
    "content": "| Key | Description | Type | Default Value | . | connectionTimeout | The maximum amount of time that a connection is allowed to remain with no data transmitted | time.Duration | 30s | . | expectContinueTimeout | See ExpectContinueTimeout in the Go docs | time.Duration | 1s | . | headers | Adds custom headers to HTTP requests | map[string]string | &lt;nil&gt; | . | idleTimeout | The max duration to hold a HTTP keepalive connection between calls | time.Duration | 475ms | . | initEnabled | Instructs FireFly to always post all current nodes to the /init API before connecting or reconnecting to the connector | boolean | false | . | manifestEnabled | Determines whether to require+validate a manifest from other DX instances in the network. Must be supported by the connector | string | false | . | maxIdleConns | The max number of idle connections to hold pooled | int | 100 | . | requestTimeout | The maximum amount of time that a request is allowed to remain open | time.Duration | 30s | . | tlsHandshakeTimeout | The maximum amount of time to wait for a successful TLS handshake | time.Duration | 10s | . | url | The URL of the Data Exchange instance | URL string | &lt;nil&gt; | . ",
    "url": "/firefly/head/reference/config.html#dataexchangeffdx",
    "relUrl": "/reference/config.html#dataexchangeffdx"
  },"142": {
    "doc": "Configuration Reference",
    "title": "dataexchange.ffdx.auth",
    "content": "| Key | Description | Type | Default Value | . | password | Password | string | &lt;nil&gt; | . | username | Username | string | &lt;nil&gt; | . ",
    "url": "/firefly/head/reference/config.html#dataexchangeffdxauth",
    "relUrl": "/reference/config.html#dataexchangeffdxauth"
  },"143": {
    "doc": "Configuration Reference",
    "title": "dataexchange.ffdx.proxy",
    "content": "| Key | Description | Type | Default Value | . | url | Optional HTTP proxy server to use when connecting to the Data Exchange | URL string | &lt;nil&gt; | . ",
    "url": "/firefly/head/reference/config.html#dataexchangeffdxproxy",
    "relUrl": "/reference/config.html#dataexchangeffdxproxy"
  },"144": {
    "doc": "Configuration Reference",
    "title": "dataexchange.ffdx.retry",
    "content": "| Key | Description | Type | Default Value | . | count | The maximum number of times to retry | int | 5 | . | enabled | Enables retries | boolean | false | . | initWaitTime | The initial retry delay | time.Duration | 250ms | . | maxWaitTime | The maximum retry delay | time.Duration | 30s | . ",
    "url": "/firefly/head/reference/config.html#dataexchangeffdxretry",
    "relUrl": "/reference/config.html#dataexchangeffdxretry"
  },"145": {
    "doc": "Configuration Reference",
    "title": "dataexchange.ffdx.ws",
    "content": "| Key | Description | Type | Default Value | . | heartbeatInterval | The amount of time to wait between heartbeat signals on the WebSocket connection | time.Duration | 30s | . | initialConnectAttempts | The number of attempts FireFly will make to connect to the WebSocket when starting up, before failing | int | 5 | . | path | The WebSocket sever URL to which FireFly should connect | WebSocket URL string | &lt;nil&gt; | . | readBufferSize | The size in bytes of the read buffer for the WebSocket connection | BytesSize | 16Kb | . | writeBufferSize | The size in bytes of the write buffer for the WebSocket connection | BytesSize | 16Kb | . ",
    "url": "/firefly/head/reference/config.html#dataexchangeffdxws",
    "relUrl": "/reference/config.html#dataexchangeffdxws"
  },"146": {
    "doc": "Configuration Reference",
    "title": "debug",
    "content": "| Key | Description | Type | Default Value | . | port | An HTTP port on which to enable the go debugger | int | &lt;nil&gt; | . ",
    "url": "/firefly/head/reference/config.html#debug",
    "relUrl": "/reference/config.html#debug"
  },"147": {
    "doc": "Configuration Reference",
    "title": "download.retry",
    "content": "| Key | Description | Type | Default Value | . | factor | The retry backoff factor | boolean | &lt;nil&gt; | . | initialDelay | The initial retry delay | time.Duration | &lt;nil&gt; | . | maxAttempts | The maximum number attempts | int | &lt;nil&gt; | . | maxDelay | The maximum retry delay | time.Duration | &lt;nil&gt; | . ",
    "url": "/firefly/head/reference/config.html#downloadretry",
    "relUrl": "/reference/config.html#downloadretry"
  },"148": {
    "doc": "Configuration Reference",
    "title": "download.worker",
    "content": "| Key | Description | Type | Default Value | . | count | The number of download workers | int | &lt;nil&gt; | . | queueLength | The length of the work queue in the channel to the workers - defaults to 2x the worker count | int | &lt;nil&gt; | . ",
    "url": "/firefly/head/reference/config.html#downloadworker",
    "relUrl": "/reference/config.html#downloadworker"
  },"149": {
    "doc": "Configuration Reference",
    "title": "event.aggregator",
    "content": "| Key | Description | Type | Default Value | . | batchSize | The maximum number of records to read from the DB before performing an aggregation run | BytesSize | &lt;nil&gt; | . | batchTimeout | How long to wait for new events to arrive before performing aggregation on a page of events | time.Duration | &lt;nil&gt; | . | firstEvent | The first event the aggregator should process, if no previous offest is stored in the DB. Valid options are oldest or newest | string | &lt;nil&gt; | . | pollTimeout | The time to wait without a notification of new events, before trying a select on the table | time.Duration | &lt;nil&gt; | . | rewindQueryLimit | Safety limit on the maximum number of records to search when performing queries to search for rewinds | int | &lt;nil&gt; | . | rewindQueueLength | The size of the queue into the rewind dispatcher | int | &lt;nil&gt; | . | rewindTimeout | The minimum time to wait for rewinds to accumulate before resolving them | time.Duration | &lt;nil&gt; | . ",
    "url": "/firefly/head/reference/config.html#eventaggregator",
    "relUrl": "/reference/config.html#eventaggregator"
  },"150": {
    "doc": "Configuration Reference",
    "title": "event.aggregator.retry",
    "content": "| Key | Description | Type | Default Value | . | factor | The retry backoff factor | boolean | &lt;nil&gt; | . | initDelay | The initial retry delay | time.Duration | &lt;nil&gt; | . | maxDelay | The maximum retry delay | time.Duration | &lt;nil&gt; | . ",
    "url": "/firefly/head/reference/config.html#eventaggregatorretry",
    "relUrl": "/reference/config.html#eventaggregatorretry"
  },"151": {
    "doc": "Configuration Reference",
    "title": "event.dbevents",
    "content": "| Key | Description | Type | Default Value | . | bufferSize | The size of the buffer of change events | BytesSize | &lt;nil&gt; | . ",
    "url": "/firefly/head/reference/config.html#eventdbevents",
    "relUrl": "/reference/config.html#eventdbevents"
  },"152": {
    "doc": "Configuration Reference",
    "title": "event.dispatcher",
    "content": "| Key | Description | Type | Default Value | . | batchTimeout | A short time to wait for new events to arrive before re-polling for new events | time.Duration | &lt;nil&gt; | . | bufferLength | The number of events + attachments an individual dispatcher should hold in memory ready for delivery to the subscription | int | &lt;nil&gt; | . | pollTimeout | The time to wait without a notification of new events, before trying a select on the table | time.Duration | &lt;nil&gt; | . ",
    "url": "/firefly/head/reference/config.html#eventdispatcher",
    "relUrl": "/reference/config.html#eventdispatcher"
  },"153": {
    "doc": "Configuration Reference",
    "title": "event.dispatcher.retry",
    "content": "| Key | Description | Type | Default Value | . | factor | The retry backoff factor | boolean | &lt;nil&gt; | . | initDelay | The initial retry delay | time.Duration | &lt;nil&gt; | . | maxDelay | The maximum retry delay | time.Duration | &lt;nil&gt; | . ",
    "url": "/firefly/head/reference/config.html#eventdispatcherretry",
    "relUrl": "/reference/config.html#eventdispatcherretry"
  },"154": {
    "doc": "Configuration Reference",
    "title": "event.transports",
    "content": "| Key | Description | Type | Default Value | . | default | The default event transport for new subscriptions | string | &lt;nil&gt; | . | enabled | Which event interface plugins are enabled | boolean | &lt;nil&gt; | . ",
    "url": "/firefly/head/reference/config.html#eventtransports",
    "relUrl": "/reference/config.html#eventtransports"
  },"155": {
    "doc": "Configuration Reference",
    "title": "histograms",
    "content": "| Key | Description | Type | Default Value | . | maxChartRows | The maximum rows to fetch for each histogram bucket | int | &lt;nil&gt; | . ",
    "url": "/firefly/head/reference/config.html#histograms",
    "relUrl": "/reference/config.html#histograms"
  },"156": {
    "doc": "Configuration Reference",
    "title": "http",
    "content": "| Key | Description | Type | Default Value | . | address | The IP address on which the HTTP API should listen | IP Address string | 127.0.0.1 | . | port | The port on which the HTTP API should listen | int | 5000 | . | publicURL | The fully qualified public URL for the API. This is used for building URLs in HTTP responses and in OpenAPI Spec generation | URL string | &lt;nil&gt; | . | readTimeout | The maximum time to wait when reading from an HTTP connection | time.Duration | 15s | . | shutdownTimeout | The maximum amount of time to wait for any open HTTP requests to finish before shutting down the HTTP server | time.Duration | 10s | . | writeTimeout | The maximum time to wait when writing to an HTTP connection | time.Duration | 15s | . ",
    "url": "/firefly/head/reference/config.html#http",
    "relUrl": "/reference/config.html#http"
  },"157": {
    "doc": "Configuration Reference",
    "title": "http.auth",
    "content": "| Key | Description | Type | Default Value | . | type | The auth plugin to use for server side authentication of requests | string | &lt;nil&gt; | . ",
    "url": "/firefly/head/reference/config.html#httpauth",
    "relUrl": "/reference/config.html#httpauth"
  },"158": {
    "doc": "Configuration Reference",
    "title": "http.auth.basic",
    "content": "| Key | Description | Type | Default Value | . | passwordfile | The path to a .htpasswd file to use for authenticating requests. Passwords should be hashed with bcrypt. | string | &lt;nil&gt; | . ",
    "url": "/firefly/head/reference/config.html#httpauthbasic",
    "relUrl": "/reference/config.html#httpauthbasic"
  },"159": {
    "doc": "Configuration Reference",
    "title": "http.tls",
    "content": "| Key | Description | Type | Default Value | . | caFile | The path to the CA file for TLS on this API | string | &lt;nil&gt; | . | certFile | The path to the certificate file for TLS on this API | string | &lt;nil&gt; | . | clientAuth | Enables or disables client auth for TLS on this API | string | &lt;nil&gt; | . | enabled | Enables or disables TLS on this API | boolean | false | . | keyFile | The path to the private key file for TLS on this API | string | &lt;nil&gt; | . ",
    "url": "/firefly/head/reference/config.html#httptls",
    "relUrl": "/reference/config.html#httptls"
  },"160": {
    "doc": "Configuration Reference",
    "title": "log",
    "content": "| Key | Description | Type | Default Value | . | compress | Determines if the rotated log files should be compressed using gzip | boolean | &lt;nil&gt; | . | filename | Filename is the file to write logs to. Backup log files will be retained in the same directory | string | &lt;nil&gt; | . | filesize | MaxSize is the maximum size the log file before it gets rotated | BytesSize | &lt;nil&gt; | . | forceColor | Force color to be enabled, even when a non-TTY output is detected | boolean | &lt;nil&gt; | . | includeCodeInfo | Enables the report caller for including the calling file and line number, and the calling function. If using text logs, it uses the logrus text format rather than the default prefix format. | boolean | &lt;nil&gt; | . | level | The log level - error, warn, info, debug, trace | string | &lt;nil&gt; | . | maxAge | The maximum time to retain old log files based on the timestamp encoded in their filename | time.Duration | &lt;nil&gt; | . | maxBackups | Maximum number of old log files to retain | int | &lt;nil&gt; | . | noColor | Force color to be disabled, event when TTY output is detected | boolean | &lt;nil&gt; | . | timeFormat | Custom time format for logs | Time format string | &lt;nil&gt; | . | utc | Use UTC timestamps for logs | boolean | &lt;nil&gt; | . ",
    "url": "/firefly/head/reference/config.html#log",
    "relUrl": "/reference/config.html#log"
  },"161": {
    "doc": "Configuration Reference",
    "title": "log.json",
    "content": "| Key | Description | Type | Default Value | . | enabled | Enables JSON formatted logs rather than text. All log color settings are ignored when enabled. | boolean | &lt;nil&gt; | . ",
    "url": "/firefly/head/reference/config.html#logjson",
    "relUrl": "/reference/config.html#logjson"
  },"162": {
    "doc": "Configuration Reference",
    "title": "log.json.fields",
    "content": "| Key | Description | Type | Default Value | . | file | configures the JSON key containing the calling file | string | &lt;nil&gt; | . | func | Configures the JSON key containing the calling function | string | &lt;nil&gt; | . | level | Configures the JSON key containing the log level | string | &lt;nil&gt; | . | message | Configures the JSON key containing the log message | string | &lt;nil&gt; | . | timestamp | Configures the JSON key containing the timestamp of the log | string | &lt;nil&gt; | . ",
    "url": "/firefly/head/reference/config.html#logjsonfields",
    "relUrl": "/reference/config.html#logjsonfields"
  },"163": {
    "doc": "Configuration Reference",
    "title": "message.writer",
    "content": "| Key | Description | Type | Default Value | . | batchMaxInserts | The maximum number of database inserts to include when writing a single batch of messages + data | int | &lt;nil&gt; | . | batchTimeout | How long to wait for more messages to arrive before flushing the batch | time.Duration | &lt;nil&gt; | . | count | The number of message writer workers | int | &lt;nil&gt; | . ",
    "url": "/firefly/head/reference/config.html#messagewriter",
    "relUrl": "/reference/config.html#messagewriter"
  },"164": {
    "doc": "Configuration Reference",
    "title": "metrics",
    "content": "| Key | Description | Type | Default Value | . | address | The IP address on which the metrics HTTP API should listen | int | 127.0.0.1 | . | enabled | Enables the metrics API | boolean | true | . | path | The path from which to serve the Prometheus metrics | string | /metrics | . | port | The port on which the metrics HTTP API should listen | int | 6000 | . | publicURL | The fully qualified public URL for the metrics API. This is used for building URLs in HTTP responses and in OpenAPI Spec generation | URL string | &lt;nil&gt; | . | readTimeout | The maximum time to wait when reading from an HTTP connection | time.Duration | 15s | . | shutdownTimeout | The maximum amount of time to wait for any open HTTP requests to finish before shutting down the HTTP server | time.Duration | 10s | . | writeTimeout | The maximum time to wait when writing to an HTTP connection | time.Duration | 15s | . ",
    "url": "/firefly/head/reference/config.html#metrics",
    "relUrl": "/reference/config.html#metrics"
  },"165": {
    "doc": "Configuration Reference",
    "title": "metrics.auth",
    "content": "| Key | Description | Type | Default Value | . | type | The auth plugin to use for server side authentication of requests | string | &lt;nil&gt; | . ",
    "url": "/firefly/head/reference/config.html#metricsauth",
    "relUrl": "/reference/config.html#metricsauth"
  },"166": {
    "doc": "Configuration Reference",
    "title": "metrics.auth.basic",
    "content": "| Key | Description | Type | Default Value | . | passwordfile | The path to a .htpasswd file to use for authenticating requests. Passwords should be hashed with bcrypt. | string | &lt;nil&gt; | . ",
    "url": "/firefly/head/reference/config.html#metricsauthbasic",
    "relUrl": "/reference/config.html#metricsauthbasic"
  },"167": {
    "doc": "Configuration Reference",
    "title": "metrics.tls",
    "content": "| Key | Description | Type | Default Value | . | caFile | The path to the CA file for TLS on this API | string | &lt;nil&gt; | . | certFile | The path to the certificate file for TLS on this API | string | &lt;nil&gt; | . | clientAuth | Enables or disables client auth for TLS on this API | string | &lt;nil&gt; | . | enabled | Enables or disables TLS on this API | boolean | false | . | keyFile | The path to the private key file for TLS on this API | string | &lt;nil&gt; | . ",
    "url": "/firefly/head/reference/config.html#metricstls",
    "relUrl": "/reference/config.html#metricstls"
  },"168": {
    "doc": "Configuration Reference",
    "title": "namespaces",
    "content": "| Key | Description | Type | Default Value | . | default | The default namespace - must be in the predefined list | string | &lt;nil&gt; | . | predefined | A list of namespaces to ensure exists, without requiring a broadcast from the network | List string | &lt;nil&gt; | . ",
    "url": "/firefly/head/reference/config.html#namespaces",
    "relUrl": "/reference/config.html#namespaces"
  },"169": {
    "doc": "Configuration Reference",
    "title": "namespaces.predefined[]",
    "content": "| Key | Description | Type | Default Value | . | defaultKey | A default signing key for blockchain transactions within this namespace | string | &lt;nil&gt; | . | description | A description for the namespace | string | &lt;nil&gt; | . | name | The name of the namespace (must be unique) | string | &lt;nil&gt; | . | plugins | The list of plugins for this namespace | string | &lt;nil&gt; | . ",
    "url": "/firefly/head/reference/config.html#namespacespredefined",
    "relUrl": "/reference/config.html#namespacespredefined"
  },"170": {
    "doc": "Configuration Reference",
    "title": "namespaces.predefined[].asset.manager",
    "content": "| Key | Description | Type | Default Value | . | keyNormalization | Mechanism to normalize keys before using them. Valid options are blockchain_plugin - use blockchain plugin (default) or none - do not attempt normalization | string | &lt;nil&gt; | . ",
    "url": "/firefly/head/reference/config.html#namespacespredefinedassetmanager",
    "relUrl": "/reference/config.html#namespacespredefinedassetmanager"
  },"171": {
    "doc": "Configuration Reference",
    "title": "namespaces.predefined[].multiparty",
    "content": "| Key | Description | Type | Default Value | . | enabled | Enables multi-party mode for this namespace (defaults to true if an org name or key is configured, either here or at the root level) | boolean | &lt;nil&gt; | . | networknamespace | The shared namespace name to be sent in multiparty messages, if it differs from the local namespace name | string | &lt;nil&gt; | . ",
    "url": "/firefly/head/reference/config.html#namespacespredefinedmultiparty",
    "relUrl": "/reference/config.html#namespacespredefinedmultiparty"
  },"172": {
    "doc": "Configuration Reference",
    "title": "namespaces.predefined[].multiparty.contract[]",
    "content": "| Key | Description | Type | Default Value | . | firstEvent | The first event the contract should process. Valid options are oldest or newest | string | &lt;nil&gt; | . | location | A blockchain-specific contract location. For example, an Ethereum contract address, or a Fabric chaincode name and channe | string | &lt;nil&gt; | . ",
    "url": "/firefly/head/reference/config.html#namespacespredefinedmultipartycontract",
    "relUrl": "/reference/config.html#namespacespredefinedmultipartycontract"
  },"173": {
    "doc": "Configuration Reference",
    "title": "namespaces.predefined[].multiparty.node",
    "content": "| Key | Description | Type | Default Value | . | description | A description for the node in this namespace | string | &lt;nil&gt; | . | name | The node name for this namespace | string | &lt;nil&gt; | . ",
    "url": "/firefly/head/reference/config.html#namespacespredefinedmultipartynode",
    "relUrl": "/reference/config.html#namespacespredefinedmultipartynode"
  },"174": {
    "doc": "Configuration Reference",
    "title": "namespaces.predefined[].multiparty.org",
    "content": "| Key | Description | Type | Default Value | . | description | A description for the local root organization within this namespace | string | &lt;nil&gt; | . | key | The signing key allocated to the root organization within this namespace | string | &lt;nil&gt; | . | name | A short name for the local root organization within this namespace | string | &lt;nil&gt; | . ",
    "url": "/firefly/head/reference/config.html#namespacespredefinedmultipartyorg",
    "relUrl": "/reference/config.html#namespacespredefinedmultipartyorg"
  },"175": {
    "doc": "Configuration Reference",
    "title": "node",
    "content": "| Key | Description | Type | Default Value | . | description | The description of this FireFly node | string | &lt;nil&gt; | . | name | The name of this FireFly node | string | &lt;nil&gt; | . ",
    "url": "/firefly/head/reference/config.html#node",
    "relUrl": "/reference/config.html#node"
  },"176": {
    "doc": "Configuration Reference",
    "title": "opupdate.retry",
    "content": "| Key | Description | Type | Default Value | . | factor | The retry backoff factor | boolean | &lt;nil&gt; | . | initialDelay | The initial retry delay | time.Duration | &lt;nil&gt; | . | maxDelay | The maximum retry delay | time.Duration | &lt;nil&gt; | . ",
    "url": "/firefly/head/reference/config.html#opupdateretry",
    "relUrl": "/reference/config.html#opupdateretry"
  },"177": {
    "doc": "Configuration Reference",
    "title": "opupdate.worker",
    "content": "| Key | Description | Type | Default Value | . | batchMaxInserts | The maximum number of database inserts to include when writing a single batch of messages + data | int | &lt;nil&gt; | . | batchTimeout | How long to wait for more messages to arrive before flushing the batch | time.Duration | &lt;nil&gt; | . | count | The number of operation update works | int | &lt;nil&gt; | . | queueLength | The size of the queue for the Operation Update worker | int | &lt;nil&gt; | . ",
    "url": "/firefly/head/reference/config.html#opupdateworker",
    "relUrl": "/reference/config.html#opupdateworker"
  },"178": {
    "doc": "Configuration Reference",
    "title": "orchestrator",
    "content": "| Key | Description | Type | Default Value | . | startupAttempts | The number of times to attempt to connect to core infrastructure on startup | string | &lt;nil&gt; | . ",
    "url": "/firefly/head/reference/config.html#orchestrator",
    "relUrl": "/reference/config.html#orchestrator"
  },"179": {
    "doc": "Configuration Reference",
    "title": "org",
    "content": "| Key | Description | Type | Default Value | . | description | A description of the organization to which this FireFly node belongs (deprecated - should be set on each multi-party namespace instead) | string | &lt;nil&gt; | . | key | The signing key allocated to the organization (deprecated - should be set on each multi-party namespace instead) | string | &lt;nil&gt; | . | name | The name of the organization to which this FireFly node belongs (deprecated - should be set on each multi-party namespace instead) | string | &lt;nil&gt; | . ",
    "url": "/firefly/head/reference/config.html#org",
    "relUrl": "/reference/config.html#org"
  },"180": {
    "doc": "Configuration Reference",
    "title": "plugins",
    "content": "| Key | Description | Type | Default Value | . | auth | Authorization plugin configuration | map[string]string | &lt;nil&gt; | . | blockchain | The list of configured Blockchain plugins | string | &lt;nil&gt; | . | database | The list of configured Database plugins | string | &lt;nil&gt; | . | dataexchange | The array of configured Data Exchange plugins | string | &lt;nil&gt; | . | identity | The list of available Identity plugins | string | &lt;nil&gt; | . | sharedstorage | The list of configured Shared Storage plugins | string | &lt;nil&gt; | . | tokens | The token plugin configurations | string | &lt;nil&gt; | . ",
    "url": "/firefly/head/reference/config.html#plugins",
    "relUrl": "/reference/config.html#plugins"
  },"181": {
    "doc": "Configuration Reference",
    "title": "plugins.auth[]",
    "content": "| Key | Description | Type | Default Value | . | name | The name of the auth plugin to use | string | &lt;nil&gt; | . | type | The type of the auth plugin to use | string | &lt;nil&gt; | . ",
    "url": "/firefly/head/reference/config.html#pluginsauth",
    "relUrl": "/reference/config.html#pluginsauth"
  },"182": {
    "doc": "Configuration Reference",
    "title": "plugins.auth[].basic",
    "content": "| Key | Description | Type | Default Value | . | passwordfile | The path to a .htpasswd file to use for authenticating requests. Passwords should be hashed with bcrypt. | string | &lt;nil&gt; | . ",
    "url": "/firefly/head/reference/config.html#pluginsauthbasic",
    "relUrl": "/reference/config.html#pluginsauthbasic"
  },"183": {
    "doc": "Configuration Reference",
    "title": "plugins.blockchain[]",
    "content": "| Key | Description | Type | Default Value | . | name | The name of the configured Blockchain plugin | string | &lt;nil&gt; | . | type | The type of the configured Blockchain Connector plugin | string | &lt;nil&gt; | . ",
    "url": "/firefly/head/reference/config.html#pluginsblockchain",
    "relUrl": "/reference/config.html#pluginsblockchain"
  },"184": {
    "doc": "Configuration Reference",
    "title": "plugins.blockchain[].ethereum.addressResolver",
    "content": "| Key | Description | Type | Default Value | . | bodyTemplate | The body go template string to use when making HTTP requests | Go Template string | &lt;nil&gt; | . | connectionTimeout | The maximum amount of time that a connection is allowed to remain with no data transmitted | time.Duration | 30s | . | expectContinueTimeout | See ExpectContinueTimeout in the Go docs | time.Duration | 1s | . | headers | Adds custom headers to HTTP requests | string | &lt;nil&gt; | . | idleTimeout | The max duration to hold a HTTP keepalive connection between calls | time.Duration | 475ms | . | maxIdleConns | The max number of idle connections to hold pooled | int | 100 | . | method | The HTTP method to use when making requests to the Address Resolver | string | GET | . | requestTimeout | The maximum amount of time that a request is allowed to remain open | time.Duration | 30s | . | responseField | The name of a JSON field that is provided in the response, that contains the ethereum address (default address) | string | address | . | retainOriginal | When true the original pre-resolved string is retained after the lookup, and passed down to Ethconnect as the from address | boolean | &lt;nil&gt; | . | tlsHandshakeTimeout | The maximum amount of time to wait for a successful TLS handshake | time.Duration | 10s | . | url | The URL of the Address Resolver | string | &lt;nil&gt; | . | urlTemplate | The URL Go template string to use when calling the Address Resolver | Go Template string | &lt;nil&gt; | . ",
    "url": "/firefly/head/reference/config.html#pluginsblockchainethereumaddressresolver",
    "relUrl": "/reference/config.html#pluginsblockchainethereumaddressresolver"
  },"185": {
    "doc": "Configuration Reference",
    "title": "plugins.blockchain[].ethereum.addressResolver.auth",
    "content": "| Key | Description | Type | Default Value | . | password | Password | string | &lt;nil&gt; | . | username | Username | string | &lt;nil&gt; | . ",
    "url": "/firefly/head/reference/config.html#pluginsblockchainethereumaddressresolverauth",
    "relUrl": "/reference/config.html#pluginsblockchainethereumaddressresolverauth"
  },"186": {
    "doc": "Configuration Reference",
    "title": "plugins.blockchain[].ethereum.addressResolver.proxy",
    "content": "| Key | Description | Type | Default Value | . | url | Optional HTTP proxy server to use when connecting to the Address Resolver | URL string | &lt;nil&gt; | . ",
    "url": "/firefly/head/reference/config.html#pluginsblockchainethereumaddressresolverproxy",
    "relUrl": "/reference/config.html#pluginsblockchainethereumaddressresolverproxy"
  },"187": {
    "doc": "Configuration Reference",
    "title": "plugins.blockchain[].ethereum.addressResolver.retry",
    "content": "| Key | Description | Type | Default Value | . | count | The maximum number of times to retry | int | 5 | . | enabled | Enables retries | boolean | false | . | initWaitTime | The initial retry delay | time.Duration | 250ms | . | maxWaitTime | The maximum retry delay | time.Duration | 30s | . ",
    "url": "/firefly/head/reference/config.html#pluginsblockchainethereumaddressresolverretry",
    "relUrl": "/reference/config.html#pluginsblockchainethereumaddressresolverretry"
  },"188": {
    "doc": "Configuration Reference",
    "title": "plugins.blockchain[].ethereum.ethconnect",
    "content": "| Key | Description | Type | Default Value | . | batchSize | The number of events Ethconnect should batch together for delivery to FireFly core. Only applies when automatically creating a new event stream | int | 50 | . | batchTimeout | How long Ethconnect should wait for new events to arrive and fill a batch, before sending the batch to FireFly core. Only applies when automatically creating a new event stream | time.Duration | 500 | . | connectionTimeout | The maximum amount of time that a connection is allowed to remain with no data transmitted | time.Duration | 30s | . | expectContinueTimeout | See ExpectContinueTimeout in the Go docs | time.Duration | 1s | . | fromBlock | The first event this FireFly instance should listen to from the BatchPin smart contract. Default=0. Only affects initial creation of the event stream | Address string | 0 | . | headers | Adds custom headers to HTTP requests | map[string]string | &lt;nil&gt; | . | idleTimeout | The max duration to hold a HTTP keepalive connection between calls | time.Duration | 475ms | . | instance | The Ethereum address of the FireFly BatchPin smart contract that has been deployed to the blockchain | Address string | &lt;nil&gt; | . | maxIdleConns | The max number of idle connections to hold pooled | int | 100 | . | prefixLong | The prefix that will be used for Ethconnect specific HTTP headers when FireFly makes requests to Ethconnect | string | firefly | . | prefixShort | The prefix that will be used for Ethconnect specific query parameters when FireFly makes requests to Ethconnect | string | fly | . | requestTimeout | The maximum amount of time that a request is allowed to remain open | time.Duration | 30s | . | tlsHandshakeTimeout | The maximum amount of time to wait for a successful TLS handshake | time.Duration | 10s | . | topic | The websocket listen topic that the node should register on, which is important if there are multiple nodes using a single ethconnect | string | &lt;nil&gt; | . | url | The URL of the Ethconnect instance | URL string | &lt;nil&gt; | . ",
    "url": "/firefly/head/reference/config.html#pluginsblockchainethereumethconnect",
    "relUrl": "/reference/config.html#pluginsblockchainethereumethconnect"
  },"189": {
    "doc": "Configuration Reference",
    "title": "plugins.blockchain[].ethereum.ethconnect.auth",
    "content": "| Key | Description | Type | Default Value | . | password | Password | string | &lt;nil&gt; | . | username | Username | string | &lt;nil&gt; | . ",
    "url": "/firefly/head/reference/config.html#pluginsblockchainethereumethconnectauth",
    "relUrl": "/reference/config.html#pluginsblockchainethereumethconnectauth"
  },"190": {
    "doc": "Configuration Reference",
    "title": "plugins.blockchain[].ethereum.ethconnect.proxy",
    "content": "| Key | Description | Type | Default Value | . | url | Optional HTTP proxy server to use when connecting to Ethconnect | URL string | &lt;nil&gt; | . ",
    "url": "/firefly/head/reference/config.html#pluginsblockchainethereumethconnectproxy",
    "relUrl": "/reference/config.html#pluginsblockchainethereumethconnectproxy"
  },"191": {
    "doc": "Configuration Reference",
    "title": "plugins.blockchain[].ethereum.ethconnect.retry",
    "content": "| Key | Description | Type | Default Value | . | count | The maximum number of times to retry | int | 5 | . | enabled | Enables retries | boolean | false | . | initWaitTime | The initial retry delay | time.Duration | 250ms | . | maxWaitTime | The maximum retry delay | time.Duration | 30s | . ",
    "url": "/firefly/head/reference/config.html#pluginsblockchainethereumethconnectretry",
    "relUrl": "/reference/config.html#pluginsblockchainethereumethconnectretry"
  },"192": {
    "doc": "Configuration Reference",
    "title": "plugins.blockchain[].ethereum.ethconnect.ws",
    "content": "| Key | Description | Type | Default Value | . | heartbeatInterval | The amount of time to wait between heartbeat signals on the WebSocket connection | time.Duration | 30s | . | initialConnectAttempts | The number of attempts FireFly will make to connect to the WebSocket when starting up, before failing | int | 5 | . | path | The WebSocket sever URL to which FireFly should connect | WebSocket URL string | &lt;nil&gt; | . | readBufferSize | The size in bytes of the read buffer for the WebSocket connection | BytesSize | 16Kb | . | writeBufferSize | The size in bytes of the write buffer for the WebSocket connection | BytesSize | 16Kb | . ",
    "url": "/firefly/head/reference/config.html#pluginsblockchainethereumethconnectws",
    "relUrl": "/reference/config.html#pluginsblockchainethereumethconnectws"
  },"193": {
    "doc": "Configuration Reference",
    "title": "plugins.blockchain[].ethereum.fftm",
    "content": "| Key | Description | Type | Default Value | . | connectionTimeout | The maximum amount of time that a connection is allowed to remain with no data transmitted | time.Duration | 30s | . | expectContinueTimeout | See ExpectContinueTimeout in the Go docs | time.Duration | 1s | . | headers | Adds custom headers to HTTP requests | map[string]string | &lt;nil&gt; | . | idleTimeout | The max duration to hold a HTTP keepalive connection between calls | time.Duration | 475ms | . | maxIdleConns | The max number of idle connections to hold pooled | int | 100 | . | requestTimeout | The maximum amount of time that a request is allowed to remain open | time.Duration | 30s | . | tlsHandshakeTimeout | The maximum amount of time to wait for a successful TLS handshake | time.Duration | 10s | . | url | The URL of the FireFly Transaction Manager runtime, if enabled | string | &lt;nil&gt; | . ",
    "url": "/firefly/head/reference/config.html#pluginsblockchainethereumfftm",
    "relUrl": "/reference/config.html#pluginsblockchainethereumfftm"
  },"194": {
    "doc": "Configuration Reference",
    "title": "plugins.blockchain[].ethereum.fftm.auth",
    "content": "| Key | Description | Type | Default Value | . | password | Password | string | &lt;nil&gt; | . | username | Username | string | &lt;nil&gt; | . ",
    "url": "/firefly/head/reference/config.html#pluginsblockchainethereumfftmauth",
    "relUrl": "/reference/config.html#pluginsblockchainethereumfftmauth"
  },"195": {
    "doc": "Configuration Reference",
    "title": "plugins.blockchain[].ethereum.fftm.proxy",
    "content": "| Key | Description | Type | Default Value | . | url | Optional HTTP proxy server to use when connecting to the Transaction Manager | string | &lt;nil&gt; | . ",
    "url": "/firefly/head/reference/config.html#pluginsblockchainethereumfftmproxy",
    "relUrl": "/reference/config.html#pluginsblockchainethereumfftmproxy"
  },"196": {
    "doc": "Configuration Reference",
    "title": "plugins.blockchain[].ethereum.fftm.retry",
    "content": "| Key | Description | Type | Default Value | . | count | The maximum number of times to retry | int | 5 | . | enabled | Enables retries | boolean | false | . | initWaitTime | The initial retry delay | time.Duration | 250ms | . | maxWaitTime | The maximum retry delay | time.Duration | 30s | . ",
    "url": "/firefly/head/reference/config.html#pluginsblockchainethereumfftmretry",
    "relUrl": "/reference/config.html#pluginsblockchainethereumfftmretry"
  },"197": {
    "doc": "Configuration Reference",
    "title": "plugins.blockchain[].fabric.fabconnect",
    "content": "| Key | Description | Type | Default Value | . | batchSize | The number of events Fabconnect should batch together for delivery to FireFly core. Only applies when automatically creating a new event stream | int | 50 | . | batchTimeout | The maximum amount of time to wait for a batch to complete | time.Duration | 500 | . | chaincode | The name of the Fabric chaincode that FireFly will use for BatchPin transactions (deprecated - use fireflyContract[].chaincode) | string | &lt;nil&gt; | . | channel | The Fabric channel that FireFly will use for BatchPin transactions | string | &lt;nil&gt; | . | connectionTimeout | The maximum amount of time that a connection is allowed to remain with no data transmitted | time.Duration | 30s | . | expectContinueTimeout | See ExpectContinueTimeout in the Go docs | time.Duration | 1s | . | headers | Adds custom headers to HTTP requests | map[string]string | &lt;nil&gt; | . | idleTimeout | The max duration to hold a HTTP keepalive connection between calls | time.Duration | 475ms | . | maxIdleConns | The max number of idle connections to hold pooled | int | 100 | . | prefixLong | The prefix that will be used for Fabconnect specific HTTP headers when FireFly makes requests to Fabconnect | string | firefly | . | prefixShort | The prefix that will be used for Fabconnect specific query parameters when FireFly makes requests to Fabconnect | string | fly | . | requestTimeout | The maximum amount of time that a request is allowed to remain open | time.Duration | 30s | . | signer | The Fabric signing key to use when submitting transactions to Fabconnect | string | &lt;nil&gt; | . | tlsHandshakeTimeout | The maximum amount of time to wait for a successful TLS handshake | time.Duration | 10s | . | topic | The websocket listen topic that the node should register on, which is important if there are multiple nodes using a single Fabconnect | string | &lt;nil&gt; | . | url | The URL of the Fabconnect instance | URL string | &lt;nil&gt; | . ",
    "url": "/firefly/head/reference/config.html#pluginsblockchainfabricfabconnect",
    "relUrl": "/reference/config.html#pluginsblockchainfabricfabconnect"
  },"198": {
    "doc": "Configuration Reference",
    "title": "plugins.blockchain[].fabric.fabconnect.auth",
    "content": "| Key | Description | Type | Default Value | . | password | Password | string | &lt;nil&gt; | . | username | Username | string | &lt;nil&gt; | . ",
    "url": "/firefly/head/reference/config.html#pluginsblockchainfabricfabconnectauth",
    "relUrl": "/reference/config.html#pluginsblockchainfabricfabconnectauth"
  },"199": {
    "doc": "Configuration Reference",
    "title": "plugins.blockchain[].fabric.fabconnect.proxy",
    "content": "| Key | Description | Type | Default Value | . | url | Optional HTTP proxy server to use when connecting to Fabconnect | URL string | &lt;nil&gt; | . ",
    "url": "/firefly/head/reference/config.html#pluginsblockchainfabricfabconnectproxy",
    "relUrl": "/reference/config.html#pluginsblockchainfabricfabconnectproxy"
  },"200": {
    "doc": "Configuration Reference",
    "title": "plugins.blockchain[].fabric.fabconnect.retry",
    "content": "| Key | Description | Type | Default Value | . | count | The maximum number of times to retry | int | 5 | . | enabled | Enables retries | boolean | false | . | initWaitTime | The initial retry delay | time.Duration | 250ms | . | maxWaitTime | The maximum retry delay | time.Duration | 30s | . ",
    "url": "/firefly/head/reference/config.html#pluginsblockchainfabricfabconnectretry",
    "relUrl": "/reference/config.html#pluginsblockchainfabricfabconnectretry"
  },"201": {
    "doc": "Configuration Reference",
    "title": "plugins.blockchain[].fabric.fabconnect.ws",
    "content": "| Key | Description | Type | Default Value | . | heartbeatInterval | The amount of time to wait between heartbeat signals on the WebSocket connection | time.Duration | 30s | . | initialConnectAttempts | The number of attempts FireFly will make to connect to the WebSocket when starting up, before failing | int | 5 | . | path | The WebSocket sever URL to which FireFly should connect | WebSocket URL string | &lt;nil&gt; | . | readBufferSize | The size in bytes of the read buffer for the WebSocket connection | BytesSize | 16Kb | . | writeBufferSize | The size in bytes of the write buffer for the WebSocket connection | BytesSize | 16Kb | . ",
    "url": "/firefly/head/reference/config.html#pluginsblockchainfabricfabconnectws",
    "relUrl": "/reference/config.html#pluginsblockchainfabricfabconnectws"
  },"202": {
    "doc": "Configuration Reference",
    "title": "plugins.database[]",
    "content": "| Key | Description | Type | Default Value | . | name | The name of the Database plugin | string | &lt;nil&gt; | . | type | The type of the configured Database plugin | string | &lt;nil&gt; | . ",
    "url": "/firefly/head/reference/config.html#pluginsdatabase",
    "relUrl": "/reference/config.html#pluginsdatabase"
  },"203": {
    "doc": "Configuration Reference",
    "title": "plugins.database[].postgres",
    "content": "| Key | Description | Type | Default Value | . | maxConnIdleTime | The maximum amount of time a database connection can be idle | time.Duration | 1m | . | maxConnLifetime | The maximum amount of time to keep a database connection open | time.Duration | &lt;nil&gt; | . | maxConns | Maximum connections to the database | int | 50 | . | maxIdleConns | The maximum number of idle connections to the database | int | &lt;nil&gt; | . | url | The PostgreSQL connection string for the database | string | &lt;nil&gt; | . ",
    "url": "/firefly/head/reference/config.html#pluginsdatabasepostgres",
    "relUrl": "/reference/config.html#pluginsdatabasepostgres"
  },"204": {
    "doc": "Configuration Reference",
    "title": "plugins.database[].postgres.migrations",
    "content": "| Key | Description | Type | Default Value | . | auto | Enables automatic database migrations | boolean | false | . | directory | The directory containing the numerically ordered migration DDL files to apply to the database | string | ./db/migrations/postgres | . ",
    "url": "/firefly/head/reference/config.html#pluginsdatabasepostgresmigrations",
    "relUrl": "/reference/config.html#pluginsdatabasepostgresmigrations"
  },"205": {
    "doc": "Configuration Reference",
    "title": "plugins.database[].sqlite3",
    "content": "| Key | Description | Type | Default Value | . | maxConnIdleTime | The maximum amount of time a database connection can be idle | time.Duration | 1m | . | maxConnLifetime | The maximum amount of time to keep a database connection open | time.Duration | &lt;nil&gt; | . | maxConns | Maximum connections to the database | int | 1 | . | maxIdleConns | The maximum number of idle connections to the database | int | &lt;nil&gt; | . | url | The SQLite connection string for the database | string | &lt;nil&gt; | . ",
    "url": "/firefly/head/reference/config.html#pluginsdatabasesqlite3",
    "relUrl": "/reference/config.html#pluginsdatabasesqlite3"
  },"206": {
    "doc": "Configuration Reference",
    "title": "plugins.database[].sqlite3.migrations",
    "content": "| Key | Description | Type | Default Value | . | auto | Enables automatic database migrations | boolean | false | . | directory | The directory containing the numerically ordered migration DDL files to apply to the database | string | ./db/migrations/sqlite | . ",
    "url": "/firefly/head/reference/config.html#pluginsdatabasesqlite3migrations",
    "relUrl": "/reference/config.html#pluginsdatabasesqlite3migrations"
  },"207": {
    "doc": "Configuration Reference",
    "title": "plugins.dataexchange[]",
    "content": "| Key | Description | Type | Default Value | . | name | The name of the configured Data Exchange plugin | string | &lt;nil&gt; | . | type | The Data Exchange plugin to use | string | &lt;nil&gt; | . ",
    "url": "/firefly/head/reference/config.html#pluginsdataexchange",
    "relUrl": "/reference/config.html#pluginsdataexchange"
  },"208": {
    "doc": "Configuration Reference",
    "title": "plugins.dataexchange[].ffdx",
    "content": "| Key | Description | Type | Default Value | . | connectionTimeout | The maximum amount of time that a connection is allowed to remain with no data transmitted | time.Duration | 30s | . | expectContinueTimeout | See ExpectContinueTimeout in the Go docs | time.Duration | 1s | . | headers | Adds custom headers to HTTP requests | map[string]string | &lt;nil&gt; | . | idleTimeout | The max duration to hold a HTTP keepalive connection between calls | time.Duration | 475ms | . | initEnabled | Instructs FireFly to always post all current nodes to the /init API before connecting or reconnecting to the connector | boolean | false | . | manifestEnabled | Determines whether to require+validate a manifest from other DX instances in the network. Must be supported by the connector | string | false | . | maxIdleConns | The max number of idle connections to hold pooled | int | 100 | . | requestTimeout | The maximum amount of time that a request is allowed to remain open | time.Duration | 30s | . | tlsHandshakeTimeout | The maximum amount of time to wait for a successful TLS handshake | time.Duration | 10s | . | url | The URL of the Data Exchange instance | URL string | &lt;nil&gt; | . ",
    "url": "/firefly/head/reference/config.html#pluginsdataexchangeffdx",
    "relUrl": "/reference/config.html#pluginsdataexchangeffdx"
  },"209": {
    "doc": "Configuration Reference",
    "title": "plugins.dataexchange[].ffdx.auth",
    "content": "| Key | Description | Type | Default Value | . | password | Password | string | &lt;nil&gt; | . | username | Username | string | &lt;nil&gt; | . ",
    "url": "/firefly/head/reference/config.html#pluginsdataexchangeffdxauth",
    "relUrl": "/reference/config.html#pluginsdataexchangeffdxauth"
  },"210": {
    "doc": "Configuration Reference",
    "title": "plugins.dataexchange[].ffdx.proxy",
    "content": "| Key | Description | Type | Default Value | . | url | Optional HTTP proxy server to use when connecting to the Data Exchange | URL string | &lt;nil&gt; | . ",
    "url": "/firefly/head/reference/config.html#pluginsdataexchangeffdxproxy",
    "relUrl": "/reference/config.html#pluginsdataexchangeffdxproxy"
  },"211": {
    "doc": "Configuration Reference",
    "title": "plugins.dataexchange[].ffdx.retry",
    "content": "| Key | Description | Type | Default Value | . | count | The maximum number of times to retry | int | 5 | . | enabled | Enables retries | boolean | false | . | initWaitTime | The initial retry delay | time.Duration | 250ms | . | maxWaitTime | The maximum retry delay | time.Duration | 30s | . ",
    "url": "/firefly/head/reference/config.html#pluginsdataexchangeffdxretry",
    "relUrl": "/reference/config.html#pluginsdataexchangeffdxretry"
  },"212": {
    "doc": "Configuration Reference",
    "title": "plugins.dataexchange[].ffdx.ws",
    "content": "| Key | Description | Type | Default Value | . | heartbeatInterval | The amount of time to wait between heartbeat signals on the WebSocket connection | time.Duration | 30s | . | initialConnectAttempts | The number of attempts FireFly will make to connect to the WebSocket when starting up, before failing | int | 5 | . | path | The WebSocket sever URL to which FireFly should connect | WebSocket URL string | &lt;nil&gt; | . | readBufferSize | The size in bytes of the read buffer for the WebSocket connection | BytesSize | 16Kb | . | writeBufferSize | The size in bytes of the write buffer for the WebSocket connection | BytesSize | 16Kb | . ",
    "url": "/firefly/head/reference/config.html#pluginsdataexchangeffdxws",
    "relUrl": "/reference/config.html#pluginsdataexchangeffdxws"
  },"213": {
    "doc": "Configuration Reference",
    "title": "plugins.identity[]",
    "content": "| Key | Description | Type | Default Value | . | name | The name of a configured Identity plugin | string | &lt;nil&gt; | . | type | The type of a configured Identity plugin | string | &lt;nil&gt; | . ",
    "url": "/firefly/head/reference/config.html#pluginsidentity",
    "relUrl": "/reference/config.html#pluginsidentity"
  },"214": {
    "doc": "Configuration Reference",
    "title": "plugins.sharedstorage[]",
    "content": "| Key | Description | Type | Default Value | . | name | The name of the Shared Storage plugin to use | string | &lt;nil&gt; | . | type | The Shared Storage plugin to use | string | &lt;nil&gt; | . ",
    "url": "/firefly/head/reference/config.html#pluginssharedstorage",
    "relUrl": "/reference/config.html#pluginssharedstorage"
  },"215": {
    "doc": "Configuration Reference",
    "title": "plugins.sharedstorage[].ipfs.api",
    "content": "| Key | Description | Type | Default Value | . | connectionTimeout | The maximum amount of time that a connection is allowed to remain with no data transmitted | time.Duration | 30s | . | expectContinueTimeout | See ExpectContinueTimeout in the Go docs | time.Duration | 1s | . | headers | Adds custom headers to HTTP requests | map[string]string | &lt;nil&gt; | . | idleTimeout | The max duration to hold a HTTP keepalive connection between calls | time.Duration | 475ms | . | maxIdleConns | The max number of idle connections to hold pooled | int | 100 | . | requestTimeout | The maximum amount of time that a request is allowed to remain open | time.Duration | 30s | . | tlsHandshakeTimeout | The maximum amount of time to wait for a successful TLS handshake | time.Duration | 10s | . | url | The URL for the IPFS API | URL string | &lt;nil&gt; | . ",
    "url": "/firefly/head/reference/config.html#pluginssharedstorageipfsapi",
    "relUrl": "/reference/config.html#pluginssharedstorageipfsapi"
  },"216": {
    "doc": "Configuration Reference",
    "title": "plugins.sharedstorage[].ipfs.api.auth",
    "content": "| Key | Description | Type | Default Value | . | password | Password | string | &lt;nil&gt; | . | username | Username | string | &lt;nil&gt; | . ",
    "url": "/firefly/head/reference/config.html#pluginssharedstorageipfsapiauth",
    "relUrl": "/reference/config.html#pluginssharedstorageipfsapiauth"
  },"217": {
    "doc": "Configuration Reference",
    "title": "plugins.sharedstorage[].ipfs.api.proxy",
    "content": "| Key | Description | Type | Default Value | . | url | Optional HTTP proxy server to use when connecting to the IPFS API | URL string | &lt;nil&gt; | . ",
    "url": "/firefly/head/reference/config.html#pluginssharedstorageipfsapiproxy",
    "relUrl": "/reference/config.html#pluginssharedstorageipfsapiproxy"
  },"218": {
    "doc": "Configuration Reference",
    "title": "plugins.sharedstorage[].ipfs.api.retry",
    "content": "| Key | Description | Type | Default Value | . | count | The maximum number of times to retry | int | 5 | . | enabled | Enables retries | boolean | false | . | initWaitTime | The initial retry delay | time.Duration | 250ms | . | maxWaitTime | The maximum retry delay | time.Duration | 30s | . ",
    "url": "/firefly/head/reference/config.html#pluginssharedstorageipfsapiretry",
    "relUrl": "/reference/config.html#pluginssharedstorageipfsapiretry"
  },"219": {
    "doc": "Configuration Reference",
    "title": "plugins.sharedstorage[].ipfs.gateway",
    "content": "| Key | Description | Type | Default Value | . | connectionTimeout | The maximum amount of time that a connection is allowed to remain with no data transmitted | time.Duration | 30s | . | expectContinueTimeout | See ExpectContinueTimeout in the Go docs | time.Duration | 1s | . | headers | Adds custom headers to HTTP requests | map[string]string | &lt;nil&gt; | . | idleTimeout | The max duration to hold a HTTP keepalive connection between calls | time.Duration | 475ms | . | maxIdleConns | The max number of idle connections to hold pooled | int | 100 | . | requestTimeout | The maximum amount of time that a request is allowed to remain open | time.Duration | 30s | . | tlsHandshakeTimeout | The maximum amount of time to wait for a successful TLS handshake | time.Duration | 10s | . | url | The URL for the IPFS Gateway | URL string | &lt;nil&gt; | . ",
    "url": "/firefly/head/reference/config.html#pluginssharedstorageipfsgateway",
    "relUrl": "/reference/config.html#pluginssharedstorageipfsgateway"
  },"220": {
    "doc": "Configuration Reference",
    "title": "plugins.sharedstorage[].ipfs.gateway.auth",
    "content": "| Key | Description | Type | Default Value | . | password | Password | string | &lt;nil&gt; | . | username | Username | string | &lt;nil&gt; | . ",
    "url": "/firefly/head/reference/config.html#pluginssharedstorageipfsgatewayauth",
    "relUrl": "/reference/config.html#pluginssharedstorageipfsgatewayauth"
  },"221": {
    "doc": "Configuration Reference",
    "title": "plugins.sharedstorage[].ipfs.gateway.proxy",
    "content": "| Key | Description | Type | Default Value | . | url | Optional HTTP proxy server to use when connecting to the IPFS Gateway | URL string | &lt;nil&gt; | . ",
    "url": "/firefly/head/reference/config.html#pluginssharedstorageipfsgatewayproxy",
    "relUrl": "/reference/config.html#pluginssharedstorageipfsgatewayproxy"
  },"222": {
    "doc": "Configuration Reference",
    "title": "plugins.sharedstorage[].ipfs.gateway.retry",
    "content": "| Key | Description | Type | Default Value | . | count | The maximum number of times to retry | int | 5 | . | enabled | Enables retries | boolean | false | . | initWaitTime | The initial retry delay | time.Duration | 250ms | . | maxWaitTime | The maximum retry delay | time.Duration | 30s | . ",
    "url": "/firefly/head/reference/config.html#pluginssharedstorageipfsgatewayretry",
    "relUrl": "/reference/config.html#pluginssharedstorageipfsgatewayretry"
  },"223": {
    "doc": "Configuration Reference",
    "title": "plugins.tokens[]",
    "content": "| Key | Description | Type | Default Value | . | broadcastName | The name to be used in broadcast messages related to this token plugin, if it differs from the local plugin name | string | &lt;nil&gt; | . | name | A name to identify this token plugin | string | &lt;nil&gt; | . | type | The type of the token plugin to use | string | &lt;nil&gt; | . ",
    "url": "/firefly/head/reference/config.html#pluginstokens",
    "relUrl": "/reference/config.html#pluginstokens"
  },"224": {
    "doc": "Configuration Reference",
    "title": "plugins.tokens[].fftokens",
    "content": "| Key | Description | Type | Default Value | . | connectionTimeout | The maximum amount of time that a connection is allowed to remain with no data transmitted | time.Duration | 30s | . | expectContinueTimeout | See ExpectContinueTimeout in the Go docs | time.Duration | 1s | . | headers | Adds custom headers to HTTP requests | map[string]string | &lt;nil&gt; | . | idleTimeout | The max duration to hold a HTTP keepalive connection between calls | time.Duration | 475ms | . | maxIdleConns | The max number of idle connections to hold pooled | int | 100 | . | requestTimeout | The maximum amount of time that a request is allowed to remain open | time.Duration | 30s | . | tlsHandshakeTimeout | The maximum amount of time to wait for a successful TLS handshake | time.Duration | 10s | . | url | The URL of the token connector | URL string | &lt;nil&gt; | . ",
    "url": "/firefly/head/reference/config.html#pluginstokensfftokens",
    "relUrl": "/reference/config.html#pluginstokensfftokens"
  },"225": {
    "doc": "Configuration Reference",
    "title": "plugins.tokens[].fftokens.auth",
    "content": "| Key | Description | Type | Default Value | . | password | Password | string | &lt;nil&gt; | . | username | Username | string | &lt;nil&gt; | . ",
    "url": "/firefly/head/reference/config.html#pluginstokensfftokensauth",
    "relUrl": "/reference/config.html#pluginstokensfftokensauth"
  },"226": {
    "doc": "Configuration Reference",
    "title": "plugins.tokens[].fftokens.proxy",
    "content": "| Key | Description | Type | Default Value | . | url | Optional HTTP proxy server to use when connecting to the token connector | URL string | &lt;nil&gt; | . ",
    "url": "/firefly/head/reference/config.html#pluginstokensfftokensproxy",
    "relUrl": "/reference/config.html#pluginstokensfftokensproxy"
  },"227": {
    "doc": "Configuration Reference",
    "title": "plugins.tokens[].fftokens.retry",
    "content": "| Key | Description | Type | Default Value | . | count | The maximum number of times to retry | int | 5 | . | enabled | Enables retries | boolean | false | . | initWaitTime | The initial retry delay | time.Duration | 250ms | . | maxWaitTime | The maximum retry delay | time.Duration | 30s | . ",
    "url": "/firefly/head/reference/config.html#pluginstokensfftokensretry",
    "relUrl": "/reference/config.html#pluginstokensfftokensretry"
  },"228": {
    "doc": "Configuration Reference",
    "title": "plugins.tokens[].fftokens.ws",
    "content": "| Key | Description | Type | Default Value | . | heartbeatInterval | The amount of time to wait between heartbeat signals on the WebSocket connection | time.Duration | 30s | . | initialConnectAttempts | The number of attempts FireFly will make to connect to the WebSocket when starting up, before failing | int | 5 | . | path | The WebSocket sever URL to which FireFly should connect | WebSocket URL string | &lt;nil&gt; | . | readBufferSize | The size in bytes of the read buffer for the WebSocket connection | BytesSize | 16Kb | . | writeBufferSize | The size in bytes of the write buffer for the WebSocket connection | BytesSize | 16Kb | . ",
    "url": "/firefly/head/reference/config.html#pluginstokensfftokensws",
    "relUrl": "/reference/config.html#pluginstokensfftokensws"
  },"229": {
    "doc": "Configuration Reference",
    "title": "privatemessaging.batch",
    "content": "| Key | Description | Type | Default Value | . | agentTimeout | How long to keep around a batching agent for a sending identity before disposal | time.Duration | &lt;nil&gt; | . | payloadLimit | The maximum payload size of a private message Data Exchange payload | BytesSize | &lt;nil&gt; | . | size | The maximum number of messages in a batch for private messages | int | &lt;nil&gt; | . | timeout | The timeout to wait for a batch to fill, before sending | time.Duration | &lt;nil&gt; | . ",
    "url": "/firefly/head/reference/config.html#privatemessagingbatch",
    "relUrl": "/reference/config.html#privatemessagingbatch"
  },"230": {
    "doc": "Configuration Reference",
    "title": "privatemessaging.retry",
    "content": "| Key | Description | Type | Default Value | . | factor | The retry backoff factor | boolean | &lt;nil&gt; | . | initDelay | The initial retry delay | time.Duration | &lt;nil&gt; | . | maxDelay | The maximum retry delay | time.Duration | &lt;nil&gt; | . ",
    "url": "/firefly/head/reference/config.html#privatemessagingretry",
    "relUrl": "/reference/config.html#privatemessagingretry"
  },"231": {
    "doc": "Configuration Reference",
    "title": "sharedstorage",
    "content": "| Key | Description | Type | Default Value | . | type | The Shared Storage plugin to use | string | &lt;nil&gt; | . ",
    "url": "/firefly/head/reference/config.html#sharedstorage",
    "relUrl": "/reference/config.html#sharedstorage"
  },"232": {
    "doc": "Configuration Reference",
    "title": "sharedstorage.ipfs.api",
    "content": "| Key | Description | Type | Default Value | . | connectionTimeout | The maximum amount of time that a connection is allowed to remain with no data transmitted | time.Duration | 30s | . | expectContinueTimeout | See ExpectContinueTimeout in the Go docs | time.Duration | 1s | . | headers | Adds custom headers to HTTP requests | map[string]string | &lt;nil&gt; | . | idleTimeout | The max duration to hold a HTTP keepalive connection between calls | time.Duration | 475ms | . | maxIdleConns | The max number of idle connections to hold pooled | int | 100 | . | requestTimeout | The maximum amount of time that a request is allowed to remain open | time.Duration | 30s | . | tlsHandshakeTimeout | The maximum amount of time to wait for a successful TLS handshake | time.Duration | 10s | . | url | The URL for the IPFS API | URL string | &lt;nil&gt; | . ",
    "url": "/firefly/head/reference/config.html#sharedstorageipfsapi",
    "relUrl": "/reference/config.html#sharedstorageipfsapi"
  },"233": {
    "doc": "Configuration Reference",
    "title": "sharedstorage.ipfs.api.auth",
    "content": "| Key | Description | Type | Default Value | . | password | Password | string | &lt;nil&gt; | . | username | Username | string | &lt;nil&gt; | . ",
    "url": "/firefly/head/reference/config.html#sharedstorageipfsapiauth",
    "relUrl": "/reference/config.html#sharedstorageipfsapiauth"
  },"234": {
    "doc": "Configuration Reference",
    "title": "sharedstorage.ipfs.api.proxy",
    "content": "| Key | Description | Type | Default Value | . | url | Optional HTTP proxy server to use when connecting to the IPFS API | URL string | &lt;nil&gt; | . ",
    "url": "/firefly/head/reference/config.html#sharedstorageipfsapiproxy",
    "relUrl": "/reference/config.html#sharedstorageipfsapiproxy"
  },"235": {
    "doc": "Configuration Reference",
    "title": "sharedstorage.ipfs.api.retry",
    "content": "| Key | Description | Type | Default Value | . | count | The maximum number of times to retry | int | 5 | . | enabled | Enables retries | boolean | false | . | initWaitTime | The initial retry delay | time.Duration | 250ms | . | maxWaitTime | The maximum retry delay | time.Duration | 30s | . ",
    "url": "/firefly/head/reference/config.html#sharedstorageipfsapiretry",
    "relUrl": "/reference/config.html#sharedstorageipfsapiretry"
  },"236": {
    "doc": "Configuration Reference",
    "title": "sharedstorage.ipfs.gateway",
    "content": "| Key | Description | Type | Default Value | . | connectionTimeout | The maximum amount of time that a connection is allowed to remain with no data transmitted | time.Duration | 30s | . | expectContinueTimeout | See ExpectContinueTimeout in the Go docs | time.Duration | 1s | . | headers | Adds custom headers to HTTP requests | map[string]string | &lt;nil&gt; | . | idleTimeout | The max duration to hold a HTTP keepalive connection between calls | time.Duration | 475ms | . | maxIdleConns | The max number of idle connections to hold pooled | int | 100 | . | requestTimeout | The maximum amount of time that a request is allowed to remain open | time.Duration | 30s | . | tlsHandshakeTimeout | The maximum amount of time to wait for a successful TLS handshake | time.Duration | 10s | . | url | The URL for the IPFS Gateway | URL string | &lt;nil&gt; | . ",
    "url": "/firefly/head/reference/config.html#sharedstorageipfsgateway",
    "relUrl": "/reference/config.html#sharedstorageipfsgateway"
  },"237": {
    "doc": "Configuration Reference",
    "title": "sharedstorage.ipfs.gateway.auth",
    "content": "| Key | Description | Type | Default Value | . | password | Password | string | &lt;nil&gt; | . | username | Username | string | &lt;nil&gt; | . ",
    "url": "/firefly/head/reference/config.html#sharedstorageipfsgatewayauth",
    "relUrl": "/reference/config.html#sharedstorageipfsgatewayauth"
  },"238": {
    "doc": "Configuration Reference",
    "title": "sharedstorage.ipfs.gateway.proxy",
    "content": "| Key | Description | Type | Default Value | . | url | Optional HTTP proxy server to use when connecting to the IPFS Gateway | URL string | &lt;nil&gt; | . ",
    "url": "/firefly/head/reference/config.html#sharedstorageipfsgatewayproxy",
    "relUrl": "/reference/config.html#sharedstorageipfsgatewayproxy"
  },"239": {
    "doc": "Configuration Reference",
    "title": "sharedstorage.ipfs.gateway.retry",
    "content": "| Key | Description | Type | Default Value | . | count | The maximum number of times to retry | int | 5 | . | enabled | Enables retries | boolean | false | . | initWaitTime | The initial retry delay | time.Duration | 250ms | . | maxWaitTime | The maximum retry delay | time.Duration | 30s | . ",
    "url": "/firefly/head/reference/config.html#sharedstorageipfsgatewayretry",
    "relUrl": "/reference/config.html#sharedstorageipfsgatewayretry"
  },"240": {
    "doc": "Configuration Reference",
    "title": "spi",
    "content": "| Key | Description | Type | Default Value | . | address | The IP address on which the admin HTTP API should listen | IP Address string | 127.0.0.1 | . | enabled | Enables the admin HTTP API | boolean | &lt;nil&gt; | . | port | The port on which the admin HTTP API should listen | int | 5001 | . | publicURL | The fully qualified public URL for the admin API. This is used for building URLs in HTTP responses and in OpenAPI Spec generation | URL string | &lt;nil&gt; | . | readTimeout | The maximum time to wait when reading from an HTTP connection | time.Duration | 15s | . | shutdownTimeout | The maximum amount of time to wait for any open HTTP requests to finish before shutting down the HTTP server | time.Duration | 10s | . | writeTimeout | The maximum time to wait when writing to an HTTP connection | time.Duration | 15s | . ",
    "url": "/firefly/head/reference/config.html#spi",
    "relUrl": "/reference/config.html#spi"
  },"241": {
    "doc": "Configuration Reference",
    "title": "spi.auth",
    "content": "| Key | Description | Type | Default Value | . | type | The auth plugin to use for server side authentication of requests | string | &lt;nil&gt; | . ",
    "url": "/firefly/head/reference/config.html#spiauth",
    "relUrl": "/reference/config.html#spiauth"
  },"242": {
    "doc": "Configuration Reference",
    "title": "spi.auth.basic",
    "content": "| Key | Description | Type | Default Value | . | passwordfile | The path to a .htpasswd file to use for authenticating requests. Passwords should be hashed with bcrypt. | string | &lt;nil&gt; | . ",
    "url": "/firefly/head/reference/config.html#spiauthbasic",
    "relUrl": "/reference/config.html#spiauthbasic"
  },"243": {
    "doc": "Configuration Reference",
    "title": "spi.tls",
    "content": "| Key | Description | Type | Default Value | . | caFile | The path to the CA file for TLS on this API | string | &lt;nil&gt; | . | certFile | The path to the certificate file for TLS on this API | string | &lt;nil&gt; | . | clientAuth | Enables or disables client auth for TLS on this API | string | &lt;nil&gt; | . | enabled | Enables or disables TLS on this API | boolean | false | . | keyFile | The path to the private key file for TLS on this API | string | &lt;nil&gt; | . ",
    "url": "/firefly/head/reference/config.html#spitls",
    "relUrl": "/reference/config.html#spitls"
  },"244": {
    "doc": "Configuration Reference",
    "title": "spi.ws",
    "content": "| Key | Description | Type | Default Value | . | blockedWarnInterval | How often to log warnings in core, when an admin change event listener falls behind the stream they requested and misses events | time.Duration | &lt;nil&gt; | . | eventQueueLength | Server-side queue length for events waiting for delivery over an admin change event listener websocket | int | &lt;nil&gt; | . | readBufferSize | The size in bytes of the read buffer for the WebSocket connection | BytesSize | &lt;nil&gt; | . | writeBufferSize | The size in bytes of the write buffer for the WebSocket connection | BytesSize | &lt;nil&gt; | . ",
    "url": "/firefly/head/reference/config.html#spiws",
    "relUrl": "/reference/config.html#spiws"
  },"245": {
    "doc": "Configuration Reference",
    "title": "subscription",
    "content": "| Key | Description | Type | Default Value | . | max | The maximum number of pre-defined subscriptions that can exist (note for high fan-out consider connecting a dedicated pub/sub broker to the dispatcher) | int | &lt;nil&gt; | . ",
    "url": "/firefly/head/reference/config.html#subscription",
    "relUrl": "/reference/config.html#subscription"
  },"246": {
    "doc": "Configuration Reference",
    "title": "subscription.defaults",
    "content": "| Key | Description | Type | Default Value | . | batchSize | Default read ahead to enable for subscriptions that do not explicitly configure readahead | int | &lt;nil&gt; | . ",
    "url": "/firefly/head/reference/config.html#subscriptiondefaults",
    "relUrl": "/reference/config.html#subscriptiondefaults"
  },"247": {
    "doc": "Configuration Reference",
    "title": "subscription.retry",
    "content": "| Key | Description | Type | Default Value | . | factor | The retry backoff factor | boolean | &lt;nil&gt; | . | initDelay | The initial retry delay | time.Duration | &lt;nil&gt; | . | maxDelay | The maximum retry delay | time.Duration | &lt;nil&gt; | . ",
    "url": "/firefly/head/reference/config.html#subscriptionretry",
    "relUrl": "/reference/config.html#subscriptionretry"
  },"248": {
    "doc": "Configuration Reference",
    "title": "tokens[]",
    "content": "| Key | Description | Type | Default Value | . | connectionTimeout | The maximum amount of time that a connection is allowed to remain with no data transmitted | time.Duration | &lt;nil&gt; | . | expectContinueTimeout | See ExpectContinueTimeout in the Go docs | time.Duration | &lt;nil&gt; | . | headers | Adds custom headers to HTTP requests | map[string]string | &lt;nil&gt; | . | idleTimeout | The max duration to hold a HTTP keepalive connection between calls | time.Duration | &lt;nil&gt; | . | maxIdleConns | The max number of idle connections to hold pooled | int | &lt;nil&gt; | . | name | A name to identify this token plugin | string | &lt;nil&gt; | . | plugin | The type of the token plugin to use | string | &lt;nil&gt; | . | requestTimeout | The maximum amount of time that a request is allowed to remain open | time.Duration | &lt;nil&gt; | . | tlsHandshakeTimeout | The maximum amount of time to wait for a successful TLS handshake | time.Duration | &lt;nil&gt; | . | url | The URL of the token connector | URL string | &lt;nil&gt; | . ",
    "url": "/firefly/head/reference/config.html#tokens",
    "relUrl": "/reference/config.html#tokens"
  },"249": {
    "doc": "Configuration Reference",
    "title": "tokens[].auth",
    "content": "| Key | Description | Type | Default Value | . | password | Password | string | &lt;nil&gt; | . | username | Username | string | &lt;nil&gt; | . ",
    "url": "/firefly/head/reference/config.html#tokensauth",
    "relUrl": "/reference/config.html#tokensauth"
  },"250": {
    "doc": "Configuration Reference",
    "title": "tokens[].proxy",
    "content": "| Key | Description | Type | Default Value | . | url | Optional HTTP proxy server to use when connecting to the token connector | URL string | &lt;nil&gt; | . ",
    "url": "/firefly/head/reference/config.html#tokensproxy",
    "relUrl": "/reference/config.html#tokensproxy"
  },"251": {
    "doc": "Configuration Reference",
    "title": "tokens[].retry",
    "content": "| Key | Description | Type | Default Value | . | count | The maximum number of times to retry | int | &lt;nil&gt; | . | enabled | Enables retries | boolean | &lt;nil&gt; | . | initWaitTime | The initial retry delay | time.Duration | &lt;nil&gt; | . | maxWaitTime | The maximum retry delay | time.Duration | &lt;nil&gt; | . ",
    "url": "/firefly/head/reference/config.html#tokensretry",
    "relUrl": "/reference/config.html#tokensretry"
  },"252": {
    "doc": "Configuration Reference",
    "title": "tokens[].ws",
    "content": "| Key | Description | Type | Default Value | . | heartbeatInterval | The amount of time to wait between heartbeat signals on the WebSocket connection | time.Duration | &lt;nil&gt; | . | initialConnectAttempts | The number of attempts FireFly will make to connect to the WebSocket when starting up, before failing | int | &lt;nil&gt; | . | path | The WebSocket sever URL to which FireFly should connect | WebSocket URL string | &lt;nil&gt; | . | readBufferSize | The size in bytes of the read buffer for the WebSocket connection | BytesSize | &lt;nil&gt; | . | writeBufferSize | The size in bytes of the write buffer for the WebSocket connection | BytesSize | &lt;nil&gt; | . ",
    "url": "/firefly/head/reference/config.html#tokensws",
    "relUrl": "/reference/config.html#tokensws"
  },"253": {
    "doc": "Configuration Reference",
    "title": "ui",
    "content": "| Key | Description | Type | Default Value | . | enabled | Enables the web user interface | boolean | &lt;nil&gt; | . | path | The file system path which contains the static HTML, CSS, and JavaScript files for the user interface | string | &lt;nil&gt; | . ",
    "url": "/firefly/head/reference/config.html#ui",
    "relUrl": "/reference/config.html#ui"
  },"254": {
    "doc": "ContractAPI",
    "title": "ContractAPI",
    "content": " ",
    "url": "/firefly/head/reference/types/contractapi.html",
    "relUrl": "/reference/types/contractapi.html"
  },"255": {
    "doc": "ContractAPI",
    "title": "Table of contents",
    "content": ". | ContractAPI . | URL | FireFly Interface (FFI) and On-chain Location | OpenAPI V3 / Swagger Definitions | Swagger UI | Example | Field Descriptions | . | FFIReference | ContractURLs | . ",
    "url": "/firefly/head/reference/types/contractapi.html#table-of-contents",
    "relUrl": "/reference/types/contractapi.html#table-of-contents"
  },"256": {
    "doc": "ContractAPI",
    "title": "ContractAPI",
    "content": "Contract APIs provide generated REST APIs for on-chain smart contracts. API endpoints are generated to invoke or perform query operations against each of the functions/methods implemented by the smart contract. API endpoints are also provided to add listeners to the events of that smart contract. Note that once you have established listeners for your blockchain events into FireFly, you need to also subscribe in your application to receive the FireFly events (of type blockchain_event_received) that are emitted for each detected blockchain event. For more information see the Events reference section. URL . The base path for your Contract API is: . | /api/v1/namespaces/{ns}/apis/{apiName} | . For the default namespace, this can be shortened to: . | /api/v1/apis/{apiName} | . FireFly Interface (FFI) and On-chain Location . Contract APIs are registered against: . | A FireFly Interface (FFI) definition, which defines in a blockchain agnostic format the list of functions/events supported by the smart contract. Also detailed type information about the inputs/outputs to those functions/events. | An optional location configured on the Contract API describes where the instance of the smart contract the API should interact with exists in the blockchain layer. For example the address of the Smart Contract for an Ethereum based blockchain, or the name and channel for a Hyperledger Fabric based blockchain. | . If the location is not specified on creation of the Contract API, then it must be specified on each API call made to the Contract API endpoints. OpenAPI V3 / Swagger Definitions . Each Contract API comes with an OpenAPI V3 / Swagger generated definition, which can be downloaded from: . | /api/v1/namespaces/{namespaces}/apis/{apiName}/api/swagger.json | . Swagger UI . A browser / exerciser UI for your API is also available on: . | /api/v1/namespaces/{namespaces}/apis/{apiName}/api | . Example . { \"id\": \"0f12317b-85a0-4a77-a722-857ea2b0a5fa\", \"namespace\": \"ns1\", \"interface\": { \"id\": \"c35d3449-4f24-4676-8e64-91c9e46f06c4\" }, \"location\": { \"address\": \"0x95a6c4895c7806499ba35f75069198f45e88fc69\" }, \"name\": \"my_contract_api\", \"message\": \"b09d9f77-7b16-4760-a8d7-0e3c319b2a16\", \"urls\": { \"openapi\": \"http://127.0.0.1:5000/api/v1/namespaces/default/apis/my_contract_api/api/swagger.json\", \"ui\": \"http://127.0.0.1:5000/api/v1/namespaces/default/apis/my_contract_api/api\" } } . Field Descriptions . | Field Name | Description | Type | . | id | The UUID of the contract API | UUID | . | namespace | The namespace of the contract API | string | . | interface | Reference to the FireFly Interface definition associated with the contract API | FFIReference | . | location | If this API is tied to an individual instance of a smart contract, this field can include a blockchain specific contract identifier. For example an Ethereum contract address, or a Fabric chaincode name and channel | JSONAny | . | name | The name that is used in the URL to access the API | string | . | message | The UUID of the broadcast message that was used to publish this API to the network | UUID | . | urls | The URLs to use to access the API | ContractURLs | . ",
    "url": "/firefly/head/reference/types/contractapi.html",
    "relUrl": "/reference/types/contractapi.html"
  },"257": {
    "doc": "ContractAPI",
    "title": "FFIReference",
    "content": "| Field Name | Description | Type | . | id | The UUID of the FireFly interface | UUID | . | name | The name of the FireFly interface | string | . | version | The version of the FireFly interface | string | . ",
    "url": "/firefly/head/reference/types/contractapi.html#ffireference",
    "relUrl": "/reference/types/contractapi.html#ffireference"
  },"258": {
    "doc": "ContractAPI",
    "title": "ContractURLs",
    "content": "| Field Name | Description | Type | . | openapi | The URL to download the OpenAPI v3 (Swagger) description for the API generated in JSON or YAML format | string | . | ui | The URL to use in a web browser to access the SwaggerUI explorer/exerciser for the API | string | . ",
    "url": "/firefly/head/reference/types/contractapi.html#contracturls",
    "relUrl": "/reference/types/contractapi.html#contracturls"
  },"259": {
    "doc": "ContractListener",
    "title": "ContractListener",
    "content": " ",
    "url": "/firefly/head/reference/types/contractlistener.html",
    "relUrl": "/reference/types/contractlistener.html"
  },"260": {
    "doc": "ContractListener",
    "title": "Table of contents",
    "content": ". | ContractListener . | Example | Field Descriptions | . | FFIReference | FFISerializedEvent | FFIParam | ContractListenerOptions | . ",
    "url": "/firefly/head/reference/types/contractlistener.html#table-of-contents",
    "relUrl": "/reference/types/contractlistener.html#table-of-contents"
  },"261": {
    "doc": "ContractListener",
    "title": "ContractListener",
    "content": "A contract listener configures FireFly to stream events from the blockchain, from a specific location on the blockchain, according to a given definition of the interface for that event. Check out the Custom Contracts Tutorial for a walk-through of how to set up listeners for the events from your smart contracts. Example . { \"id\": \"d61980a9-748c-4c72-baf5-8b485b514d59\", \"interface\": { \"id\": \"ff1da3c1-f9e7-40c2-8d93-abb8855e8a1d\" }, \"namespace\": \"ns1\", \"name\": \"contract1_events\", \"backendId\": \"sb-dd8795fc-a004-4554-669d-c0cf1ee2c279\", \"location\": { \"address\": \"0x596003a91a97757ef1916c8d6c0d42592630d2cf\" }, \"created\": \"2022-05-16T01:23:15Z\", \"event\": { \"name\": \"Changed\", \"description\": \"\", \"params\": [ { \"name\": \"x\", \"schema\": { \"type\": \"integer\", \"details\": { \"type\": \"uint256\", \"internalType\": \"uint256\" } } } ] }, \"signature\": \"Changed(uint256)\", \"topic\": \"app1_topic\", \"options\": { \"firstEvent\": \"newest\" } } . Field Descriptions . | Field Name | Description | Type | . | id | The UUID of the smart contract listener | UUID | . | interface | A reference to an existing FFI, containing pre-registered type information for the event | FFIReference | . | namespace | The namespace of the listener, which defines the namespace of all blockchain events detected by this listener | string | . | name | A descriptive name for the listener | string | . | backendId | An ID assigned by the blockchain connector to this listener | string | . | location | A blockchain specific contract identifier. For example an Ethereum contract address, or a Fabric chaincode name and channel | JSONAny | . | created | The creation time of the listener | FFTime | . | event | The definition of the event, either provided in-line when creating the listener, or extracted from the referenced FFI | FFISerializedEvent | . | signature | The stringified signature of the event, as computed by the blockchain plugin | string | . | topic | A topic to set on the FireFly event that is emitted each time a blockchain event is detected from the blockchain. Setting this topic on a number of listeners allows applications to easily subscribe to all events they need | string | . | options | Options that control how the listener subscribes to events from the underlying blockchain | ContractListenerOptions | . ",
    "url": "/firefly/head/reference/types/contractlistener.html",
    "relUrl": "/reference/types/contractlistener.html"
  },"262": {
    "doc": "ContractListener",
    "title": "FFIReference",
    "content": "| Field Name | Description | Type | . | id | The UUID of the FireFly interface | UUID | . | name | The name of the FireFly interface | string | . | version | The version of the FireFly interface | string | . ",
    "url": "/firefly/head/reference/types/contractlistener.html#ffireference",
    "relUrl": "/reference/types/contractlistener.html#ffireference"
  },"263": {
    "doc": "ContractListener",
    "title": "FFISerializedEvent",
    "content": "| Field Name | Description | Type | . | name | The name of the event | string | . | description | A description of the smart contract event | string | . | params | An array of event parameter/argument definitions | FFIParam[] | . | details | Additional blockchain specific fields about this event from the original smart contract. Used by the blockchain plugin and for documentation generation. | JSONObject | . ",
    "url": "/firefly/head/reference/types/contractlistener.html#ffiserializedevent",
    "relUrl": "/reference/types/contractlistener.html#ffiserializedevent"
  },"264": {
    "doc": "ContractListener",
    "title": "FFIParam",
    "content": "| Field Name | Description | Type | . | name | The name of the parameter. Note that parameters must be ordered correctly on the FFI, according to the order in the blockchain smart contract | string | . | schema | FireFly uses an extended subset of JSON Schema to describe parameters, similar to OpenAPI/Swagger. Converters are available for native blockchain interface definitions / type systems - such as an Ethereum ABI. See the documentation for more detail | JSONAny | . ",
    "url": "/firefly/head/reference/types/contractlistener.html#ffiparam",
    "relUrl": "/reference/types/contractlistener.html#ffiparam"
  },"265": {
    "doc": "ContractListener",
    "title": "ContractListenerOptions",
    "content": "| Field Name | Description | Type | . | firstEvent | A blockchain specific string, such as a block number, to start listening from. The special strings ‘oldest’ and ‘newest’ are supported by all blockchain connectors. Default is ‘newest’ | string | . ",
    "url": "/firefly/head/reference/types/contractlistener.html#contractlisteneroptions",
    "relUrl": "/reference/types/contractlistener.html#contractlisteneroptions"
  },"266": {
    "doc": "Data",
    "title": "Data",
    "content": " ",
    "url": "/firefly/head/reference/types/data.html",
    "relUrl": "/reference/types/data.html"
  },"267": {
    "doc": "Data",
    "title": "Table of contents",
    "content": ". | Data . | Value - JSON data stored in the core database | Datatype - validation of agreed data types | Blob - binary data stored via the Data Exchange | Example | Field Descriptions | . | DatatypeRef | BlobRef | . ",
    "url": "/firefly/head/reference/types/data.html#table-of-contents",
    "relUrl": "/reference/types/data.html#table-of-contents"
  },"268": {
    "doc": "Data",
    "title": "Data",
    "content": "Data is a uniquely identified piece of data available for retrieval or transfer. Multiple data items can be attached to a message when sending data off-chain to another party in a multi-party system. Note that if you pass data in-line when sending a message, those data elements will be stored separately to the message and available to retrieve separately later. An UUID is allocated to each data resource. A hash is also calculated as follows: . | If there is only data, the hash is of the value serialized as JSON with no additional whitespace (order of the keys is retained from the original upload order). | If there is only a blob attachment, the hash is of the blob data. | There is is both a blob and a value, then the hash is a hash of the concatenation of a hash of the value and a hash of the blob. | . Value - JSON data stored in the core database . Each data resource can contain a value, which is any JSON type. String, number, boolean, array or object. This value is stored directly in the FireFly database. If the value you are storing is not JSON data, but is small enough you want it to be stored in the core database, then use a JSON string to store an encoded form of your data (such as XML, CSV etc.). Datatype - validation of agreed data types . A datatype can be associated with your data, causing FireFly to verify the value against a schema before accepting it (on upload, or receipt from another party in the network). These datatypes are pre-established via broadcast messages, and support versioning. Use this system to enforce a set of common data types for exchange of data across your business network, and reduce the overhead of data verification required in the application/integration tier. More information in the Datatype section . Blob - binary data stored via the Data Exchange . Data resources can also contain a blob attachment, which is stored via the Data Exchange plugin outside of the FireFly core database. This is intended for large data payloads, which might be structured or unstructured. PDF documents, multi-MB XML payloads, CSV data exports, JPEG images video files etc. A Data resource can contain both a value JSON payload, and a blob attachment, meaning that you bind a set of metadata to a binary payload. For example a set of extracted metadata from OCR processing of a PDF document. One special case is a filename for a document. This pattern is so common for file/document management scenarios, that special handling is provided for it. If a JSON object is stored in value, and it has a property called name, then this value forms part of the data hash (as does every field in the value) and is stored in a separately indexed blob.name field. The upload REST API provides an autometa form field, which can be set to ask FireFly core to automatically set the value to contain the filename, size, and MIME type from the file upload. Example . { \"id\": \"4f11e022-01f4-4c3f-909f-5226947d9ef0\", \"validator\": \"json\", \"namespace\": \"ns1\", \"hash\": \"5e2758423c99b799f53d3f04f587f5716c1ff19f1d1a050f40e02ea66860b491\", \"created\": \"2022-05-16T01:23:15Z\", \"datatype\": { \"name\": \"widget\", \"version\": \"v1.2.3\" }, \"value\": { \"name\": \"filename.pdf\", \"a\": \"example\", \"b\": { \"c\": 12345 } }, \"blob\": { \"hash\": \"cef238f7b02803a799f040cdabe285ad5cd6db4a15cb9e2a1000f2860884c7ad\", \"size\": 12345, \"name\": \"filename.pdf\" } } . Field Descriptions . | Field Name | Description | Type | . | id | The UUID of the data resource | UUID | . | validator | The data validator type | FFEnum: | . | namespace | The namespace of the data resource | string | . | hash | The hash of the data resource. Derived from the value and the hash of any binary blob attachment | Bytes32 | . | created | The creation time of the data resource | FFTime | . | datatype | The optional datatype to use of validation of this data | DatatypeRef | . | value | The value for the data, stored in the FireFly core database. Can be any JSON type - object, array, string, number or boolean. Can be combined with a binary blob attachment | JSONAny | . | public | If the JSON value has been published to shared storage, this field is the id of the data in the shared storage plugin (IPFS hash etc.) | string | . | blob | An optional hash reference to a binary blob attachment | BlobRef | . ",
    "url": "/firefly/head/reference/types/data.html",
    "relUrl": "/reference/types/data.html"
  },"269": {
    "doc": "Data",
    "title": "DatatypeRef",
    "content": "| Field Name | Description | Type | . | name | The name of the datatype | string | . | version | The version of the datatype. Semantic versioning is encouraged, such as v1.0.1 | string | . ",
    "url": "/firefly/head/reference/types/data.html#datatyperef",
    "relUrl": "/reference/types/data.html#datatyperef"
  },"270": {
    "doc": "Data",
    "title": "BlobRef",
    "content": "| Field Name | Description | Type | . | hash | The hash of the binary blob data | Bytes32 | . | size | The size of the binary data | int64 | . | name | The name field from the metadata attached to the blob, commonly used as a path/filename, and indexed for search | string | . | public | If the blob data has been published to shared storage, this field is the id of the data in the shared storage plugin (IPFS hash etc.) | string | . ",
    "url": "/firefly/head/reference/types/data.html#blobref",
    "relUrl": "/reference/types/data.html#blobref"
  },"271": {
    "doc": "pages.private_data_exchange",
    "title": "Private data exchange",
    "content": " ",
    "url": "/firefly/head/overview/data_exchange.html#private-data-exchange",
    "relUrl": "/overview/data_exchange.html#private-data-exchange"
  },"272": {
    "doc": "pages.private_data_exchange",
    "title": "Table of contents",
    "content": ". | Introduction | Qualities of service | FireFly OSS implementation | . ",
    "url": "/firefly/head/overview/data_exchange.html#table-of-contents",
    "relUrl": "/overview/data_exchange.html#table-of-contents"
  },"273": {
    "doc": "pages.private_data_exchange",
    "title": "Introduction",
    "content": "Private data exchange is the way most enterprise business-to-business communication happens today. One party private sends data to another, over a pipe that has been agreed as sufficiently secure between the two parties. That might be a REST API, SOAP Web Service, FTP / EDI, Message Queue (MQ), or other B2B Gateway technology. The ability to perform these same private data exchanges within a multi-party system is critical. In fact it’s common for the majority of business data continue to transfer over such interfaces. So real-time application to application private messaging, and private transfer of large blobs/documents, are first class constructs in the FireFly API. ",
    "url": "/firefly/head/overview/data_exchange.html#introduction",
    "relUrl": "/overview/data_exchange.html#introduction"
  },"274": {
    "doc": "pages.private_data_exchange",
    "title": "Qualities of service",
    "content": "FireFly recognizes that a multi-party system will need to establish a secure messaging backbone, with the right qualities of service for their requirements. So the implementation is pluggable, and the plugin interface embraces the following quality of service characteristics that differ between different implementations. | Transport Encryption . | Technologies like TLS encrypt data while it is in flight, so that it cannot be sniffed by a third party that has access to the underlying network. | . | Authentication . | There are many technologies including Mutual TLS, and Java Web Tokens (JWT), that can be used to ensure a private data exchange is happening with the correct party in the system. | Most modern approaches use public/private key encryption to establish the identity during the setup phase of a connection. This means a distribution mechanism is required for public keys, which might be enhanced with a trust hierarchy (like PKI). | . | Request/Response (Sync) vs. Message Queuing (Async) . | Synchronous transports like HTTPS require both parties to be available at the time data is sent, and the transmission must be retried at the application (plugin) layer if it fails or times out. | Asynchronous transports like AMQP, MQTT or Kafka introduce one or more broker runtimes between the parties, that reliably buffer the communications if the target application falls behind or is temporarily unavailable. | . | Hub &amp; spoke vs. Peer to peer . | Connectivity might be direct from one party to another within the network, tackling the IT security complexity of firewalls between sensitive networks. Or network shared infrastructure / as-a-service provider might be used to provide a reliable backbone for data exchange between the members. | . | End-to-end Payload Encryption . | Particularly in cases where the networking hops are complex, or involve shared shared/third-party infrastructure, end-to-end encryption can be used to additionally protect the data while in flight. This technology means data remains encrypted from the source to the target, regardless of the number of transport hops taken in-between. | . | Large blob / Managed file transfer . | The optimal approach to transferring real-time small messages (KBs in size) is different to the approach to transferring large blobs (MBs/GBs in size). For large blobs chunking, compression, and checkpoint restart are common for efficient and reliable transfer. | . | . ",
    "url": "/firefly/head/overview/data_exchange.html#qualities-of-service",
    "relUrl": "/overview/data_exchange.html#qualities-of-service"
  },"275": {
    "doc": "pages.private_data_exchange",
    "title": "FireFly OSS implementation",
    "content": "A reference implementation of a private data exchange is provided as part of the FireFly project. This implementation uses peer-to-peer transfer over a synchronous HTTPS transport, backed by Mutual TLS authentication. X509 certificate exchange is orchestrated by FireFly, such that self-signed certificates can be used (or multiple PKI trust roots) and bound to the blockchain-backed identities of the organizations in FireFly. See hyperledger/firefly-dataexchange-https . ",
    "url": "/firefly/head/overview/data_exchange.html#firefly-oss-implementation",
    "relUrl": "/overview/data_exchange.html#firefly-oss-implementation"
  },"276": {
    "doc": "pages.private_data_exchange",
    "title": "pages.private_data_exchange",
    "content": " ",
    "url": "/firefly/head/overview/data_exchange.html",
    "relUrl": "/overview/data_exchange.html"
  },"277": {
    "doc": "DataRef",
    "title": "DataRef",
    "content": " ",
    "url": "/firefly/head/reference/types/dataref.html",
    "relUrl": "/reference/types/dataref.html"
  },"278": {
    "doc": "DataRef",
    "title": "Table of contents",
    "content": ". | DataRef . | Example | Field Descriptions | . | . ",
    "url": "/firefly/head/reference/types/dataref.html#table-of-contents",
    "relUrl": "/reference/types/dataref.html#table-of-contents"
  },"279": {
    "doc": "DataRef",
    "title": "DataRef",
    "content": "Example . { \"id\": \"5bea782a-6cf2-4e01-95ee-cb5fa05873e9\", \"hash\": \"8b7df143d91c716ecfa5fc1730022f6b421b05cedee8fd52b1fc65a96030ad52\" } . Field Descriptions . | Field Name | Description | Type | . | id | The UUID of the referenced data resource | UUID | . | hash | The hash of the referenced data | Bytes32 | . ",
    "url": "/firefly/head/reference/types/dataref.html",
    "relUrl": "/reference/types/dataref.html"
  },"280": {
    "doc": "Datatype",
    "title": "Datatype",
    "content": " ",
    "url": "/firefly/head/reference/types/datatype.html",
    "relUrl": "/reference/types/datatype.html"
  },"281": {
    "doc": "Datatype",
    "title": "Table of contents",
    "content": ". | Datatype . | Example | Field Descriptions | . | . ",
    "url": "/firefly/head/reference/types/datatype.html#table-of-contents",
    "relUrl": "/reference/types/datatype.html#table-of-contents"
  },"282": {
    "doc": "Datatype",
    "title": "Datatype",
    "content": "A datatype defines the format of some data that can be shared between parties, in a way that FireFly can enforce consistency of that data against the schema. Data that does not match the schema associated with it will not be accepted on upload to FireFly, and if this were bypassed by a participant in some way it would be rejected by all parties and result in a message_rejected event (rather than message_confirmed event). Currently JSON Schema validation of data is supported. The system for defining datatypes is pluggable, to support other schemes in the future, such as XML Schema, or CSV, EDI etc. Example . { \"id\": \"3a479f7e-ddda-4bda-aa24-56d06c0bf08e\", \"message\": \"bfcf904c-bdf7-40aa-bbd7-567f625c26c0\", \"validator\": \"json\", \"namespace\": \"ns1\", \"name\": \"widget\", \"version\": \"1.0.0\", \"hash\": \"639cd98c893fa45a9df6fd87bd0393a9b39e31e26fbb1eeefe90cb40c3fa02d2\", \"created\": \"2022-05-16T01:23:16Z\", \"value\": { \"$id\": \"https://example.com/widget.schema.json\", \"$schema\": \"https://json-schema.org/draft/2020-12/schema\", \"title\": \"Widget\", \"type\": \"object\", \"properties\": { \"id\": { \"type\": \"string\", \"description\": \"The unique identifier for the widget.\" }, \"name\": { \"type\": \"string\", \"description\": \"The person's last name.\" } }, \"additionalProperties\": false } } . Field Descriptions . | Field Name | Description | Type | . | id | The UUID of the datatype | UUID | . | message | The UUID of the broadcast message that was used to publish this datatype to the network | UUID | . | validator | The validator that should be used to verify this datatype | FFEnum:\"json\"\"none\"\"definition\" | . | namespace | The namespace of the datatype. Data resources can only be created referencing datatypes in the same namespace | string | . | name | The name of the datatype | string | . | version | The version of the datatype. Multiple versions can exist with the same name. Use of semantic versioning is encourages, such as v1.0.1 | string | . | hash | The hash of the value, such as the JSON schema. Allows all parties to be confident they have the exact same rules for verifying data created against a datatype | Bytes32 | . | created | The time the datatype was created | FFTime | . | value | The definition of the datatype, in the syntax supported by the validator (such as a JSON Schema definition) | JSONAny | . ",
    "url": "/firefly/head/reference/types/datatype.html",
    "relUrl": "/reference/types/datatype.html"
  },"283": {
    "doc": "Define a datatype",
    "title": "Define a datatype",
    "content": " ",
    "url": "/firefly/head/tutorials/define_datatype.html",
    "relUrl": "/tutorials/define_datatype.html"
  },"284": {
    "doc": "Define a datatype",
    "title": "Table of contents",
    "content": ". | Quick reference | Additional info . | Example 1: Broadcast new datatype | . | Example message response | Lookup the confirmed data type | Example private send referring to the datatype | Defining Datatypes using the Sandbox | . ",
    "url": "/firefly/head/tutorials/define_datatype.html#table-of-contents",
    "relUrl": "/tutorials/define_datatype.html#table-of-contents"
  },"285": {
    "doc": "Define a datatype",
    "title": "Quick reference",
    "content": "As your use case matures, it is important to agree formal datatypes between the parties. These canonical datatypes need to be defined and versioned, so that each member can extract and transform data from their internal systems into this datatype. Datatypes are broadcast to the network so everybody refers to the same JSON schema when validating their data. The broadcast must complete before a datatype can be used by an application to upload/broadcast/send data. The same system of broadcast within FireFly is used to broadcast definitions of datatypes, as is used to broadcast the data itself. ",
    "url": "/firefly/head/tutorials/define_datatype.html#quick-reference",
    "relUrl": "/tutorials/define_datatype.html#quick-reference"
  },"286": {
    "doc": "Define a datatype",
    "title": "Additional info",
    "content": ". | Key Concepts: Broadcast / shared data | Swagger: POST /api/v1/namespaces/{ns}/datatypes | . Example 1: Broadcast new datatype . POST /api/v1/namespaces/{ns}/broadcast/datatype . { \"name\": \"widget\", \"version\": \"0.0.2\", \"value\": { \"$id\": \"https://example.com/widget.schema.json\", \"$schema\": \"https://json-schema.org/draft/2020-12/schema\", \"title\": \"Widget\", \"type\": \"object\", \"properties\": { \"id\": { \"type\": \"string\", \"description\": \"The unique identifier for the widget.\" }, \"name\": { \"type\": \"string\", \"description\": \"The person's last name.\" } } } } . ",
    "url": "/firefly/head/tutorials/define_datatype.html#additional-info",
    "relUrl": "/tutorials/define_datatype.html#additional-info"
  },"287": {
    "doc": "Define a datatype",
    "title": "Example message response",
    "content": "Status: 202 Accepted - a broadcast message has been sent, and on confirmation the new datatype will be created (unless it conflicts with another definition with the same name and version that was ordered onto the blockchain before this definition). { \"header\": { \"id\": \"727f7d3a-d07e-4e80-95af-59f8d2ac7531\", // this is the ID of the message, not the data type \"type\": \"definition\", // a special type for system broadcasts \"txtype\": \"batch_pin\", // the broadcast is pinned to the chain \"author\": \"0x0a65365587a65ce44938eab5a765fe8bc6532bdf\", // the local identity \"created\": \"2021-07-01T21:06:26.9997478Z\", // the time the broadcast was sent \"namespace\": \"ff_system\", // the data/message broadcast happens on the system namespace \"topic\": [ \"ff_ns_default\" // the namespace itself is used in the topic ], \"tag\": \"ff_define_datatype\", // a tag instructing FireFly to process this as a datatype definition \"datahash\": \"56bd677e3e070ba62f547237edd7a90df5deaaf1a42e7d6435ec66a587c14370\" }, \"hash\": \"5b6593720243831ba9e4ad002c550e95c63704b2c9dbdf31135d7d9207f8cae8\", \"state\": \"ready\", // this message is stored locally but not yet confirmed \"data\": [ { \"id\": \"7539a0ab-78d8-4d42-b283-7e316b3afed3\", // this data object in the ff_system namespace, contains the schema \"hash\": \"22ba1cdf84f2a4aaffac665c83ff27c5431c0004dc72a9bf031ae35a75ac5aef\" } ] } . ",
    "url": "/firefly/head/tutorials/define_datatype.html#example-message-response",
    "relUrl": "/tutorials/define_datatype.html#example-message-response"
  },"288": {
    "doc": "Define a datatype",
    "title": "Lookup the confirmed data type",
    "content": "GET /api/v1/namespaces/default/datatypes?name=widget&amp;version=0.0.2 . [ { \"id\": \"421c94b1-66ce-4ba0-9794-7e03c63df29d\", // an ID allocated to the datatype \"message\": \"727f7d3a-d07e-4e80-95af-59f8d2ac7531\", // the message that broadcast this data type \"validator\": \"json\", // the type of validator that this datatype can be used for (this one is JSON Schema) \"namespace\": \"default\", // the namespace of the datatype \"name\": \"widget\", // the name of the datatype \"version\": \"0.0.2\", // the version of the data type \"hash\": \"a4dceb79a21937ca5ea9fa22419011ca937b4b8bc563d690cea3114af9abce2c\", // hash of the schema itself \"created\": \"2021-07-01T21:06:26.983986Z\", // time it was confirmed \"value\": { // the JSON schema itself \"$id\": \"https://example.com/widget.schema.json\", \"$schema\": \"https://json-schema.org/draft/2020-12/schema\", \"title\": \"Widget\", \"type\": \"object\", \"properties\": { \"id\": { \"type\": \"string\", \"description\": \"The unique identifier for the widget.\" }, \"name\": { \"type\": \"string\", \"description\": \"The person's last name.\" } } } } ] . ",
    "url": "/firefly/head/tutorials/define_datatype.html#lookup-the-confirmed-data-type",
    "relUrl": "/tutorials/define_datatype.html#lookup-the-confirmed-data-type"
  },"289": {
    "doc": "Define a datatype",
    "title": "Example private send referring to the datatype",
    "content": "Once confirmed, a piece of data can be assigned that datatype and all FireFly nodes will verify it against the schema. On a sending node, the data will be rejected at upload/send time if it does not conform. On other nodes, bad data results in a message_rejected event (rather than message_confirmed) for any message that arrives referring to that data. POST /api/v1/namespaces/default/send/message . { \"header\": { \"tag\": \"new_widget_created\", \"topic\": [\"widget_id_12345\"] }, \"group\": { \"members\": [ { \"identity\": \"org_1\" } ] }, \"data\": [ { \"datatype\": { \"name\": \"widget\", \"version\": \"0.0.2\" }, \"value\": { \"id\": \"widget_id_12345\", \"name\": \"superwidget\" } } ] } . ",
    "url": "/firefly/head/tutorials/define_datatype.html#example-private-send-referring-to-the-datatype",
    "relUrl": "/tutorials/define_datatype.html#example-private-send-referring-to-the-datatype"
  },"290": {
    "doc": "Define a datatype",
    "title": "Defining Datatypes using the Sandbox",
    "content": "You can also define a datatype through the FireFly Sandbox. To get started, open up the Web UI and Sanbox UI for at least one of your members. The URLs for these were printed in your terminal when you started your FireFly stack. In the sandbox, enter the datatype’s name, version, and JSON Schema as seen in the screenshot below. { \"name\": \"widget\", \"version\": \"0.0.2\", \"value\": { \"$id\": \"https://example.com/widget.schema.json\", \"$schema\": \"https://json-schema.org/draft/2020-12/schema\", \"title\": \"Widget\", \"type\": \"object\", \"properties\": { \"id\": { \"type\": \"string\", \"description\": \"The unique identifier for the widget.\" }, \"name\": { \"type\": \"string\", \"description\": \"The person's last name.\" } } } } . Notice how the data field in the center panel updates in real time. Click the blue Run button. This should return a 202 response immediately in the Server Response section and will populate the right hand panel with transaction information after a few seconds. Go back to the FireFly UI (the URL for this would have been shown in the terminal when you started the stack) and you’ll see that you’ve successfully defined your datatype . ",
    "url": "/firefly/head/tutorials/define_datatype.html#defining-datatypes-using-the-sandbox",
    "relUrl": "/tutorials/define_datatype.html#defining-datatypes-using-the-sandbox"
  },"291": {
    "doc": "Deterministic compute",
    "title": "Deterministic compute",
    "content": " ",
    "url": "/firefly/head/overview/deterministic_compute.html",
    "relUrl": "/overview/deterministic_compute.html"
  },"292": {
    "doc": "Deterministic compute",
    "title": "Table of contents",
    "content": ". | Introduction | The fundamental building blocks | Advanced Cryptography and Privacy Preserving Trusted Compute | Complementary approaches to deterministic computation | . ",
    "url": "/firefly/head/overview/deterministic_compute.html#table-of-contents",
    "relUrl": "/overview/deterministic_compute.html#table-of-contents"
  },"293": {
    "doc": "Deterministic compute",
    "title": "Introduction",
    "content": "A critical aspect of designing a multi-party systems, is choosing where you exploit the blockchain and other advanced cryptography technology to automate agreement between parties. Specifically where you rely on the computation itself to come up with a result that all parties can independently trust. For example because all parties performed the same computation independently and came up with the same result, against the same data, and agreed to that result using a consensus algorithm. The more sophisticated the agreement is you want to prove, the more consideration needs to be taken into factors such as: . | Data privacy | Data deletion | Ease of understanding by business users | Ease of audit | Autonomy of parties with proprietary business logic | Human workflows (obviously non-deterministic) | Technology complexity/maturity (particularly for privacy preserving technologies) | Cost and skills for implementation | . FireFly embraces the fact that different use cases, will make different decisions on how much of the agreement should be enforced through deterministic compute. Also that multi-party systems include a mixture of approaches in addition to deterministic compute, including traditional off-chain secure HTTP/Messaging, documents, private non-deterministic logic, and human workflows. ",
    "url": "/firefly/head/overview/deterministic_compute.html#introduction",
    "relUrl": "/overview/deterministic_compute.html#introduction"
  },"294": {
    "doc": "Deterministic compute",
    "title": "The fundamental building blocks",
    "content": "There are some fundamental types of deterministic computation, that can be proved with mature blockchain technology, and all multi-party systems should consider exploiting: . | Total conservation of value . | Allows you to assign value to something, because you know it is a fraction of a total pool | This is the magic behind fungible tokens, or “coins” | The proven technology for this is a shared ledger of all previous transactions | Learn more in the Tokens section | . | Existence and ownership of a unique identifiable thing . | Gives you an anchor to attach to something in the real world | This is the magic behind non-fungible tokens (NTFs) | The proven technology for this is a shared ledger of its creation, and ownership changes | Learn more in the Tokens section | . | An agreed sequence of events . | The foundation tool that allows the building of higher level constructs (including tokens) | Not previously available when business ecosystems used HTTP/Messaging transports alone | Can be bi-lateral, multi-lateral or global | Each blockchain technology has different features to establish these “chains” of information | Different approaches provide privacy different levels of privacy on the parties and sequence | . | Identification of data by a “hash” of its contents . | The glue that binds a piece of private data, to a proof that you have a copy of that data | This is the basis of “pinning” data to the blockchain, without sharing its contents | Care needs to be taken to make sure the data is unique enough to make the hash secure | Learn more in the On-chain/off-chain coordination section | . | . ",
    "url": "/firefly/head/overview/deterministic_compute.html#the-fundamental-building-blocks",
    "relUrl": "/overview/deterministic_compute.html#the-fundamental-building-blocks"
  },"295": {
    "doc": "Deterministic compute",
    "title": "Advanced Cryptography and Privacy Preserving Trusted Compute",
    "content": "There are use cases where a deterministic agreement on computation is desired, but the data upon which the execution is performed cannot be shared between all the parties. For example proving total conservation of value in a token trading scenario, without knowing who is involved in the individual transactions. Or providing you have access to a piece of data, without disclosing what that data is. Technologies exist that can solve these requirements, with two major categories: . | Zero Knowledge Proofs (ZKPs) . | Advanced cryptography techniques that allow one party to generate a proof that can be be verified by another party, without access to the data used to generate the proof. | . | Trusted Compute Environments (TEEs) . | Secure compute environments that provide proofs of what code was executed, such that other parties can be confident of the logic that was executed without having access to the data. | . | . FireFly today provides an orchestration engine that’s helpful in coordinating the inputs, outputs, and execution of such advanced cryptography technologies. Active collaboration between the FireFly and other projects like Hyperledger Avalon, and Hyperledger Cactus, is evolving how these technologies can plug-in with higher level patterns. ",
    "url": "/firefly/head/overview/deterministic_compute.html#advanced-cryptography-and-privacy-preserving-trusted-compute",
    "relUrl": "/overview/deterministic_compute.html#advanced-cryptography-and-privacy-preserving-trusted-compute"
  },"296": {
    "doc": "Deterministic compute",
    "title": "Complementary approaches to deterministic computation",
    "content": "Enterprise multi-party systems usually operate differently to end-user decentralized applications. In particular, strong identity is established for the organizations that are involved, and those organizations usually sign legally binding commitments around their participation in the network. Those businesses then bring on-board an ecosystem of employees and or customers that are end-users to the system. So the shared source of truth empowered by the blockchain and other cryptography are not the only tools that can be used in the toolbox to ensure correct behavior. Regognizing that there are real legal entities involved, that are mature and regulated, does not undermine the value of the blockchain components. In fact it enhances it. A multi-party system can use just enough of this secret sauce in the right places, to change the dynamics of trust such that competitors in a market are willing to create value together that could never be created before. Or create a system where parties can share data with each other while still conforming to their own regulatory and audit commitments, that previously would have been impossible to share. Not to be overlooked is the sometimes astonishing efficiency increase that can be added to existing business relationships, by being able to agree the order and sequence of a set of events. Having the tools to digitize processes that previously took physical documents flying round the world, into near-immediate digital agreement where the arbitration of a dispute can be resolved at a tiny fraction of what would have been possible without a shared and immutable audit trail of who said what when. ",
    "url": "/firefly/head/overview/deterministic_compute.html#complementary-approaches-to-deterministic-computation",
    "relUrl": "/overview/deterministic_compute.html#complementary-approaches-to-deterministic-computation"
  },"297": {
    "doc": "Setting up a FireFly Core Development Environment",
    "title": "Setting up a FireFly Core Development Environment",
    "content": " ",
    "url": "/firefly/head/contributors/dev_environment_setup.html",
    "relUrl": "/contributors/dev_environment_setup.html"
  },"298": {
    "doc": "Setting up a FireFly Core Development Environment",
    "title": "Table of contents",
    "content": ". | Setting up a FireFly Core Development Environment . | Dependencies . | Install the FireFly CLI | Installing Go and setting up your GOPATH | . | Building FireFly | Install the CLI | Set up a development stack . | Start the stack | 1) From another terminal | 2) Using an IDE | . | Set up dev environment for other components | . | . This guide will walk you through setting up your machine for contributing to FireFly, specifically the FireFly core. ",
    "url": "/firefly/head/contributors/dev_environment_setup.html#table-of-contents",
    "relUrl": "/contributors/dev_environment_setup.html#table-of-contents"
  },"299": {
    "doc": "Setting up a FireFly Core Development Environment",
    "title": "Dependencies",
    "content": "You will need a few prerequisites set up on your machine before you can build FireFly from source. We recommend doing development on macOS, Linux, or WSL 2.0. | Go (1.17 or newer) | make | GCC | openssl | . Install the FireFly CLI . The first step to setting up a local development environment is to install the FireFly CLI. Please section of the Getting Started Guide to install The FireFly CLI. Installing Go and setting up your GOPATH . We recommend following the instructions on golang.org to install Go, rather than installing Go from another package magager such as brew. Although it is possible to install Go any way you’d like, setting up your GOPATH may differ from the following instructions. After installing Go, you will need to add a few environment variables to your shell run commands file. This is usually a hidden file in your home directory called .bashrc or .zshrc, depending on which shell you’re using. Add the following lines to your .bashrc or .zshrc file: . export GOPATH=$HOME/go export GOROOT=\"/usr/local/go\" export PATH=\"$PATH:${GOPATH}/bin:${GOROOT}/bin\" . ",
    "url": "/firefly/head/contributors/dev_environment_setup.html#dependencies",
    "relUrl": "/contributors/dev_environment_setup.html#dependencies"
  },"300": {
    "doc": "Setting up a FireFly Core Development Environment",
    "title": "Building FireFly",
    "content": "After installing dependencies, building FireFly from source is very easy. Just clone the repo: . git clone git@github.com:hyperledger/firefly.git &amp;&amp; cd firefly . And run the Makefile to run tests, and compile the app . make . If you want to install the binary on your path (assuming your Go Home is already on your path), from inside the project directory you can simply run: . go install . ",
    "url": "/firefly/head/contributors/dev_environment_setup.html#building-firefly",
    "relUrl": "/contributors/dev_environment_setup.html#building-firefly"
  },"301": {
    "doc": "Setting up a FireFly Core Development Environment",
    "title": "Install the CLI",
    "content": "Please check the CLI Installation instructions for the best way to install the CLI on your machine: https://github.com/hyperledger/firefly-cli#install-the-cli . ",
    "url": "/firefly/head/contributors/dev_environment_setup.html#install-the-cli",
    "relUrl": "/contributors/dev_environment_setup.html#install-the-cli"
  },"302": {
    "doc": "Setting up a FireFly Core Development Environment",
    "title": "Set up a development stack",
    "content": "Now that you have both FireFly and the FireFly CLI installed, it’s time to create a development stack. The CLI can be used to create a docker-compose environment that runs the entirety of a FireFly network. This will include several different processes for each member of the network. This is very useful for people that want to build apps that use FireFly’s API. It can also be useful if you want to make changes to FireFly itself, however we need to set up the stack slightly differently in that case. Essentially what we are going to do is have docker-compose run everything in the FireFly network except one FireFly core process. We’ll run this FireFly core process on our host machine, and configure it to connect to the rest of the microservices running in docker-compose. This means we could launch FireFly from Visual Studio Code or some other IDE and use a debugger to see what’s going on inside FireFly as it’s running. We’ll call this stack dev. We’re also going to add --external 1 to the end of our command to create the new stack: . ff init dev --external 1 . This tells the CLI that we want to manage one of the FireFly core processes outside the docker-compose stack. For convenience, the CLI will still generate a config file for this process though. Start the stack . To start your new stack simply run: . ff start dev . At a certain point in the startup process, the CLI will pause and wait for up to two minutes for you to start the other FireFly node. There are two different ways you can run the external FireFly core process. 1) From another terminal . The CLI will print out the command line which can be copied and pasted into another terminal window to run FireFly. This command should be run from the firefly core project directory. Here is an example of the command that the CLI will tell you to run: . firefly -f ~/.firefly/stacks/dev/runtime/config/firefly_core_0.yml . NOTE: The first time you run FireFly with a fresh database, it will need a directory of database migrations to apply to the empty database. If you run FireFly from the firefly project directory you cloned from GitHub, it will automatically find these and apply them. If you run it from some other directory, you will have to point FireFly to the migrations on your own. 2) Using an IDE . If you named your stack dev there is a launch.json file for Visual Studio code already in the project directory. If you have the project open in Visual Studio Code, you can either press the F5 key to run it, or go to the “Run and Debug” view in Visual Studio code, and click “Run FireFly Core”. Now you should have a full FireFly stack up and running, and be able to debug FireFly using your IDE. Happy hacking! . NOTE: Because firefly-ui is a separate repo, unless you also start a UI dev server for the external FireFly core, the default UI path will not load. This is expected, and if you’re just working on FireFly core itself, you don’t need to worry about it.` . ",
    "url": "/firefly/head/contributors/dev_environment_setup.html#set-up-a-development-stack",
    "relUrl": "/contributors/dev_environment_setup.html#set-up-a-development-stack"
  },"303": {
    "doc": "Setting up a FireFly Core Development Environment",
    "title": "Set up dev environment for other components",
    "content": "Refer to Advanced CLI Usage. ",
    "url": "/firefly/head/contributors/dev_environment_setup.html#set-up-dev-environment-for-other-components",
    "relUrl": "/contributors/dev_environment_setup.html#set-up-dev-environment-for-other-components"
  },"304": {
    "doc": "Contributing to Documentation",
    "title": "Contributing to Documentation",
    "content": " ",
    "url": "/firefly/head/contributors/docs_setup.html",
    "relUrl": "/contributors/docs_setup.html"
  },"305": {
    "doc": "Contributing to Documentation",
    "title": "Table of contents",
    "content": ". | Contributing to Documentation . | Process for updating documentation | Dependencies . | macOS | Linux | . | Build and serve the docs locally | . | . This guide will walk you through setting up your machine for contributing to FireFly documentation. Documentation contributions are extremely valuable. If you discover something is missing in the docs, we would love to include your additions or clarifications to help the next person who has the same question. This doc site is generated by a set of Markdown files in the main FireFly repository, under the ./docs directory. You can browse the source for the current live site in GitHub here: https://github.com/hyperledger/firefly/tree/main/docs . ",
    "url": "/firefly/head/contributors/docs_setup.html#table-of-contents",
    "relUrl": "/contributors/docs_setup.html#table-of-contents"
  },"306": {
    "doc": "Contributing to Documentation",
    "title": "Process for updating documentation",
    "content": "The process for updating the documentation is really easy! You’ll follow the same basic steps outlined in the same steps outlined in the Contributor’s guide. Here are the detailed steps for contributing to the docs: . | Fork https://github.com/hyperledger/firefly | Clone your fork locally to your computer | Follow the steps below to view your local copy of the docs in a browser | Make some improvements to the Markdown files | Verify that your changes look they way you want them to in your browser | Create a new git commit with your changes. Be sure to sign-off on your commit by using git commit -s! | Push your changes | Open a Pull Request to incorporate your changes back into the hyperledger/firefly repo | . ",
    "url": "/firefly/head/contributors/docs_setup.html#process-for-updating-documentation",
    "relUrl": "/contributors/docs_setup.html#process-for-updating-documentation"
  },"307": {
    "doc": "Contributing to Documentation",
    "title": "Dependencies",
    "content": "The FireFly docs site uses GitHub pages, which uses a tool called Jekyll to convert Markdown files into HTML files that can be read in your browser. Basically that means in order to build and view the pages locally on your machine, you need to have Jekyll. Jekyll is a Ruby app, so you’ll also need to have Ruby, and the Ruby bundler app to install Jekyll’s dependencies. The good news is these things are very easy to set up. macOS . If you’re using an Intel Mac, you are already good to go! macOS already comes with ruby and bundle installed and set up already. You don’t need to do anything extra. However, it may be advisable to install a newer version of Ruby anyway. NOTE: From the macOS Catalina 10.15 Release Notes: Scripting language runtimes such as Python, Ruby, and Perl are included in macOS for compatibility with legacy software. Future versions of macOS won’t include scripting language runtimes by default, and might require you to install additional packages. If your software depends on scripting languages, it’s recommended that you bundle the runtime within the app. (49764202) . If you’re using an Apple Silicon based Mac, the version of Ruby that comes with macOS supports both Intel and ARM binaries which unfortunately ends up causing some problems when installing certain gems. We recommend installing Ruby with brew and setting it on your path. This will also give you a newer version of Ruby. To do this, run: . brew install ruby echo 'export PATH=\"/opt/homebrew/opt/ruby/bin:$PATH\"' &gt;&gt; ~/.zshrc . Linux . You will need to install ruby and bundle and have them on your path to build and serve the docs locally. On Ubuntu, to install these, run the following commands: . sudo apt-get update sudo apt-get install ruby ruby-bundler . ",
    "url": "/firefly/head/contributors/docs_setup.html#dependencies",
    "relUrl": "/contributors/docs_setup.html#dependencies"
  },"308": {
    "doc": "Contributing to Documentation",
    "title": "Build and serve the docs locally",
    "content": "To build and serve the docs locally, from the project root, navigate to the docs directory: . cd docs . Install docs dependencies: . bundle install . And start the Jekyll test server: . bundle exec jekyll serve --livereload . You should now be able to open http://127.0.0.1:4000/firefly/index.html in your browser and see a locally hosted version of the doc site. As you make changes to files in the ./docs directory, Jekyll will automatically rebuild the pages, and notify you of any errors or warnings in your terminal. If you have a browser open, it will automatically reload when changes are made to pages. ",
    "url": "/firefly/head/contributors/docs_setup.html#build-and-serve-the-docs-locally",
    "relUrl": "/contributors/docs_setup.html#build-and-serve-the-docs-locally"
  },"309": {
    "doc": "ERC-1155",
    "title": "Use ERC-1155 tokens",
    "content": " ",
    "url": "/firefly/head/tutorials/tokens/erc1155.html#use-erc-1155-tokens",
    "relUrl": "/tutorials/tokens/erc1155.html#use-erc-1155-tokens"
  },"310": {
    "doc": "ERC-1155",
    "title": "Table of contents",
    "content": ". | Previous steps: Install the FireFly CLI | Create a stack with an ERC-1155 connector | Use the Sandbox (optional) | Create a pool | Mint tokens | Transfer tokens | Sending data with a transfer . | Broadcast message | Private message | . | Burn tokens | Token approvals . | Request | Response | . | . ",
    "url": "/firefly/head/tutorials/tokens/erc1155.html#table-of-contents",
    "relUrl": "/tutorials/tokens/erc1155.html#table-of-contents"
  },"311": {
    "doc": "ERC-1155",
    "title": "Previous steps: Install the FireFly CLI",
    "content": "If you haven’t set up the FireFly CLI already, please go back to the Getting Started guide and read the section on how to Install the FireFly CLI. ← ① Install the FireFly CLI . ",
    "url": "/firefly/head/tutorials/tokens/erc1155.html#previous-steps-install-the-firefly-cli",
    "relUrl": "/tutorials/tokens/erc1155.html#previous-steps-install-the-firefly-cli"
  },"312": {
    "doc": "ERC-1155",
    "title": "Create a stack with an ERC-1155 connector",
    "content": "The default Token Connector that the FireFly CLI sets up is for ERC-20 and ERC-721. If you would like to work with ERC-1155 tokens, you need to create a stack that is configured to use that Token Connector. To do that, run: . ff init -t erc-1155 . Then run: . ff start &lt;your_stack_name&gt; . ",
    "url": "/firefly/head/tutorials/tokens/erc1155.html#create-a-stack-with-an-erc-1155-connector",
    "relUrl": "/tutorials/tokens/erc1155.html#create-a-stack-with-an-erc-1155-connector"
  },"313": {
    "doc": "ERC-1155",
    "title": "Use the Sandbox (optional)",
    "content": "At this point you could open the Sandbox to http://localhost:3000/home?action=tokens.pools and perform the functions outlined in the rest of this guide. Or you can keep reading to learn how to build HTTP requests to work with tokens in FireFly. ",
    "url": "/firefly/head/tutorials/tokens/erc1155.html#use-the-sandbox-optional",
    "relUrl": "/tutorials/tokens/erc1155.html#use-the-sandbox-optional"
  },"314": {
    "doc": "ERC-1155",
    "title": "Create a pool",
    "content": "After you stack is up and running, the first thing you need to do is create a Token Pool. Every application will need at least one Token Pool. At a minimum, you must always specify a name and type (fungible or nonfungible) for the pool. POST http://127.0.0.1:5000/api/v1/namespaces/default/tokens/pools . { \"name\": \"testpool\", \"type\": \"fungible\" } . Other parameters: . | You must specify a connector if you have configured multiple token connectors | You may pass through a config object of additional parameters, if supported by your token connector | You may specify a key understood by the connector (i.e. an Ethereum address) if you’d like to use a non-default signing identity | . ",
    "url": "/firefly/head/tutorials/tokens/erc1155.html#create-a-pool",
    "relUrl": "/tutorials/tokens/erc1155.html#create-a-pool"
  },"315": {
    "doc": "ERC-1155",
    "title": "Mint tokens",
    "content": "Once you have a token pool, you can mint tokens within it. With the default firefly-tokens-erc1155 connector, only the creator of a pool is allowed to mint - but each connector may define its own permission model. POST http://127.0.0.1:5000/api/v1/namespaces/default/tokens/mint . { \"amount\": 10 } . Other parameters: . | You must specify a pool name if you’ve created more than one pool | You may specify a key understood by the connector (i.e. an Ethereum address) if you’d like to use a non-default signing identity | You may specify to if you’d like to send the minted tokens to a specific identity (default is the same as key) | . ",
    "url": "/firefly/head/tutorials/tokens/erc1155.html#mint-tokens",
    "relUrl": "/tutorials/tokens/erc1155.html#mint-tokens"
  },"316": {
    "doc": "ERC-1155",
    "title": "Transfer tokens",
    "content": "You may transfer tokens within a pool by specifying an amount and a destination understood by the connector (i.e. an Ethereum address). With the default firefly-tokens-erc1155 connector, only the owner of a token may transfer it away - but each connector may define its own permission model. POST http://127.0.0.1:5000/api/v1/namespaces/default/tokens/transfers . { \"amount\": 1, \"to\": \"0x07eab7731db665caf02bc92c286f51dea81f923f\" } . NOTE: When transferring a non-fungible token, the amount must always be 1. The tokenIndex field is also required when transferring a non-fungible token. Other parameters: . | You must specify a pool name if you’ve created more than one pool | You may specify a key understood by the connector (i.e. an Ethereum address) if you’d like to use a non-default signing identity | You may specify from if you’d like to send tokens from a specific identity (default is the same as key) | . ",
    "url": "/firefly/head/tutorials/tokens/erc1155.html#transfer-tokens",
    "relUrl": "/tutorials/tokens/erc1155.html#transfer-tokens"
  },"317": {
    "doc": "ERC-1155",
    "title": "Sending data with a transfer",
    "content": "All transfers (as well as mint/burn operations) support an optional message parameter that contains a broadcast or private message to be sent along with the transfer. This message follows the same convention as other FireFly messages, and may be comprised of text or blob data, and can provide context, metadata, or other supporting information about the transfer. The message will be batched, hashed, and pinned to the primary blockchain. The message ID and hash will also be sent to the token connector as part of the transfer operation, to be written to the token blockchain when the transaction is submitted. All recipients of the message will then be able to correlate the message with the token transfer. POST http://127.0.0.1:5000/api/v1/namespaces/default/tokens/transfers . Broadcast message . { \"amount\": 1, \"to\": \"0x07eab7731db665caf02bc92c286f51dea81f923f\", \"message\": { \"data\": [{ \"value\": \"payment for goods\" }] } } . Private message . { \"amount\": 1, \"to\": \"0x07eab7731db665caf02bc92c286f51dea81f923f\", \"message\": { \"header\": { \"type\": \"transfer_private\", }, \"group\": { \"members\": [{ \"identity\": \"org_1\" }] }, \"data\": [{ \"value\": \"payment for goods\" }] } } . Note that all parties in the network will be able to see the transfer (including the message ID and hash), but only the recipients of the message will be able to view the actual message data. ",
    "url": "/firefly/head/tutorials/tokens/erc1155.html#sending-data-with-a-transfer",
    "relUrl": "/tutorials/tokens/erc1155.html#sending-data-with-a-transfer"
  },"318": {
    "doc": "ERC-1155",
    "title": "Burn tokens",
    "content": "You may burn tokens by simply specifying an amount. With the default firefly-tokens-erc1155 connector, only the owner of a token may burn it - but each connector may define its own permission model. POST http://127.0.0.1:5000/api/v1/namespaces/default/tokens/burn . { \"amount\": 1, } . NOTE: When burning a non-fungible token, the amount must always be 1. The tokenIndex field is also required when burning a non-fungible token. Other parameters: . | You must specify a pool name if you’ve created more than one pool | You may specify a key understood by the connector (i.e. an Ethereum address) if you’d like to use a non-default signing identity | You may specify from if you’d like to burn tokens from a specific identity (default is the same as key) | . ",
    "url": "/firefly/head/tutorials/tokens/erc1155.html#burn-tokens",
    "relUrl": "/tutorials/tokens/erc1155.html#burn-tokens"
  },"319": {
    "doc": "ERC-1155",
    "title": "Token approvals",
    "content": "You can also approve other wallets to transfer tokens on your behalf with the /approvals API. The important fields in a token approval API request are as follows: . | approved: Sets whether another account is allowed to transfer tokens out of this wallet or not. If not specified, will default to true. Setting to false can revoke an existing approval. | operator: The other account that is allowed to transfer tokens out of the wallet specified in the key field | key: The wallet address for the approval. If not set, it defaults to the address of the FireFly node submitting the transaction | . Here is an example request that would let the signing account 0x634ee8c7d0894d086c7af1fc8514736aed251528 transfer any amount of tokens from my wallet . Request . POST http://127.0.0.1:5000/api/v1/namespaces/default/tokens/approvals . { \"operator\": \"0x634ee8c7d0894d086c7af1fc8514736aed251528\" } . Response . { \"localId\": \"46fef50a-cf93-4f92-acf8-fae161b37362\", \"pool\": \"e1477ed5-7282-48e5-ad9d-1612296bb29d\", \"connector\": \"erc1155\", \"key\": \"0x14ddd36a0c2f747130915bf5214061b1e4bec74c\", \"operator\": \"0x634ee8c7d0894d086c7af1fc8514736aed251528\", \"approved\": true, \"tx\": { \"type\": \"token_approval\", \"id\": \"00faa011-f42c-403d-a047-2df7318967cd\" } } . ",
    "url": "/firefly/head/tutorials/tokens/erc1155.html#token-approvals",
    "relUrl": "/tutorials/tokens/erc1155.html#token-approvals"
  },"320": {
    "doc": "ERC-1155",
    "title": "ERC-1155",
    "content": " ",
    "url": "/firefly/head/tutorials/tokens/erc1155.html",
    "relUrl": "/tutorials/tokens/erc1155.html"
  },"321": {
    "doc": "ERC-20",
    "title": "Use ERC-20 tokens",
    "content": " ",
    "url": "/firefly/head/tutorials/tokens/erc20.html#use-erc-20-tokens",
    "relUrl": "/tutorials/tokens/erc20.html#use-erc-20-tokens"
  },"322": {
    "doc": "ERC-20",
    "title": "Table of contents",
    "content": ". | Previous steps: Start your environment | Use the built in sample token factory | Use the Sandbox (optional) | Create a pool . | Request | Response | Get the address of the deployed contract . | Request | Response | . | Create a pool for an existing contract | . | Mint tokens . | Request | Response | . | Transfer tokens . | Request | Response | . | Sending data with a transfer . | Broadcast message | Private message | . | Burn tokens | Token approvals . | Request | Response | . | Use Metamask . | Configure a new network | Import tokens | Transfer tokens | . | . ",
    "url": "/firefly/head/tutorials/tokens/erc20.html#table-of-contents",
    "relUrl": "/tutorials/tokens/erc20.html#table-of-contents"
  },"323": {
    "doc": "ERC-20",
    "title": "Previous steps: Start your environment",
    "content": "If you haven’t started a FireFly stack already, please go to the Getting Started guide on how to Start your environment. This will set up a token connector that works with both ERC-20 and ERC-721 by default. ← ② Start your environment . ",
    "url": "/firefly/head/tutorials/tokens/erc20.html#previous-steps-start-your-environment",
    "relUrl": "/tutorials/tokens/erc20.html#previous-steps-start-your-environment"
  },"324": {
    "doc": "ERC-20",
    "title": "Use the built in sample token factory",
    "content": "If you are using the default ERC-20 / ERC-721 token connector, when the FireFly CLI set up your FireFly stack, it also deployed a token factory contract. When you create a token pool through FireFly’s token APIs, the token factory contract will automatically deploy an ERC-20 or ERC-721 contract, based on the pool type in the API request. ⚠️ WARNING: The default token contract that was deployed by the FireFly CLI is only provided for the purpose of learning about FireFly. It is not a production grade contract. If you intend to deploy a production application using tokens FireFly you should research token contract best practices. For details, please see the source code for the contract that was deployed. ",
    "url": "/firefly/head/tutorials/tokens/erc20.html#use-the-built-in-sample-token-factory",
    "relUrl": "/tutorials/tokens/erc20.html#use-the-built-in-sample-token-factory"
  },"325": {
    "doc": "ERC-20",
    "title": "Use the Sandbox (optional)",
    "content": "At this point you could open the Sandbox at http://127.0.0.1:5109/home?action=tokens.pools and perform the functions outlined in the rest of this guide. Or you can keep reading to learn how to build HTTP requests to work with tokens in FireFly. ",
    "url": "/firefly/head/tutorials/tokens/erc20.html#use-the-sandbox-optional",
    "relUrl": "/tutorials/tokens/erc20.html#use-the-sandbox-optional"
  },"326": {
    "doc": "ERC-20",
    "title": "Create a pool",
    "content": "After your stack is up and running, the first thing you need to do is create a Token Pool. Every application will need at least one Token Pool. At a minimum, you must always specify a name and type for the pool. If you’re using the default ERC-20 / ERC-721 token connector and its sample token factory, it will automatically deploy a new token contract, based on the type in the request to create the token pool. Request . POST http://127.0.0.1:5000/api/v1/namespaces/default/tokens/pools . { \"name\": \"testpool\", \"type\": \"fungible\" } . Response . { \"id\": \"e1477ed5-7282-48e5-ad9d-1612296bb29d\", \"type\": \"fungible\", \"namespace\": \"default\", \"name\": \"testpool\", \"key\": \"0x14ddd36a0c2f747130915bf5214061b1e4bec74c\", \"connector\": \"erc20_erc721\", \"tx\": { \"type\": \"token_pool\", \"id\": \"e901921e-ffc4-4776-b20a-9e9face70a47\" } } . Other parameters: . | You must specify a connector if you have configured multiple token connectors | You may pass through a config object of additional parameters, if supported by your token connector | You may specify a key understood by the connector (i.e. an Ethereum address) if you’d like to use a non-default signing identity | . Get the address of the deployed contract . To lookup the address of the new contract, you can lookup the Token Pool by its ID on the API. Creating the token pool will also emit an event which will contain the address. To query the token pool you can make a GET request to the pool’s ID: . Request . GET http://127.0.0.1:5000/api/v1/namespaces/default/tokens/pools/5811e8d5-52d0-44b1-8b75-73f5ff88f598 . Response . { \"id\": \"e1477ed5-7282-48e5-ad9d-1612296bb29d\", \"type\": \"fungible\", \"namespace\": \"default\", \"name\": \"testpool\", \"standard\": \"ERC20\", \"locator\": \"address=0xc4d02efcfab06f18ec0a68e00b98ffecf6bf7e3c&amp;schema=ERC20WithData&amp;type=fungible\", \"decimals\": 18, \"connector\": \"erc20_erc721\", \"message\": \"7e2f6004-31fd-4ba8-9845-15c5fe5fbcd7\", \"state\": \"confirmed\", \"created\": \"2022-04-28T14:03:16.732222381Z\", \"info\": { \"address\": \"0xc4d02efcfab06f18ec0a68e00b98ffecf6bf7e3c\", \"name\": \"testpool\", \"schema\": \"ERC20WithData\" }, \"tx\": { \"type\": \"token_pool\", \"id\": \"e901921e-ffc4-4776-b20a-9e9face70a47\" } } . Create a pool for an existing contract . If you wish to use a contract that is already on the chain, you can pass the address in a config object with an address when you make the request to create the Token Pool. POST http://127.0.0.1:5000/api/v1/namespaces/default/tokens/pools . { \"name\": \"testpool\", \"type\": \"fungible\", \"config\": { \"address\": \"0xb1C845D32966c79E23f733742Ed7fCe4B41901FC\" } } . ",
    "url": "/firefly/head/tutorials/tokens/erc20.html#create-a-pool",
    "relUrl": "/tutorials/tokens/erc20.html#create-a-pool"
  },"327": {
    "doc": "ERC-20",
    "title": "Mint tokens",
    "content": "Once you have a token pool, you can mint tokens within it. With a token contract deployed by the default token factory, only the creator of a pool is allowed to mint, but a different contract may define its own permission model. NOTE: The default token factory creates an ERC-20 with 18 decimal places. This means that if you want to create 100 tokens, the number submitted to the API / blockchain should actually be 100×1018 = 100000000000000000000. This allows users to work with “fractional” tokens even though Ethereum virtual machines only support integer arithmetic. Request . POST http://127.0.0.1:5000/api/v1/namespaces/default/tokens/mint . { \"amount\": \"100000000000000000000\" } . Response . { \"type\": \"mint\", \"localId\": \"835fe2a1-594b-4336-bc1d-b2f59d51064b\", \"pool\": \"e1477ed5-7282-48e5-ad9d-1612296bb29d\", \"connector\": \"erc20_erc721\", \"key\": \"0x14ddd36a0c2f747130915bf5214061b1e4bec74c\", \"from\": \"0x14ddd36a0c2f747130915bf5214061b1e4bec74c\", \"to\": \"0x14ddd36a0c2f747130915bf5214061b1e4bec74c\", \"amount\": \"100000000000000000000\", \"tx\": { \"type\": \"token_transfer\", \"id\": \"3fc97e24-fde1-4e80-bd82-660e479c0c43\" } } . Other parameters: . | You must specify a pool name if you’ve created more than one pool | You may specify a key understood by the connector (i.e. an Ethereum address) if you’d like to use a non-default signing identity | You may specify to if you’d like to send the minted tokens to a specific identity (default is the same as key) | . ",
    "url": "/firefly/head/tutorials/tokens/erc20.html#mint-tokens",
    "relUrl": "/tutorials/tokens/erc20.html#mint-tokens"
  },"328": {
    "doc": "ERC-20",
    "title": "Transfer tokens",
    "content": "You may transfer tokens within a pool by specifying an amount and a destination understood by the connector (i.e. an Ethereum address). With a token contract deployed by the default token factory, only the owner of the tokens or another approved account may transfer their tokens, but a different contract may define its own permission model. Request . POST http://127.0.0.1:5000/api/v1/namespaces/default/tokens/transfers . { \"amount\": \"10000000000000000000\", \"to\": \"0xa4222a4ae19448d43a338e6586edd5fb2ac398e1\" } . Response . { \"type\": \"transfer\", \"localId\": \"61f0a71f-712b-4778-8b37-784fbee52657\", \"pool\": \"e1477ed5-7282-48e5-ad9d-1612296bb29d\", \"connector\": \"erc20_erc721\", \"key\": \"0x14ddd36a0c2f747130915bf5214061b1e4bec74c\", \"from\": \"0x14ddd36a0c2f747130915bf5214061b1e4bec74c\", \"to\": \"0xa4222a4ae19448d43a338e6586edd5fb2ac398e1\", \"amount\": \"10000000000000000000\", \"tx\": { \"type\": \"token_transfer\", \"id\": \"c0c316a3-23a9-42f3-89b3-1cfdba6c948d\" } } . Other parameters: . | You must specify a pool name if you’ve created more than one pool | You may specify a key understood by the connector (i.e. an Ethereum address) if you’d like to use a non-default signing identity | You may specify from if you’d like to send tokens from a specific identity (default is the same as key) | . ",
    "url": "/firefly/head/tutorials/tokens/erc20.html#transfer-tokens",
    "relUrl": "/tutorials/tokens/erc20.html#transfer-tokens"
  },"329": {
    "doc": "ERC-20",
    "title": "Sending data with a transfer",
    "content": "All transfers (as well as mint/burn operations) support an optional message parameter that contains a broadcast or private message to be sent along with the transfer. This message follows the same convention as other FireFly messages, and may be comprised of text or blob data, and can provide context, metadata, or other supporting information about the transfer. The message will be batched, hashed, and pinned to the primary blockchain. The message ID and hash will also be sent to the token connector as part of the transfer operation, to be written to the token blockchain when the transaction is submitted. All recipients of the message will then be able to correlate the message with the token transfer. POST http://127.0.0.1:5000/api/v1/namespaces/default/tokens/transfers . Broadcast message . { \"amount\": 1, \"to\": \"0x07eab7731db665caf02bc92c286f51dea81f923f\", \"message\": { \"data\": [{ \"value\": \"payment for goods\" }] } } . Private message . { \"amount\": 1, \"to\": \"0x07eab7731db665caf02bc92c286f51dea81f923f\", \"message\": { \"header\": { \"type\": \"transfer_private\", }, \"group\": { \"members\": [{ \"identity\": \"org_1\" }] }, \"data\": [{ \"value\": \"payment for goods\" }] } } . Note that all parties in the network will be able to see the transfer (including the message ID and hash), but only the recipients of the message will be able to view the actual message data. ",
    "url": "/firefly/head/tutorials/tokens/erc20.html#sending-data-with-a-transfer",
    "relUrl": "/tutorials/tokens/erc20.html#sending-data-with-a-transfer"
  },"330": {
    "doc": "ERC-20",
    "title": "Burn tokens",
    "content": "You may burn tokens by simply specifying an amount. With a token contract deployed by the default token factory, only the owner of a token may burn it, but a different contract may define its own permission model. POST http://127.0.0.1:5000/api/v1/namespaces/default/tokens/burn . { \"amount\": 1, } . Other parameters: . | You must specify a pool name if you’ve created more than one pool | You may specify a key understood by the connector (i.e. an Ethereum address) if you’d like to use a non-default signing identity | You may specify from if you’d like to burn tokens from a specific identity (default is the same as key) | . ",
    "url": "/firefly/head/tutorials/tokens/erc20.html#burn-tokens",
    "relUrl": "/tutorials/tokens/erc20.html#burn-tokens"
  },"331": {
    "doc": "ERC-20",
    "title": "Token approvals",
    "content": "You can also approve other wallets to transfer tokens on your behalf with the /approvals API. The important fields in a token approval API request are as follows: . | approved: Sets whether another account is allowed to transfer tokens out of this wallet or not. If not specified, will default to true. Setting to false can revoke an existing approval. | operator: The other account that is allowed to transfer tokens out of the wallet specified in the key field | config.allowance: The number of tokens the other account is allowed to transfer. If 0 or not set, the approval is valid for any number. | key: The wallet address for the approval. If not set, it defaults to the address of the FireFly node submitting the transaction | . Here is an example request that would let the signing account 0x634ee8c7d0894d086c7af1fc8514736aed251528 transfer up to 10×1018 (10000000000000000000) tokens from my wallet . Request . POST http://127.0.0.1:5000/api/v1/namespaces/default/tokens/approvals . { \"operator\": \"0x634ee8c7d0894d086c7af1fc8514736aed251528\", \"config\": { \"allowance\": \"10000000000000000000\" } } . Response . { \"localId\": \"46fef50a-cf93-4f92-acf8-fae161b37362\", \"pool\": \"e1477ed5-7282-48e5-ad9d-1612296bb29d\", \"connector\": \"erc20_erc721\", \"key\": \"0x14ddd36a0c2f747130915bf5214061b1e4bec74c\", \"operator\": \"0x634ee8c7d0894d086c7af1fc8514736aed251528\", \"approved\": true, \"tx\": { \"type\": \"token_approval\", \"id\": \"00faa011-f42c-403d-a047-2df7318967cd\" }, \"config\": { \"allowance\": \"10000000000000000000\" } } . ",
    "url": "/firefly/head/tutorials/tokens/erc20.html#token-approvals",
    "relUrl": "/tutorials/tokens/erc20.html#token-approvals"
  },"332": {
    "doc": "ERC-20",
    "title": "Use Metamask",
    "content": "Now that you have an ERC-20 contract up and running, you may be wondering how to use Metamask (or some other wallet) with this contract. This section will walk you through how to connect Metamask to the blockchain and token contract that FireFly is using. Configure a new network . The first thing we need to do is tell Metamask how to connect to our local blockchain node. To do that: . | Click your account icon | In the drop down menu, click Settings . | On the left hand side of the page, click Networks | Click the Add a network button . | Fill in the network details: . | Network Name: FireFly (could be any name) | New RPC URL: http://127.0.0.1:5100 | Chain ID: 2021 | Currency Symbol: ETH | . | Click Save | . Import tokens . Metamask won’t know about our custom ERC-20 contract until we give it the Ethereum address for the contract, so that’s what we’ll do next. | Click on Import tokens . | Enter the Ethereum address of the contract | Enter a Token Symbol (can be anything you want) | Click Add Custom Token | . NOTE: You can find the address of your contract from the response to the request to create the token pool above. You can also do a GET to http://127.0.0.1:5000/api/v1/namespaces/default/tokens/pools to lookup your configured token pools. Transfer tokens . Now you can copy your account address from your Metamask wallet, and perform a transfer from FireFly’s API (as described above) to your Metamask address. After a couple seconds, you should see your tokens show up in your Metamask wallet. You can also send tokens to a FireFly address or any other Ethereum address from your Metamask wallet. NOTE: You can find the Ethereum addresses for organizations in your FireFly network in the Network → Organizations page in the FireFly explorer. Click on an organization and look under the Verifiers header for the organization’s Ethereum address. ",
    "url": "/firefly/head/tutorials/tokens/erc20.html#use-metamask",
    "relUrl": "/tutorials/tokens/erc20.html#use-metamask"
  },"333": {
    "doc": "ERC-20",
    "title": "ERC-20",
    "content": " ",
    "url": "/firefly/head/tutorials/tokens/erc20.html",
    "relUrl": "/tutorials/tokens/erc20.html"
  },"334": {
    "doc": "ERC-721",
    "title": "Use ERC-721 tokens",
    "content": " ",
    "url": "/firefly/head/tutorials/tokens/erc721.html#use-erc-721-tokens",
    "relUrl": "/tutorials/tokens/erc721.html#use-erc-721-tokens"
  },"335": {
    "doc": "ERC-721",
    "title": "Table of contents",
    "content": ". | Previous steps: Start your environment | Use the built in sample token factory | Use the Sandbox (optional) | Create a pool . | Request | Response | Get the address of the deployed contract . | Request | Response | . | Create a pool for an existing contract | . | Mint a token . | Request | Response | . | Transfer a token . | Request | Response | . | Sending data with a transfer . | Broadcast message | Private message | . | Burn tokens | Token approvals . | Request | Response | . | Use Metamask . | Configure a new network | Import tokens | Transfer tokens | . | . ",
    "url": "/firefly/head/tutorials/tokens/erc721.html#table-of-contents",
    "relUrl": "/tutorials/tokens/erc721.html#table-of-contents"
  },"336": {
    "doc": "ERC-721",
    "title": "Previous steps: Start your environment",
    "content": "If you haven’t started a FireFly stack already, please go to the Getting Started guide on how to Start your environment. This will set up a token connector that works with both ERC-20 and ERC-721 by default. ← ② Start your environment . ",
    "url": "/firefly/head/tutorials/tokens/erc721.html#previous-steps-start-your-environment",
    "relUrl": "/tutorials/tokens/erc721.html#previous-steps-start-your-environment"
  },"337": {
    "doc": "ERC-721",
    "title": "Use the built in sample token factory",
    "content": "If you are using the default ERC-20 / ERC-721 token connector, when the FireFly CLI set up your FireFly stack, it also deployed a token factory contract. When you create a token pool through FireFly’s token APIs, the token factory contract will automatically deploy an ERC-20 or ERC-721 contract, based on the pool type in the API request. ⚠️ WARNING: The default token contract that was deployed by the FireFly CLI is only provided for the purpose of learning about FireFly. It is not a production grade contract. If you intend to deploy a production application using tokens FireFly you should research token contract best practices. For details, please see the source code for the contract that was deployed. ",
    "url": "/firefly/head/tutorials/tokens/erc721.html#use-the-built-in-sample-token-factory",
    "relUrl": "/tutorials/tokens/erc721.html#use-the-built-in-sample-token-factory"
  },"338": {
    "doc": "ERC-721",
    "title": "Use the Sandbox (optional)",
    "content": "At this point you could open the Sandbox at http://127.0.0.1:5109/home?action=tokens.pools and perform the functions outlined in the rest of this guide. Or you can keep reading to learn how to build HTTP requests to work with tokens in FireFly. ",
    "url": "/firefly/head/tutorials/tokens/erc721.html#use-the-sandbox-optional",
    "relUrl": "/tutorials/tokens/erc721.html#use-the-sandbox-optional"
  },"339": {
    "doc": "ERC-721",
    "title": "Create a pool",
    "content": "After you stack is up and running, the first thing you need to do is create a Token Pool. Every application will need at least one Token Pool. At a minimum, you must always specify a name and type for the pool. If you’re using the default ERC-20 / ERC-721 token connector and its sample token factory, it will automatically deploy a new token contract, based on the type in the request to create the token pool. Request . POST http://127.0.0.1:5000/api/v1/namespaces/default/tokens/pools . { \"type\": \"nonfungible\", \"name\": \"nfts\" } . Response . { \"id\": \"a92a0a25-b886-4b43-931f-4add2840258a\", \"type\": \"nonfungible\", \"namespace\": \"default\", \"name\": \"nfts\", \"key\": \"0x14ddd36a0c2f747130915bf5214061b1e4bec74c\", \"connector\": \"erc20_erc721\", \"tx\": { \"type\": \"token_pool\", \"id\": \"00678116-89d2-4295-990c-bd5ffa6e2434\" } } . Other parameters: . | You must specify a connector if you have configured multiple token connectors | You may pass through a config object of additional parameters, if supported by your token connector | You may specify a key understood by the connector (i.e. an Ethereum address) if you’d like to use a non-default signing identity | . Get the address of the deployed contract . To lookup the address of the new contract, you can lookup the Token Pool by its ID on the API. Creating the token pool will also emit an event which will contain the address. To query the token pool you can make a GET request to the pool’s ID: . Request . GET http://127.0.0.1:5000/api/v1/namespaces/default/tokens/pools/5811e8d5-52d0-44b1-8b75-73f5ff88f598 . Response . { \"id\": \"a92a0a25-b886-4b43-931f-4add2840258a\", \"type\": \"nonfungible\", \"namespace\": \"default\", \"name\": \"nfts\", \"standard\": \"ERC721\", \"locator\": \"address=0xc4d02efcfab06f18ec0a68e00b98ffecf6bf7e3c&amp;schema=ERC721WithData&amp;type=nonfungible\", \"connector\": \"erc20_erc721\", \"message\": \"53d95dda-e8ca-4546-9226-a0fdc6ec03ec\", \"state\": \"confirmed\", \"created\": \"2022-04-29T12:03:51.971349509Z\", \"info\": { \"address\": \"0xc4d02efcfab06f18ec0a68e00b98ffecf6bf7e3c\", \"name\": \"nfts\", \"schema\": \"ERC721WithData\" }, \"tx\": { \"type\": \"token_pool\", \"id\": \"00678116-89d2-4295-990c-bd5ffa6e2434\" } } . Create a pool for an existing contract . If you wish to use a contract that is already on the chain, you can pass the address in a config object with an address when you make the request to create the Token Pool. POST http://127.0.0.1:5000/api/v1/namespaces/default/tokens/pools . { \"name\": \"testpool\", \"type\": \"fungible\", \"config\": { \"address\": \"0xb1C845D32966c79E23f733742Ed7fCe4B41901FC\" } } . ",
    "url": "/firefly/head/tutorials/tokens/erc721.html#create-a-pool",
    "relUrl": "/tutorials/tokens/erc721.html#create-a-pool"
  },"340": {
    "doc": "ERC-721",
    "title": "Mint a token",
    "content": "Once you have a token pool, you can mint tokens within it. With a token contract deployed by the default token factory, only the creator of a pool is allowed to mint, but a different contract may define its own permission model. With the default ERC-20 / ERC-721 token connector, the tokenIndex field must be set when minting an NFT. This is the unique index within the pool for the specific token that you are minting. NOTE: When minting NFTs the amount must be 1. If you wish to mint more NFTs, simply call the endpoint multiple times. Request . POST http://127.0.0.1:5000/api/v1/namespaces/default/tokens/mint . { \"amount\": \"1\", \"tokenIndex\": \"1\" } . Response . { \"type\": \"mint\", \"localId\": \"2de2e05e-9474-4a08-a64f-2cceb076bdaa\", \"pool\": \"a92a0a25-b886-4b43-931f-4add2840258a\", \"connector\": \"erc20_erc721\", \"key\": \"0x14ddd36a0c2f747130915bf5214061b1e4bec74c\", \"from\": \"0x14ddd36a0c2f747130915bf5214061b1e4bec74c\", \"to\": \"0x14ddd36a0c2f747130915bf5214061b1e4bec74c\", \"amount\": \"1\", \"tx\": { \"type\": \"token_transfer\", \"id\": \"0fad4581-7cb2-42c7-8f78-62d32205c2c2\" } } . Other parameters: . | You must specify a pool name if you’ve created more than one pool | You may specify a key understood by the connector (i.e. an Ethereum address) if you’d like to use a non-default signing identity | You may specify to if you’d like to send the minted tokens to a specific identity (default is the same as key) | . ",
    "url": "/firefly/head/tutorials/tokens/erc721.html#mint-a-token",
    "relUrl": "/tutorials/tokens/erc721.html#mint-a-token"
  },"341": {
    "doc": "ERC-721",
    "title": "Transfer a token",
    "content": "You may transfer tokens within a pool by specifying an amount and a destination understood by the connector (i.e. an Ethereum address). With a token contract deployed by the default token factory, only the owner of the tokens or another approved account may transfer their tokens, but a different contract may define its own permission model. When transferring an NFT, you must also specify the tokenIndex that you wish to transfer. The tokenIndex is simply the ID of the specific NFT within the pool that you wish to transfer. NOTE: When transferring NFTs the amount must be 1. If you wish to transfer more NFTs, simply call the endpoint multiple times, specifying the token index of each token to transfer. Request . POST http://127.0.0.1:5000/api/v1/namespaces/default/tokens/transfers . { \"amount\": \"1\", \"tokenIndex\": \"1\", \"to\": \"0xa4222a4ae19448d43a338e6586edd5fb2ac398e1\" } . Response . { \"type\": \"transfer\", \"localId\": \"f5fd0d13-db13-4d70-9a99-6bcd747f1e42\", \"pool\": \"a92a0a25-b886-4b43-931f-4add2840258a\", \"tokenIndex\": \"1\", \"connector\": \"erc20_erc721\", \"key\": \"0x14ddd36a0c2f747130915bf5214061b1e4bec74c\", \"from\": \"0x14ddd36a0c2f747130915bf5214061b1e4bec74c\", \"to\": \"0xa4222a4ae19448d43a338e6586edd5fb2ac398e1\", \"amount\": \"1\", \"tx\": { \"type\": \"token_transfer\", \"id\": \"63c1a89b-240c-41eb-84bb-323d56f4ba5a\" } } . Other parameters: . | You must specify a pool name if you’ve created more than one pool | You may specify a key understood by the connector (i.e. an Ethereum address) if you’d like to use a non-default signing identity | You may specify from if you’d like to send tokens from a specific identity (default is the same as key) | . ",
    "url": "/firefly/head/tutorials/tokens/erc721.html#transfer-a-token",
    "relUrl": "/tutorials/tokens/erc721.html#transfer-a-token"
  },"342": {
    "doc": "ERC-721",
    "title": "Sending data with a transfer",
    "content": "All transfers (as well as mint/burn operations) support an optional message parameter that contains a broadcast or private message to be sent along with the transfer. This message follows the same convention as other FireFly messages, and may be comprised of text or blob data, and can provide context, metadata, or other supporting information about the transfer. The message will be batched, hashed, and pinned to the primary blockchain. The message ID and hash will also be sent to the token connector as part of the transfer operation, to be written to the token blockchain when the transaction is submitted. All recipients of the message will then be able to correlate the message with the token transfer. POST http://127.0.0.1:5000/api/v1/namespaces/default/tokens/transfers . Broadcast message . { \"amount\": 1, \"tokenIndex\": \"1\", \"to\": \"0x07eab7731db665caf02bc92c286f51dea81f923f\", \"message\": { \"data\": [{ \"value\": \"payment for goods\" }] } } . Private message . { \"amount\": 1, \"tokenIndex\": \"1\", \"to\": \"0x07eab7731db665caf02bc92c286f51dea81f923f\", \"message\": { \"header\": { \"type\": \"transfer_private\", }, \"group\": { \"members\": [{ \"identity\": \"org_1\" }] }, \"data\": [{ \"value\": \"payment for goods\" }] } } . Note that all parties in the network will be able to see the transfer (including the message ID and hash), but only the recipients of the message will be able to view the actual message data. ",
    "url": "/firefly/head/tutorials/tokens/erc721.html#sending-data-with-a-transfer",
    "relUrl": "/tutorials/tokens/erc721.html#sending-data-with-a-transfer"
  },"343": {
    "doc": "ERC-721",
    "title": "Burn tokens",
    "content": "You may burn a token by specifying the token’s tokenIndex. With a token contract deployed by the default token factory, only the owner of a token may burn it, but a different contract may define its own permission model. POST http://127.0.0.1:5000/api/v1/namespaces/default/tokens/burn . { \"amount\": 1, \"tokenIndex\": \"1\" } . Other parameters: . | You must specify a pool name if you’ve created more than one pool | You may specify a key understood by the connector (i.e. an Ethereum address) if you’d like to use a non-default signing identity | You may specify from if you’d like to burn tokens from a specific identity (default is the same as key) | . ",
    "url": "/firefly/head/tutorials/tokens/erc721.html#burn-tokens",
    "relUrl": "/tutorials/tokens/erc721.html#burn-tokens"
  },"344": {
    "doc": "ERC-721",
    "title": "Token approvals",
    "content": "You can also approve other wallets to transfer tokens on your behalf with the /approvals API. The important fields in a token approval API request are as follows: . | approved: Sets whether another account is allowed to transfer tokens out of this wallet or not. If not specified, will default to true. Setting to false can revoke an existing approval. | operator: The other account that is allowed to transfer tokens out of the wallet specified in the key field | config.tokenIndex: The specific token index within the pool that the operator is allowed to transfer. If 0 or not set, the approval is valid for all tokens. | key: The wallet address for the approval. If not set, it defaults to the address of the FireFly node submitting the transaction | . Here is an example request that would let the signing account 0x634ee8c7d0894d086c7af1fc8514736aed251528 transfer tokenIndex 2 from my wallet. Request . POST http://127.0.0.1:5000/api/v1/namespaces/default/tokens/approvals . { \"operator\": \"0x634ee8c7d0894d086c7af1fc8514736aed251528\", \"config\": { \"tokenIndex\": \"2\" } } . Response . { \"localId\": \"46fef50a-cf93-4f92-acf8-fae161b37362\", \"pool\": \"e1477ed5-7282-48e5-ad9d-1612296bb29d\", \"connector\": \"erc20_erc721\", \"key\": \"0x14ddd36a0c2f747130915bf5214061b1e4bec74c\", \"operator\": \"0x634ee8c7d0894d086c7af1fc8514736aed251528\", \"approved\": true, \"tx\": { \"type\": \"token_approval\", \"id\": \"00faa011-f42c-403d-a047-2df7318967cd\" }, \"config\": { \"tokenIndex\": \"2\" } } . ",
    "url": "/firefly/head/tutorials/tokens/erc721.html#token-approvals",
    "relUrl": "/tutorials/tokens/erc721.html#token-approvals"
  },"345": {
    "doc": "ERC-721",
    "title": "Use Metamask",
    "content": "Now that you have an ERC-721 contract up and running, you may be wondering how to use Metamask (or some other wallet) with this contract. This section will walk you through how to connect Metamask to the blockchain and token contract that FireFly is using. Configure a new network . The first thing we need to do is tell Metamask how to connect to our local blockchain node. To do that: . | Click your account icon | In the drop down menu, click Settings . | On the left hand side of the page, click Networks | Click the Add a network button . | Fill in the network details: . | Network Name: FireFly (could be any name) | New RPC URL: http://127.0.0.1:5100 | Chain ID: 2021 | Currency Symbol: ETH | . | Click Save | . Import tokens . Metamask won’t know about our custom ERC-721 contract until we give it the Ethereum address for the contract, so that’s what we’ll do next. | Click on Import tokens . | Enter the Ethereum address of the contract | Enter a Token Symbol (can be anything you want) | Click Add Custom Token | . NOTE: You can find the address of your contract from the response to the request to create the token pool above. You can also do a GET to http://127.0.0.1:5000/api/v1/namespaces/default/tokens/pools to lookup your configured token pools. Transfer tokens . Now you can copy your account address from your Metamask wallet, and perform a transfer from FireFly’s API (as described above) to your Metamask address. After a couple seconds, you should see your token show up in your Metamask wallet. NOTE: While the NFT token balance can be viewed in Metamask, it does not appear that Metamask supports sending these tokens to another address at this time. ",
    "url": "/firefly/head/tutorials/tokens/erc721.html#use-metamask",
    "relUrl": "/tutorials/tokens/erc721.html#use-metamask"
  },"346": {
    "doc": "ERC-721",
    "title": "ERC-721",
    "content": " ",
    "url": "/firefly/head/tutorials/tokens/erc721.html",
    "relUrl": "/tutorials/tokens/erc721.html"
  },"347": {
    "doc": "Ethereum",
    "title": "Work with Ethereum smart contracts",
    "content": "This guide describes the steps to deploy a smart contract to an Ethereum blockchain and use FireFly to interact with it in order to submit transactions, query for states and listening for events. NOTE: This guide assumes that you are running a local FireFly stack with at least 2 members and an Ethereum blockchain created by the FireFly CLI. If you need help getting that set up, please see the Getting Started guide to Start your environment. ",
    "url": "/firefly/head/tutorials/custom_contracts/ethereum.html#work-with-ethereum-smart-contracts",
    "relUrl": "/tutorials/custom_contracts/ethereum.html#work-with-ethereum-smart-contracts"
  },"348": {
    "doc": "Ethereum",
    "title": "Table of contents",
    "content": ". | Example smart contract | Contract deployment . | Using Truffle | Using the FireFly CLI | . | The FireFly Interface Format . | Request | Response | . | Broadcast the contract interface . | Request | Response | . | Create an HTTP API for the contract . | Request | Response | . | View OpenAPI spec for the contract | Invoke the smart contract . | Request | Response | . | Query the current value . | Request | Response | . | Passing additional options with a request . | Request | Response | . | Create a blockchain event listener . | Request | Response | Querying listener status . | Request / Response | . | . | Subscribe to events from our contract . | Request | Response | . | Receive custom smart contract events . | WebSocket event | Subscription offset | . | Appendix I: Work with a custom contract without creating a named API . | Request | Response | . | Appendix II: Work directly with contracts with inline requests . | Request | Response | . | . ",
    "url": "/firefly/head/tutorials/custom_contracts/ethereum.html#table-of-contents",
    "relUrl": "/tutorials/custom_contracts/ethereum.html#table-of-contents"
  },"349": {
    "doc": "Ethereum",
    "title": "Example smart contract",
    "content": "For this tutorial, we will be using a well known, but slightly modified smart contract called SimpleStorage, and will be using this contract on an Ethereum blockchain. As the name implies, it’s a very simple contract which stores an unsigned 256 bit integer, emits and event when the value is updated, and allows you to retrieve the current value. Here is the source for this contract: . // SPDX-License-Identifier: Apache-2.0 pragma solidity ^0.8.10; // Declares a new contract contract SimpleStorage { // Storage. Persists in between transactions uint256 x; // Allows the unsigned integer stored to be changed function set(uint256 newValue) public { x = newValue; emit Changed(msg.sender, newValue); } // Returns the currently stored unsigned integer function get() public view returns (uint256) { return x; } event Changed(address indexed from, uint256 value); } . ",
    "url": "/firefly/head/tutorials/custom_contracts/ethereum.html#example-smart-contract",
    "relUrl": "/tutorials/custom_contracts/ethereum.html#example-smart-contract"
  },"350": {
    "doc": "Ethereum",
    "title": "Contract deployment",
    "content": "For the this guide, we will assume that the SimpleStorage contract is deployed at the Ethereum address of: 0xa5ea5d0a6b2eaf194716f0cc73981939dca26da1 . Deployment of smart contracts is not currently within the scope of responsibility for FireFly. You can use your standard blockchain specific tools to deploy your contract to whichever blockchain you are using. For Ethereum blockchains you could use Truffle or Hardhat. Using Truffle . If you’re using Truffle, you’ll need to set your truffle-config.js file to point to the locally running blockchain node that the FireFly CLI created. Make sure your networks section looks like this: . networks: { development: { host: \"127.0.0.1\", port: 5100, network_id: \"*\" } } . Using the FireFly CLI . The FireFly CLI also has a function to deploy an already-compiled smart contract to a local FireFly stack. NOTE: The contract deployment function of the FireFly CLI is a convenience function to speed up local development, and not intended for production applications . We will use the solc compiler to compile our smart contract. For details on how to install solc on your system, please see the Solidity Compiler Documentation. If you take the smart contract source code in the example above, and save that to a file called simple_storage.sol, here is the command to compile the contract: . $ solc --combined-json abi,bin simple_storage.sol &gt; simple_storage.json . Next, we’ll tell the FireFly to deploy the compiled contract to a running stack named dev. If your stack name is different, update the command accordingly: . $ ff deploy dev simple_storage.json reading stack config... done deploying simple_storage.sol:SimpleStorage... done contract address: 0xa5ea5d0a6b2eaf194716f0cc73981939dca26da1 . The FireFly CLI tells us that it has successfully deployed the contract with an address of 0xa5ea5d0a6b2eaf194716f0cc73981939dca26da1. We will use this contract address for the rest of this guide. ",
    "url": "/firefly/head/tutorials/custom_contracts/ethereum.html#contract-deployment",
    "relUrl": "/tutorials/custom_contracts/ethereum.html#contract-deployment"
  },"351": {
    "doc": "Ethereum",
    "title": "The FireFly Interface Format",
    "content": "If you have an Ethereum ABI for an existing smart contract, there is an HTTP endpoint on the FireFly API that will take the ABI as input and automatically generate the FireFly Interface for you. Rather than handcrafting our FFI, we’ll let FireFly generate it for us using that endpoint now. Request . Here we will take the JSON ABI generated by truffle or solc and POST that to FireFly to have it automatically generate the FireFly Interface for us. Copy the abi from the compiled JSON file, and put that inside an input object like the example below: . POST http://localhost:5000/api/v1/namespaces/default/contracts/interfaces/generate . { \"input\": { \"abi\": [ { \"anonymous\": false, \"inputs\": [ { \"indexed\": true, \"internalType\": \"address\", \"name\": \"from\", \"type\": \"address\" }, { \"indexed\": false, \"internalType\": \"uint256\", \"name\": \"value\", \"type\": \"uint256\" } ], \"name\": \"Changed\", \"type\": \"event\" }, { \"inputs\": [], \"name\": \"get\", \"outputs\": [ { \"internalType\": \"uint256\", \"name\": \"\", \"type\": \"uint256\" } ], \"stateMutability\": \"view\", \"type\": \"function\" }, { \"inputs\": [ { \"internalType\": \"uint256\", \"name\": \"newValue\", \"type\": \"uint256\" } ], \"name\": \"set\", \"outputs\": [], \"stateMutability\": \"nonpayable\", \"type\": \"function\" } ] } } . Response . FireFly generates and returns the the full FireFly Interface for the SimpleStorage contract in the response body: . { \"namespace\": \"default\", \"name\": \"\", \"description\": \"\", \"version\": \"\", \"methods\": [ { \"name\": \"get\", \"pathname\": \"\", \"description\": \"\", \"params\": [], \"returns\": [ { \"name\": \"\", \"schema\": { \"type\": \"integer\", \"details\": { \"type\": \"uint256\", \"internalType\": \"uint256\" } } } ] }, { \"name\": \"set\", \"pathname\": \"\", \"description\": \"\", \"params\": [ { \"name\": \"newValue\", \"schema\": { \"type\": \"integer\", \"details\": { \"type\": \"uint256\", \"internalType\": \"uint256\" } } } ], \"returns\": [] } ], \"events\": [ { \"name\": \"Changed\", \"description\": \"\", \"params\": [ { \"name\": \"from\", \"schema\": { \"type\": \"string\", \"details\": { \"type\": \"address\", \"internalType\": \"address\", \"indexed\": true } } }, { \"name\": \"value\", \"schema\": { \"type\": \"integer\", \"details\": { \"type\": \"uint256\", \"internalType\": \"uint256\" } } } ] } ] } . ",
    "url": "/firefly/head/tutorials/custom_contracts/ethereum.html#the-firefly-interface-format",
    "relUrl": "/tutorials/custom_contracts/ethereum.html#the-firefly-interface-format"
  },"352": {
    "doc": "Ethereum",
    "title": "Broadcast the contract interface",
    "content": "Now that we have a FireFly Interface representation of our smart contract, we want to broadcast that to the entire network. This broadcast will be pinned to the blockchain, so we can always refer to this specific name and version, and everyone in the network will know exactly which contract interface we are talking about. We will take the output from the previous HTTP response above, fill in the name and version and then POST that to the /contracts/interfaces API endpoint. Request . POST http://localhost:5000/api/v1/namespaces/default/contracts/interfaces . { \"namespace\": \"default\", \"name\": \"SimpleStorage\", \"version\": \"v1.0.0\", \"description\": \"\", \"methods\": [ { \"name\": \"get\", \"pathname\": \"\", \"description\": \"\", \"params\": [], \"returns\": [ { \"name\": \"\", \"schema\": { \"type\": \"integer\", \"details\": { \"type\": \"uint256\", \"internalType\": \"uint256\" } } } ] }, { \"name\": \"set\", \"pathname\": \"\", \"description\": \"\", \"params\": [ { \"name\": \"newValue\", \"schema\": { \"type\": \"integer\", \"details\": { \"type\": \"uint256\", \"internalType\": \"uint256\" } } } ], \"returns\": [] } ], \"events\": [ { \"name\": \"Changed\", \"description\": \"\", \"params\": [ { \"name\": \"from\", \"schema\": { \"type\": \"string\", \"details\": { \"type\": \"address\", \"internalType\": \"address\", \"indexed\": true } } }, { \"name\": \"value\", \"schema\": { \"type\": \"integer\", \"details\": { \"type\": \"uint256\", \"internalType\": \"uint256\" } } } ] } ] } . Response . { \"id\": \"8bdd27a5-67c1-4960-8d1e-7aa31b9084d3\", \"message\": \"3cd0dde2-1e39-4c9e-a4a1-569e87cca93a\", \"namespace\": \"default\", \"name\": \"SimpleStorage\", \"description\": \"\", \"version\": \"v1.0.0\", \"methods\": [ { \"id\": \"56467890-5713-4463-84b8-4537fcb63d8b\", \"contract\": \"8bdd27a5-67c1-4960-8d1e-7aa31b9084d3\", \"name\": \"get\", \"namespace\": \"default\", \"pathname\": \"get\", \"description\": \"\", \"params\": [], \"returns\": [ { \"name\": \"\", \"schema\": { \"type\": \"integer\", \"details\": { \"type\": \"uint256\", \"internalType\": \"uint256\" } } } ] }, { \"id\": \"6b254d1d-5f5f-491e-bbd2-201e96892e1a\", \"contract\": \"8bdd27a5-67c1-4960-8d1e-7aa31b9084d3\", \"name\": \"set\", \"namespace\": \"default\", \"pathname\": \"set\", \"description\": \"\", \"params\": [ { \"name\": \"newValue\", \"schema\": { \"type\": \"integer\", \"details\": { \"type\": \"uint256\", \"internalType\": \"uint256\" } } } ], \"returns\": [] } ], \"events\": [ { \"id\": \"aa1fe67b-b2ac-41af-a7e7-7ad54a30a78d\", \"contract\": \"8bdd27a5-67c1-4960-8d1e-7aa31b9084d3\", \"namespace\": \"default\", \"pathname\": \"Changed\", \"name\": \"Changed\", \"description\": \"\", \"params\": [ { \"name\": \"from\", \"schema\": { \"type\": \"string\", \"details\": { \"type\": \"address\", \"internalType\": \"address\", \"indexed\": true } } }, { \"name\": \"value\", \"schema\": { \"type\": \"integer\", \"details\": { \"type\": \"uint256\", \"internalType\": \"uint256\" } } } ] } ] } . ",
    "url": "/firefly/head/tutorials/custom_contracts/ethereum.html#broadcast-the-contract-interface",
    "relUrl": "/tutorials/custom_contracts/ethereum.html#broadcast-the-contract-interface"
  },"353": {
    "doc": "Ethereum",
    "title": "Create an HTTP API for the contract",
    "content": "Now comes the fun part where we see some of the powerful, developer-friendly features of FireFly. The next thing we’re going to do is tell FireFly to build an HTTP API for this smart contract, complete with an OpenAPI Specification and Swagger UI. As part of this, we’ll also tell FireFly where the contract is on the blockchain. Like the interface broadcast above, this will also generate a broadcast which will be pinned to the blockchain so all the members of the network will be aware of and able to interact with this API. We need to copy the id field we got in the response from the previous step to the interface.id field in the request body below. We will also pick a name that will be part of the URL for our HTTP API, so be sure to pick a name that is URL friendly. In this case we’ll call it simple-storage. Lastly, in the location.address field, we’re telling FireFly where an instance of the contract is deployed on-chain. NOTE: The location field is optional here, but if it is omitted, it will be required in every request to invoke or query the contract. This can be useful if you have multiple instances of the same contract deployed to different addresses. Request . POST http://localhost:5000/api/v1/namespaces/default/apis . { \"name\": \"simple-storage\", \"interface\": { \"id\": \"8bdd27a5-67c1-4960-8d1e-7aa31b9084d3\" }, \"location\": { \"address\": \"0xa5ea5d0a6b2eaf194716f0cc73981939dca26da1\" } } . Response . { \"id\": \"9a681ec6-1dee-42a0-b91b-61d23a814b0f\", \"namespace\": \"default\", \"interface\": { \"id\": \"8bdd27a5-67c1-4960-8d1e-7aa31b9084d3\" }, \"location\": { \"address\": \"0xa5ea5d0a6b2eaf194716f0cc73981939dca26da1\" }, \"name\": \"simple-storage\", \"message\": \"d90d0386-8874-43fb-b7d3-485c22f35f47\", \"urls\": { \"openapi\": \"http://127.0.0.1:5000/api/v1/namespaces/default/apis/simple-storage/api/swagger.json\", \"ui\": \"http://127.0.0.1:5000/api/v1/namespaces/default/apis/simple-storage/api\" } } . ",
    "url": "/firefly/head/tutorials/custom_contracts/ethereum.html#create-an-http-api-for-the-contract",
    "relUrl": "/tutorials/custom_contracts/ethereum.html#create-an-http-api-for-the-contract"
  },"354": {
    "doc": "Ethereum",
    "title": "View OpenAPI spec for the contract",
    "content": "You’ll notice in the response body that there are a couple of URLs near the bottom. If you navigate to the one labeled ui in your browser, you should see the Swagger UI for your smart contract. ",
    "url": "/firefly/head/tutorials/custom_contracts/ethereum.html#view-openapi-spec-for-the-contract",
    "relUrl": "/tutorials/custom_contracts/ethereum.html#view-openapi-spec-for-the-contract"
  },"355": {
    "doc": "Ethereum",
    "title": "Invoke the smart contract",
    "content": "Now that we’ve got everything set up, it’s time to use our smart contract! We’re going to make a POST request to the invoke/set endpoint to set the integer value on-chain. Let’s set it to the value of 3 right now. Request . POST http://localhost:5000/api/v1/namespaces/default/apis/simple-storage/invoke/set . { \"input\": { \"newValue\": 3 } } . Response . { \"id\": \"41c67c63-52cf-47ce-8a59-895fe2ffdc86\" } . You’ll notice that we just get an ID back here, and that’s expected due to the asynchronous programming model of working with smart contracts in FireFly. To see what the value is now, we can query the smart contract. In a little bit, we’ll also subscribe to the events emitted by this contract so we can know when the value is updated in realtime. ",
    "url": "/firefly/head/tutorials/custom_contracts/ethereum.html#invoke-the-smart-contract",
    "relUrl": "/tutorials/custom_contracts/ethereum.html#invoke-the-smart-contract"
  },"356": {
    "doc": "Ethereum",
    "title": "Query the current value",
    "content": "To make a read-only request to the blockchain to check the current value of the stored integer, we can make a POST to the query/get endpoint. Request . POST http://localhost:5000/api/v1/namespaces/default/apis/simple-storage/query/get . {} . Response . { \"output\": \"3\" } . NOTE: Some contracts may have queries that require input parameters. That’s why the query endpoint is a POST, rather than a GET so that parameters can be passed as JSON in the request body. This particular function does not have any parameters, so we just pass an empty JSON object. ",
    "url": "/firefly/head/tutorials/custom_contracts/ethereum.html#query-the-current-value",
    "relUrl": "/tutorials/custom_contracts/ethereum.html#query-the-current-value"
  },"357": {
    "doc": "Ethereum",
    "title": "Passing additional options with a request",
    "content": "Some smart contract functions may accept or require additional options to be passed with the request. For example, a Solidity function might be payable, meaning that a value field must be specified, indicating an amount of ETH to be transferred with the request. Each of your smart contract API’s /invoke or /query endpoints support an options object in addition to the input arguments for the function itself. Here is an example of sending 100 wei with a transaction: . Request . POST http://localhost:5000/api/v1/namespaces/default/apis/simple-storage/invoke/set . { \"input\": { \"newValue\": 3 }, \"options\": { \"value\": 100 } } . Response . { \"id\": \"41c67c63-52cf-47ce-8a59-895fe2ffdc86\" } . ",
    "url": "/firefly/head/tutorials/custom_contracts/ethereum.html#passing-additional-options-with-a-request",
    "relUrl": "/tutorials/custom_contracts/ethereum.html#passing-additional-options-with-a-request"
  },"358": {
    "doc": "Ethereum",
    "title": "Create a blockchain event listener",
    "content": "Now that we’ve seen how to submit transactions and preform read-only queries to the blockchain, let’s look at how to receive blockchain events so we know when things are happening in realtime. If you look at the source code for the smart contract we’re working with above, you’ll notice that it emits an event when the stored value of the integer is set. In order to receive these events, we first need to instruct FireFly to listen for this specific type of blockchain event. To do this, we create an Event Listener. The /contracts/listeners endpoint is RESTful so there are POST, GET, and DELETE methods available on it. To create a new listener, we will make a POST request. We are going to tell FireFly to listen to events with name \"Changed\" from the FireFly Interface we defined earlier, referenced by its ID. We will also tell FireFly which contract address we expect to emit these events, and the topic to assign these events to. Topics are a way for applications to subscribe to events they are interested in. Request . POST http://localhost:5000/api/v1/namespaces/default/contracts/listeners . { \"interface\": { \"id\": \"8bdd27a5-67c1-4960-8d1e-7aa31b9084d3\" }, \"location\": { \"address\": \"0xa5ea5d0a6b2eaf194716f0cc73981939dca26da1\" }, \"eventPath\": \"Changed\", \"options\": { \"firstEvent\": \"new\" }, \"topic\": \"simple-storage\" } . Response . { \"id\": \"1bfa3b0f-3d90-403e-94a4-af978d8c5b14\", \"interface\": { \"id\": \"8bdd27a5-67c1-4960-8d1e-7aa31b9084d3\" }, \"namespace\": \"default\", \"name\": \"sb-66209ffc-d355-4ac0-7151-bc82490ca9df\", \"protocolId\": \"sb-66209ffc-d355-4ac0-7151-bc82490ca9df\", \"location\": { \"address\": \"0xa5ea5d0a6b2eaf194716f0cc73981939dca26da1\" }, \"created\": \"2022-02-17T22:02:36.34549538Z\", \"event\": { \"name\": \"Changed\", \"description\": \"\", \"params\": [ { \"name\": \"from\", \"schema\": { \"type\": \"string\", \"details\": { \"type\": \"address\", \"internalType\": \"address\", \"indexed\": true } } }, { \"name\": \"value\", \"schema\": { \"type\": \"integer\", \"details\": { \"type\": \"uint256\", \"internalType\": \"uint256\" } } } ] }, \"options\": { \"firstEvent\": \"oldest\" } } . We can see in the response, that FireFly pulls all the schema information from the FireFly Interface that we broadcasted earlier and creates the listener with that schema. This is useful so that we don’t have to enter all of that data again. Querying listener status . If you are interested in learning about the current state of a listener you have created, you can query with the fetchstatus parameter. For FireFly stacks with an EVM compatible blockchain connector, the response will include checkpoint information and if the listener is currently in catchup mode. Request / Response . GET http://localhost:5000/api/v1/namespaces/default/contracts/listeners/1bfa3b0f-3d90-403e-94a4-af978d8c5b14?fetchstatus . { \"id\": \"1bfa3b0f-3d90-403e-94a4-af978d8c5b14\", \"interface\": { \"id\": \"8bdd27a5-67c1-4960-8d1e-7aa31b9084d3\" }, \"namespace\": \"default\", \"name\": \"sb-66209ffc-d355-4ac0-7151-bc82490ca9df\", \"protocolId\": \"sb-66209ffc-d355-4ac0-7151-bc82490ca9df\", \"location\": { \"address\": \"0xa5ea5d0a6b2eaf194716f0cc73981939dca26da1\" }, \"created\": \"2022-02-17T22:02:36.34549538Z\", \"event\": { \"name\": \"Changed\", \"description\": \"\", \"params\": [ { \"name\": \"from\", \"schema\": { \"type\": \"string\", \"details\": { \"type\": \"address\", \"internalType\": \"address\", \"indexed\": true } } }, { \"name\": \"value\", \"schema\": { \"type\": \"integer\", \"details\": { \"type\": \"uint256\", \"internalType\": \"uint256\" } } } ] }, \"status\": { \"checkpoint\": { \"block\": 0, \"transactionIndex\": -1, \"logIndex\": -1 }, \"catchup\": true }, \"options\": { \"firstEvent\": \"oldest\" } } . ",
    "url": "/firefly/head/tutorials/custom_contracts/ethereum.html#create-a-blockchain-event-listener",
    "relUrl": "/tutorials/custom_contracts/ethereum.html#create-a-blockchain-event-listener"
  },"359": {
    "doc": "Ethereum",
    "title": "Subscribe to events from our contract",
    "content": "Now that we’ve told FireFly that it should listen for specific events on the blockchain, we can set up a Subscription for FireFly to send events to our app. To set up our subscription, we will make a POST to the /subscriptions endpoint. We will set a friendly name simple-storage to identify the Subscription when we are connecting to it in the next step. We’re also going to set up a filter to only send events blockchain events from our listener that we created in the previous step. To do that, we’ll copy the listener ID from the step above (1bfa3b0f-3d90-403e-94a4-af978d8c5b14) and set that as the value of the listener field in the example below: . Request . POST http://localhost:5000/api/v1/namespaces/default/subscriptions . { \"namespace\": \"default\", \"name\": \"simple-storage\", \"transport\": \"websockets\", \"filter\": { \"events\": \"blockchain_event_received\", \"blockchainevent\": { \"listener\": \"1bfa3b0f-3d90-403e-94a4-af978d8c5b14\" } }, \"options\": { \"firstEvent\": \"oldest\" } } . Response . { \"id\": \"f826269c-65ed-4634-b24c-4f399ec53a32\", \"namespace\": \"default\", \"name\": \"simple-storage\", \"transport\": \"websockets\", \"filter\": { \"events\": \"blockchain_event_received\", \"message\": {}, \"transaction\": {}, \"blockchainevent\": { \"listener\": \"1bfa3b0f-3d90-403e-94a4-af978d8c5b14\" } }, \"options\": { \"firstEvent\": \"-1\", \"withData\": false }, \"created\": \"2022-03-15T17:35:30.131698921Z\", \"updated\": null } . ",
    "url": "/firefly/head/tutorials/custom_contracts/ethereum.html#subscribe-to-events-from-our-contract",
    "relUrl": "/tutorials/custom_contracts/ethereum.html#subscribe-to-events-from-our-contract"
  },"360": {
    "doc": "Ethereum",
    "title": "Receive custom smart contract events",
    "content": "The last step is to connect a WebSocket client to FireFly to receive the event. You can use any WebSocket client you like, such as Postman or a command line app like websocat. Connect your WebSocket client to ws://localhost:5000/ws. After connecting the WebSocket client, send a message to tell FireFly to: . | Start sending events | For the Subscription named simple-storage | On the default namespace | Automatically “ack” each event which will let FireFly immediately send the next event when available | . { \"type\": \"start\", \"name\": \"simple-storage\", \"namespace\": \"default\", \"autoack\": true } . WebSocket event . After creating the subscription, you should see an event arrive on the connected WebSocket client that looks something like this: . { \"id\": \"0f4a31d6-9743-4537-82df-5a9c76ccbd1e\", \"sequence\": 24, \"type\": \"blockchain_event_received\", \"namespace\": \"default\", \"reference\": \"dd3e1554-c832-47a8-898e-f1ee406bea41\", \"created\": \"2022-03-15T17:32:27.824417878Z\", \"blockchainevent\": { \"id\": \"dd3e1554-c832-47a8-898e-f1ee406bea41\", \"sequence\": 7, \"source\": \"ethereum\", \"namespace\": \"default\", \"name\": \"Changed\", \"listener\": \"1bfa3b0f-3d90-403e-94a4-af978d8c5b14\", \"protocolId\": \"000000000010/000000/000000\", \"output\": { \"from\": \"0xb7e6a5eb07a75a2c81801a157192a82bcbce0f21\", \"value\": \"3\" }, \"info\": { \"address\": \"0xa5ea5d0a6b2eaf194716f0cc73981939dca26da1\", \"blockNumber\": \"10\", \"logIndex\": \"0\", \"signature\": \"Changed(address,uint256)\", \"subId\": \"sb-724b8416-786d-4e67-4cd3-5bae4a26eb0e\", \"timestamp\": \"1647365460\", \"transactionHash\": \"0xd5b5c716554097b2868d8705241bb2189bb76d16300f702ad05b0b02fccc4afb\", \"transactionIndex\": \"0x0\" }, \"timestamp\": \"2022-03-15T17:31:00Z\", \"tx\": { \"type\": \"\" } }, \"subscription\": { \"id\": \"f826269c-65ed-4634-b24c-4f399ec53a32\", \"namespace\": \"default\", \"name\": \"simple-storage\" } } . You can see in the event received over the WebSocket connection, the blockchain event that was emitted from our first transaction, which happened in the past. We received this event, because when we set up both the Listener, and the Subscription, we specified the \"firstEvent\" as \"oldest\". This tells FireFly to look for this event from the beginning of the blockchain, and that your app is interested in FireFly events since the beginning of FireFly’s event history. In the event, we can also see the blockchainevent itself, which has an output object. These are the params in our FireFly Interface, and the actual output of the event. Here we can see the value is 3 which is what we set the integer to in our original transaction. Subscription offset . If you query by the ID of your subscription with the fetchstatus parameter, you can see its current offset. GET http://localhost:5000/api/v1/namespaces/default/subscriptions/f826269c-65ed-4634-b24c-4f399ec53a32 . { \"id\": \"f826269c-65ed-4634-b24c-4f399ec53a32\", \"namespace\": \"default\", \"name\": \"simple-storage\", \"transport\": \"websockets\", \"filter\": { \"events\": \"blockchain_event_received\", \"message\": {}, \"transaction\": {}, \"blockchainevent\": { \"listener\": \"1bfa3b0f-3d90-403e-94a4-af978d8c5b14\" } }, \"options\": { \"firstEvent\": \"-1\", \"withData\": false }, \"status\": { \"offset\": 20 } \"created\": \"2022-03-15T17:35:30.131698921Z\", \"updated\": null } . You’ve reached the end of the main guide to working with custom smart contracts in FireFly. Hopefully this was helpful and gives you what you need to get up and running with your own contracts. There are several additional ways to invoke or query smart contracts detailed below, so feel free to keep reading if you’re curious. ",
    "url": "/firefly/head/tutorials/custom_contracts/ethereum.html#receive-custom-smart-contract-events",
    "relUrl": "/tutorials/custom_contracts/ethereum.html#receive-custom-smart-contract-events"
  },"361": {
    "doc": "Ethereum",
    "title": "Appendix I: Work with a custom contract without creating a named API",
    "content": "FireFly aims to offer a developer-friendly and flexible approach to using custom smart contracts. The guide above has detailed the most robust and feature-rich way to use custom contracts with FireFly, but there are several alternative API usage patterns available as well. It is possible to broadcast a contract interface and use a smart contract that implements that interface without also broadcasting a named API as above. There are several key differences (which may or may not be desirable) compared to the method outlined in the full guide above: . | OpenAPI Spec and Swagger UI are not available | Each HTTP request to invoke/query the contract will need to include the contract location | The contract location will not have been broadcasted to all other members of the network | The URL to invoke/query the contract will be different (described below) | . Request . POST http://localhost:5000/api/v1/namespaces/default/contracts/interfaces/8bdd27a5-67c1-4960-8d1e-7aa31b9084d3/invoke/set . { \"location\": { \"address\": \"0xa5ea5d0a6b2eaf194716f0cc73981939dca26da1\" }, \"input\": { \"newValue\": 7 } } . Response . { \"id\": \"f310fa4a-73d8-4777-9f9d-dfa5012a052f\" } . All of the same invoke, query, and subscribe endpoints are available on the contract interface itself. ",
    "url": "/firefly/head/tutorials/custom_contracts/ethereum.html#appendix-i-work-with-a-custom-contract-without-creating-a-named-api",
    "relUrl": "/tutorials/custom_contracts/ethereum.html#appendix-i-work-with-a-custom-contract-without-creating-a-named-api"
  },"362": {
    "doc": "Ethereum",
    "title": "Appendix II: Work directly with contracts with inline requests",
    "content": "The final way of working with custom smart contracts with FireFly is to just put everything FireFly needs all in one request, each time a contract is invoked or queried. This is the most lightweight, but least feature-rich way of using a custom contract. To do this, we will need to put both the contract location, and a subset of the FireFly Interface that describes the method we want to invoke in the request body, in addition to the function input. Request . POST http://localhost:5000/api/v1/namespaces/default/contracts/invoke . { \"location\": { \"address\": \"0xa5ea5d0a6b2eaf194716f0cc73981939dca26da1\" }, \"method\": { \"name\": \"set\", \"params\": [ { \"name\": \"x\", \"schema\": { \"type\": \"integer\", \"details\": { \"type\": \"uint256\" } } } ], \"returns\": [] }, \"input\": { \"x\": 42 } } . Response . { \"id\": \"386d3e23-e4bc-4a9b-bc1f-452f0a8c9ae5\" } . ",
    "url": "/firefly/head/tutorials/custom_contracts/ethereum.html#appendix-ii-work-directly-with-contracts-with-inline-requests",
    "relUrl": "/tutorials/custom_contracts/ethereum.html#appendix-ii-work-directly-with-contracts-with-inline-requests"
  },"363": {
    "doc": "Ethereum",
    "title": "Ethereum",
    "content": " ",
    "url": "/firefly/head/tutorials/custom_contracts/ethereum.html",
    "relUrl": "/tutorials/custom_contracts/ethereum.html"
  },"364": {
    "doc": "Event",
    "title": "Event",
    "content": " ",
    "url": "/firefly/head/reference/types/event.html",
    "relUrl": "/reference/types/event.html"
  },"365": {
    "doc": "Event",
    "title": "Table of contents",
    "content": ". | Event . | Sequence | Reference | Correlator | Topic | Transaction | Reference, Topic and Correlator by Event Type | Example | Field Descriptions | . | . ",
    "url": "/firefly/head/reference/types/event.html#table-of-contents",
    "relUrl": "/reference/types/event.html#table-of-contents"
  },"366": {
    "doc": "Event",
    "title": "Event",
    "content": "Every Event emitted by FireFly shares a common structure. See Events for a reference for how the overall event bus in Hyperledger FireFly operates, and descriptions of all the sub-categories of events. Sequence . A local sequence number is assigned to each event, and you can use an API to query events using this sequence number in exactly the same order that they are delivered to your application. Reference . Events have a reference to the UUID of an object that is the subject of the event, such as a detailed Blockchain Event, or an off-chain Message. When events are delivered to your application, the reference field is automatically retrieved and included in the JSON payload that is delivered to your application. You can use the ?fetchreferences query parameter on API calls to request the same in-line JSON payload be included in query results. The type of the reference also determines what subscription filters apply when performing server-side filters. Here is the mapping between event types, and the object that you find in the reference field. Correlator . For some event types, there is a secondary reference to an object that is associated with the event. This is set in a correlator field on the Event, but is not automatically fetched. This field is primarily used for the confirm option on API calls to allow FireFly to determine when a request has succeeded/failed. Topic . Events have a topic, and how that topic is determined is specific to the type of event. This is intended to be a property you would use to filter events to your application, or query all historical events associated with a given business data stream. For example when you send a Message, you set the topics you want that message to apply to, and FireFly ensures a consistent global order between all parties that receive that message. Transaction . When actions are submitted by a FireFly node, they are performed within a FireFly Transaction. The events that occur as a direct result of that transaction, are tagged with the transaction ID so that they can be grouped together. This construct is a distinct higher level construct than a Blockchain transaction, that groups together a number of operations/events that might be on-chain or off-chain. In some cases, such as unpinned off-chain data transfer, a FireFly transaction can exist when there is no blockchain transaction at all. Wherever possible you will find that FireFly tags the FireFly transaction with any associated Blockchain transaction(s). Note that some events cannot be tagged with a Transaction ID: . | Blockchain events, unless they were part of a batch-pin transaction for transfer of a message | Token transfers/approvals, unless they had a message transfer associated with them (and included a data payload in the event they emitted) | . Reference, Topic and Correlator by Event Type . | Types | Reference | Topic | Correlator | . | transaction_submitted | Transaction | transaction.type |   | . | message_confirmedmessage_rejected | Message | message.header.topics[i]* | message.header.cid | . | token_pool_confirmed | TokenPool | tokenPool.id |   | . | token_pool_op_failed | Operation | tokenPool.id | tokenPool.id | . | token_transfer_confirmed | TokenTransfer | tokenPool.id |   | . | token_transfer_op_failed | Operation | tokenPool.id | tokenTransfer.localId | . | token_approval_confirmed | TokenApproval | tokenPool.id |   | . | token_approval_op_failed | Operation | tokenPool.id | tokenApproval.localId | . | namespace_confirmed | Namespace | \"ff_definition\" |   | . | datatype_confirmed | Datatype | \"ff_definition\" |   | . | identity_confirmedidentity_updated | Identity | \"ff_definition\" |   | . | contract_interface_confirmed | FFI | \"ff_definition\" |   | . | contract_api_confirmed | ContractAPI | \"ff_definition\" |   | . | blockchain_event_received | BlockchainEvent | From listener ** |   | . | blockchain_invoke_op_succeeded | Operation |   |   | . | blockchain_invoke_op_failed | Operation |   |   | . | A separate event is emitted for each topic associated with a Message. | . ** The topic for a blockchain event is inherited from the blockchain listener, allowing you to create multiple blockchain listeners that all deliver messages to your application on a single FireFly topic. Example . { \"id\": \"5f875824-b36b-4559-9791-a57a2e2b30dd\", \"sequence\": 168, \"type\": \"transaction_submitted\", \"namespace\": \"ns1\", \"reference\": \"0d12aa75-5ed8-48a7-8b54-45274c6edcb1\", \"tx\": \"0d12aa75-5ed8-48a7-8b54-45274c6edcb1\", \"topic\": \"batch_pin\", \"created\": \"2022-05-16T01:23:15Z\" } . Field Descriptions . | Field Name | Description | Type | . | id | The UUID assigned to this event by your local FireFly node | UUID | . | sequence | A sequence indicating the order in which events are delivered to your application. Assure to be unique per event in your local FireFly database (unlike the created timestamp) | int64 | . | type | All interesting activity in FireFly is emitted as a FireFly event, of a given type. The ‘type’ combined with the ‘reference’ can be used to determine how to process the event within your application | FFEnum:\"transaction_submitted\"\"message_confirmed\"\"message_rejected\"\"datatype_confirmed\"\"identity_confirmed\"\"identity_updated\"\"token_pool_confirmed\"\"token_pool_op_failed\"\"token_transfer_confirmed\"\"token_transfer_op_failed\"\"token_approval_confirmed\"\"token_approval_op_failed\"\"contract_interface_confirmed\"\"contract_api_confirmed\"\"blockchain_event_received\"\"blockchain_invoke_op_succeeded\"\"blockchain_invoke_op_failed\" | . | namespace | The namespace of the event. Your application must subscribe to events within a namespace | string | . | reference | The UUID of an resource that is the subject of this event. The event type determines what type of resource is referenced, and whether this field might be unset | UUID | . | correlator | For message events, this is the ‘header.cid’ field from the referenced message. For certain other event types, a secondary object is referenced such as a token pool | UUID | . | tx | The UUID of a transaction that is event is part of. Not all events are part of a transaction | UUID | . | topic | A stream of information this event relates to. For message confirmation events, a separate event is emitted for each topic in the message. For blockchain events, the listener specifies the topic. Rules exist for how the topic is set for other event types | string | . | created | The time the event was emitted. Not guaranteed to be unique, or to increase between events in the same order as the final sequence events are delivered to your application. As such, the ‘sequence’ field should be used instead of the ‘created’ field for querying events in the exact order they are delivered to applications | FFTime | . ",
    "url": "/firefly/head/reference/types/event.html",
    "relUrl": "/reference/types/event.html"
  },"367": {
    "doc": "Event Bus",
    "title": "Event Bus",
    "content": " ",
    "url": "/firefly/head/reference/events.html",
    "relUrl": "/reference/events.html"
  },"368": {
    "doc": "Event Bus",
    "title": "Table of contents",
    "content": ". | Hyperledger FireFly Event Bus | Event-Driven Application Architecture | Decentralized Event Processing . | Example 1: A fungible token balance transfer | Example 2: A step in a multi-party business process | . | Privacy groups and late join | Event Types . | Blockchain events | Token events | . | Message events: on-chain / off-chain coordinated | Transaction submission events | . ",
    "url": "/firefly/head/reference/events.html#table-of-contents",
    "relUrl": "/reference/events.html#table-of-contents"
  },"369": {
    "doc": "Event Bus",
    "title": "Hyperledger FireFly Event Bus",
    "content": "The FireFly event bus provides your application with a single stream of events from all of the back-end services that plug into FireFly. Applications subscribe to these events using developer friendly protocols like WebSockets, and Webhooks. Additional transports and messaging systems like NATS, Kafka, and JMS Servers can be connected through plugins. Each application creates one or more Subscriptions to identify itself. In this subscription the application can choose to receive all events that are emitted within a namespace, or can use server-side filtering to only receive a sub-set of events. The event bus reliably keeps track of which events have been delivered to which applications, via an offset into the main event stream that is updated each time an application acknowledges receipt of events over its subscription. ",
    "url": "/firefly/head/reference/events.html#hyperledger-firefly-event-bus",
    "relUrl": "/reference/events.html#hyperledger-firefly-event-bus"
  },"370": {
    "doc": "Event Bus",
    "title": "Event-Driven Application Architecture",
    "content": "Decentralized applications are built around a source of truth that is shared between multiple parties. No one party can change the state unilaterally, as their changes need to be processed in order with the other changes in the system. Each party processes requests to change shared state in the same order, against a common set of rules for what is allowed at that exact point in the processing. As a result everybody deterministically ends up with the same state at the end of the processing. This requires an event-driven programming model. You will find an event-driven model at the core of every blockchain Smart Contract technology. This event-driven approach is unavoidable regardless of how much of your business data &amp; logic can be directly stored/processed on-chain, vs. off-chain. So Hyperledger FireFly aims to provide you with the tools to easily manage this model throughout your decentralized application stack. Your back-end application should be structured for this event-driven paradigm, with an Event Handler constantly listening for events, applying a consistent State Machine to those events and applying the changes to your Application Database. FireFly comes with a built in event processor for Token transfers &amp; approvals, that implements this pattern to maintain balances, and transaction history in a rich query off-chain data cache. ",
    "url": "/firefly/head/reference/events.html#event-driven-application-architecture",
    "relUrl": "/reference/events.html#event-driven-application-architecture"
  },"371": {
    "doc": "Event Bus",
    "title": "Decentralized Event Processing",
    "content": "In a decentralized system, you need to consider that each organization runs its own applications, and has its own private database. At any given point in time different organizations will have slightly different views of what the most up to date information is - even for the blockchain state. As well as the agreed business logic, there will be private data and core system integration that are needed to process events as they happen. Some of this data might be received privately from other parties, over a secure communications channel (not the blockchain). The system must be eventually consistent across all parties for any business data/decision that those parties need to agree on. This happens by all parties processing the same events in the same order, and by applying the same business logic (for the parts of the business logic that are agreed). This means that when processing an event, a participant must have access to enough historical data/state to reach the same conclusion as everyone else. Let’s look at a couple of examples. Example 1: A fungible token balance transfer . You need to be able to verify the complete lineage of the tokens being spent, in order to know that they cannot be double spent anywhere in the network. This means the transaction must be backed by a blockchain verifiable by all participants on the network that could hold balances of that token. You might be able to use advanced cryptography (such as zero-knowledge proofs) to mask the participants in the trade, but the transaction themselves must be verifiable to everyone in a global sequence that prevents double spending. Example 2: A step in a multi-party business process . Here it is likely you want to restrict visibility of the data to just the parties directly involved in the business process. To come to a common agreement on outcome, the parties must know they are processing the same data in the same order. So at minimum a proof (a hash of the data) needs to “pinned” to a blockchain ledger visible to all participants involved in the process. You can then choose to put more processing on the blockchain, to enforce some critical rules in the business state machine that must be executed fairly to prevent one party from cheating the system. Such as that the highest bid is chosen in a competitive bidding process, or a minimum set of parties have voted agreement before a transaction is finalized. Other steps in the process might include human decision making, private data from the core systems of one member, or proprietary business logic that one member is not willing to share. These steps are “non-deterministic” - you cannot predict the outcome, nor be guaranteed to reproduce the same outcome with the same inputs in the future. The FireFly event bus is designed to make triggering these non-deterministic steps easy, while still allowing them to be part of the overall state machine of the business process. You need to take care that the system is designed so parties cannot cheat, and must follow the rules. How much of that rule enforcement needs to be executed on-chain vs. off-chain (backed by a deterministic order through the blockchain) is different for each use case. Remember that tokens provide a great set of building blocks for on-chain steps in your decentralized applications. Enterprise NFTs allow generation of a globally unique ID, and track ownership. Fungible tokens allow value transfer, and can be extended with smart contracts that to lock/unlock funds in “digital escrow” while complex off-chain agreement happens. ",
    "url": "/firefly/head/reference/events.html#decentralized-event-processing",
    "relUrl": "/reference/events.html#decentralized-event-processing"
  },"372": {
    "doc": "Event Bus",
    "title": "Privacy groups and late join",
    "content": "If a new participant needs to join into a business transaction that has already started, they must first “catch up” with the current state before they can play their part. In a real-world scenario they might not be allowed to see all the data that’s visible to the other parties, so it is common to create a new stream of communications that includes all of the existing parties, plus the new party, to continue the process. If you use the same blockchain to back both groups, then you can safely order business process steps that involve different parties across these overlapping groups of participants. Using a single Ethereum permissioned side-chain for example. Alternatively, you can create dedicated distributed ledgers (DLTs) for communication between these groups of participants. This can allow more logic and data to go on-chain directly, although you still must consider the fact that this data is immutable and can never be deleted. Using Hyperledger Fabric channels for example. On top of either type of ledger, FireFly provides a private Group construct to facilitate secure off-chain data exchanges, and to efficiently pin these communications to the blockchain in batches. These private data exchanges can also be coordinated with most sophisticated on-chain transactions, such as token transfers. ",
    "url": "/firefly/head/reference/events.html#privacy-groups-and-late-join",
    "relUrl": "/reference/events.html#privacy-groups-and-late-join"
  },"373": {
    "doc": "Event Bus",
    "title": "Event Types",
    "content": "FireFly provides a number of different types of events to your application, designed to allow you to build your application state machine quickly and reliably. All events in FireFly share a common base structure, regardless of their type. They are then linked (via a reference) to an object that contains detailed information. The categories of event your application can receive are as follows: . See the Core Resources/Event page for a full list of event types, and more details on the data you can expect for each type. Blockchain events . FireFly allows your application to subscribe to any event from a blockchain smart contract. In order for applications connected to the FireFly API to receive blockchain events from a smart contracts, a ContractListener fist must be created to instruct FireFly to listen to those events from the blockchain (via the blockchain plugin). Once you have configured the blockchain event listener, every event detected from the blockchain will result in a FireFly event delivered to your application of type blockchain_event_received. Check out the Custom Contracts Tutorial for a walk-through of how to set up listeners for the events from your smart contracts. FireFly automatically establishes listeners for some blockchain events: . | Events from the FireFly BatchPin contract that is used to pin identities, off-chain data broadcast and private messaging to the blockchain. | Events from Token contracts, for which a Token Pool has been configured. These events are detected indirectly via the token connector. | . Token events . FireFly provides a Wallet API, that is pluggable to multiple token implementations without needing to change your app. The pluggable API/Event interface allows all kinds of technical implementations of tokens to be fitted into a common framework. The following wallet operations are supported. These are universal to all token implementations - NFTs and fungible tokens alike: . | Mint | Burn | Transfer | Approve | . FireFly processes, indexes and stores the events associated with these actions, for any Token Pool that has been configured on the FireFly node. See Token Transfer and Token Approval for more information on the individual operations. The token connector is responsible for mapping from the raw Blockchain Events, to the FireFly model for tokens. Reference token connector implementations are provided for common interface standards implemented by tokens - like ERC-20, ERC-721 and ERC-115. A particular token contract might have many additional features that are unique to that contract, particularly around governance. For these you would use the Smart Contract features of FireFly to interact with the blockchain API and Events directly. ",
    "url": "/firefly/head/reference/events.html#event-types",
    "relUrl": "/reference/events.html#event-types"
  },"374": {
    "doc": "Event Bus",
    "title": "Message events: on-chain / off-chain coordinated",
    "content": "Event aggregation between data arriving off-chain, and the associated ordered proof/transaction events being confirmed on-chain, is a complex orchestration task. The universal order and additional transaction logic on-chain must be the source of truth for when and how an event is processed. However, that event cannot be processed until the off-chain private/broadcast data associated with that event is also available and verified against the on-chain hash of that additional data. They might arrive in any order, and no further events can be processed on that business transaction until the data is available. Multiple parties might be emitting events as part of the business transaction, and the outcome will only be assured to be the same by all parties if they process these events in the same order. Hyperledger FireFly handles this for you. Events related to a message are not emitted until both the on-chain and off-chain parts (including large binary attachments) are available+verified in your local FireFly node, and all previous messages on the same topic have been processed successfully by your application. Your application just needs to: . | Choose a suitable topic for your messages that determines the ordered stream it is part of. Such as a business transaction identifier. | Make sure the application does not acknowledge a message, until it has finished processing it. | . See Message for more information . ",
    "url": "/firefly/head/reference/events.html#message-events-on-chain--off-chain-coordinated",
    "relUrl": "/reference/events.html#message-events-on-chain--off-chain-coordinated"
  },"375": {
    "doc": "Event Bus",
    "title": "Transaction submission events",
    "content": "These events are emitted each time a new transaction is initiated via the Firefly API. These events are only emitted on the local FireFly node that initiates an activity. For more information about FireFly Transactions, and how they relate to blockchain transactions, see Transaction. ",
    "url": "/firefly/head/reference/events.html#transaction-submission-events",
    "relUrl": "/reference/events.html#transaction-submission-events"
  },"376": {
    "doc": "Listen for events",
    "title": "Listen for events",
    "content": " ",
    "url": "/firefly/head/tutorials/events.html",
    "relUrl": "/tutorials/events.html"
  },"377": {
    "doc": "Listen for events",
    "title": "Table of contents",
    "content": ". | Quick reference | Additional info | WebSockets Example 1: Ephemeral subscription with auto-commit | Example event payload | Download the message and data | Download just the data array associated with a message | WebSockets Example 2: Durable subscription for your application, with manual-commit . | Set up the WebSocket subscription | Connect to consume messages | . | Custom Contract Events | . ",
    "url": "/firefly/head/tutorials/events.html#table-of-contents",
    "relUrl": "/tutorials/events.html#table-of-contents"
  },"378": {
    "doc": "Listen for events",
    "title": "Quick reference",
    "content": "Probably the most important aspect of FireFly is that it is an event-driven programming model. Parties interact by sending messages and transactions to each other, on and off chain. Once aggregated and confirmed those events drive processing in the other party. This allows orchestration of complex multi-party system applications and business processes. FireFly provides each party with their own private history, that includes all exchanges outbound and inbound performed through the node into the multi-party system. That includes blockchain backed transactions, as well as completely off-chain message exchanges. The event transports are pluggable. The core transports are WebSockets and Webhooks. We focus on WebSockets in this getting started guide. Check out the Request/Reply section for more information on Webhooks . ",
    "url": "/firefly/head/tutorials/events.html#quick-reference",
    "relUrl": "/tutorials/events.html#quick-reference"
  },"379": {
    "doc": "Listen for events",
    "title": "Additional info",
    "content": ". | Key Concepts: Multi-party process flow | Reference: coming soon | . ",
    "url": "/firefly/head/tutorials/events.html#additional-info",
    "relUrl": "/tutorials/events.html#additional-info"
  },"380": {
    "doc": "Listen for events",
    "title": "WebSockets Example 1: Ephemeral subscription with auto-commit",
    "content": "The simplest way to get started consuming events, is with an ephemeral WebSocket listener. Example connection URL: . ws://localhost:5000/ws?namespace=default&amp;ephemeral&amp;autoack&amp;filter.events=message_confirmed . | namespace=default - event listeners are scoped to a namespace | ephemeral - listen for events that occur while this connection is active, but do not remember the app instance (great for UIs) | autoack- automatically acknowledge each event, so the next event is sent (great for UIs) | filter.events=message_confirmed - only listen for events resulting from a message confirmation | . There are a number of browser extensions that let you experiment with WebSockets: . ",
    "url": "/firefly/head/tutorials/events.html#websockets-example-1-ephemeral-subscription-with-auto-commit",
    "relUrl": "/tutorials/events.html#websockets-example-1-ephemeral-subscription-with-auto-commit"
  },"381": {
    "doc": "Listen for events",
    "title": "Example event payload",
    "content": "The events (by default) do not contain the payload data, just the event and referred message. This means the WebSocket payloads are a predictably small size, and the application can use the information in the message to post-filter the event to decide if it needs to download the full data. There are server-side filters provided on events as well . { \"id\": \"8f0da4d7-8af7-48da-912d-187979bf60ed\", \"sequence\": 61, \"type\": \"message_confirmed\", \"namespace\": \"default\", \"reference\": \"9710a350-0ba1-43c6-90fc-352131ce818a\", \"created\": \"2021-07-02T04:37:47.6556589Z\", \"subscription\": { \"id\": \"2426c5b1-ffa9-4f7d-affb-e4e541945808\", \"namespace\": \"default\", \"name\": \"2426c5b1-ffa9-4f7d-affb-e4e541945808\" }, \"message\": { \"header\": { \"id\": \"9710a350-0ba1-43c6-90fc-352131ce818a\", \"type\": \"broadcast\", \"txtype\": \"batch_pin\", \"author\": \"0x1d14b65d2dd5c13f6cb6d3dc4aa13c795a8f3b28\", \"created\": \"2021-07-02T04:37:40.1257944Z\", \"namespace\": \"default\", \"topic\": [ \"default\" ], \"datahash\": \"cd6a09a15ccd3e6ed1d67d69fa4773b563f27f17f3eaad611a2792ba945ca34f\" }, \"hash\": \"1b6808d2b95b418e54e7bd34593bfa36a002b841ac42f89d00586dac61e8df43\", \"batchID\": \"16ffc02c-8cb0-4e2f-8b58-a707ad1d1eae\", \"state\": \"confirmed\", \"confirmed\": \"2021-07-02T04:37:47.6548399Z\", \"data\": [ { \"id\": \"b3a814cc-17d1-45d5-975e-90279ed2c3fc\", \"hash\": \"9ddefe4435b21d901439e546d54a14a175a3493b9fd8fbf38d9ea6d3cbf70826\" } ] } } . ",
    "url": "/firefly/head/tutorials/events.html#example-event-payload",
    "relUrl": "/tutorials/events.html#example-event-payload"
  },"382": {
    "doc": "Listen for events",
    "title": "Download the message and data",
    "content": "A simple REST API is provided to allow you to download the data associated with the message: . GET /api/v1/namespaces/default/messages/{id}?data=true . ",
    "url": "/firefly/head/tutorials/events.html#download-the-message-and-data",
    "relUrl": "/tutorials/events.html#download-the-message-and-data"
  },"383": {
    "doc": "Listen for events",
    "title": "Download just the data array associated with a message",
    "content": "As you already have the message object in the event delivery, you can query just the array of data objects as follows: . GET /api/v1/namespaces/default/messages/{id}/data . ",
    "url": "/firefly/head/tutorials/events.html#download-just-the-data-array-associated-with-a-message",
    "relUrl": "/tutorials/events.html#download-just-the-data-array-associated-with-a-message"
  },"384": {
    "doc": "Listen for events",
    "title": "WebSockets Example 2: Durable subscription for your application, with manual-commit",
    "content": "To reliably process messages within your application, you should first set up a subscription. A subscription requests that: . | FireFly keeps a record of the latest event consumed by that application | FireFly only delivers one copy of the event to the application, even when there are multiple active connections | . This should be combined with manual acknowledgment of the events, where the application sends a payload such as the following in response to each event it receives (where the id comes from the event it received): . { \"type\": \"ack\", \"id\": \"617db63-2cf5-4fa3-8320-46150cbb5372\" } . You must send an acknowledgement for every message, or you will stop receiving messages. Set up the WebSocket subscription . Each subscription is scoped to a namespace, and must have a name. You can then choose to perform server-side filtering on the events using regular expressions matched against the information in the event. POST /namespaces/default/subscriptions . { \"transport\": \"websockets\", \"name\": \"app1\", \"filter\": { \"blockchainevent\": { \"listener\": \".*\", \"name\": \".*\" }, \"events\": \".*\", \"message\": { \"author\": \".*\", \"group\": \".*\", \"tag\": \".*\", \"topics\": \".*\" }, \"transaction\": { \"type\": \".*\" } }, \"options\": { \"firstEvent\": \"newest\", \"readAhead\": 50 } } . Connect to consume messages . Example connection URL: . ws://localhost:5000/ws?namespace=default&amp;name=app1 . | namespace=default - event listeners are scoped to a namespace | name=app1 - the subscription name | . ",
    "url": "/firefly/head/tutorials/events.html#websockets-example-2-durable-subscription-for-your-application-with-manual-commit",
    "relUrl": "/tutorials/events.html#websockets-example-2-durable-subscription-for-your-application-with-manual-commit"
  },"385": {
    "doc": "Listen for events",
    "title": "Custom Contract Events",
    "content": "If you are interested in learning more about events for custom smart contracts, please see the Working with custom smart contracts section. ",
    "url": "/firefly/head/tutorials/events.html#custom-contract-events",
    "relUrl": "/tutorials/events.html#custom-contract-events"
  },"386": {
    "doc": "Fabric",
    "title": "Work with Hyperledger Fabric chaincodes",
    "content": "This guide describes the steps to deploy a chaincode to a Hyperledger Fabric blockchain and use FireFly to interact with it in order to submit transactions, query for states and listening for events. NOTE: This guide assumes that you are running a local FireFly stack with at least 2 members and a Fabric blockchain created by the FireFly CLI. If you need help getting that set up, please see the Getting Started guide to Start your environment. ",
    "url": "/firefly/head/tutorials/custom_contracts/fabric.html#work-with-hyperledger-fabric-chaincodes",
    "relUrl": "/tutorials/custom_contracts/fabric.html#work-with-hyperledger-fabric-chaincodes"
  },"387": {
    "doc": "Fabric",
    "title": "Table of contents",
    "content": ". | Example smart contract | Create the chaincode package | Contract deployment | The FireFly Interface Format . | Input parameters | Return values | Event payloads | . | Broadcast the contract interface . | Request | Response | . | Create an HTTP API for the contract . | Request | Response | . | View OpenAPI spec for the contract . | /invoke/* endpoints | /query/* endpoints | . | Invoke the chaincode . | Request | Response | . | Query the current state . | Request | Response | . | Create a blockchain event listener . | Request | Response | . | Subscribe to events from our contract . | Request | Response | . | Receive custom smart contract events . | WebSocket event | . | . ",
    "url": "/firefly/head/tutorials/custom_contracts/fabric.html#table-of-contents",
    "relUrl": "/tutorials/custom_contracts/fabric.html#table-of-contents"
  },"388": {
    "doc": "Fabric",
    "title": "Example smart contract",
    "content": "For this tutorial, we will be using a well known, but slightly modified smart contract called asset_transfer. It’s based on the asset-transfer-basic chaincode in the fabric-samples project. Check out the code repository and use the source code provided below to replace part of the content of the file fabric-samples/asset-transfer-basic/chaincode-go/chaincode/smartcontract.go. Find the following return statement in the function CreateAsset: . return ctx.GetStub().PutState(id, assetJSON) . and replace it with the following, so that an event will be emitted when the transaction is committed to the channel ledger: . err = ctx.GetStub().PutState(id, assetJSON) if err != nil { return err } return ctx.GetStub().SetEvent(\"AssetCreated\", assetJSON) . ",
    "url": "/firefly/head/tutorials/custom_contracts/fabric.html#example-smart-contract",
    "relUrl": "/tutorials/custom_contracts/fabric.html#example-smart-contract"
  },"389": {
    "doc": "Fabric",
    "title": "Create the chaincode package",
    "content": "Use the peer command to create the chaincode package for deployment. You can download the peer binary from the releases page of the Fabric project or build it from source. ~ johndoe$ cd fabric-samples/asset-transfer-basic/chaincode-go chaincode-go johndoe$ touch core.yaml chaincode-go johndoe$ peer lifecycle chaincode package -p . --label asset_transfer ./asset_transfer.zip . The peer command requires an empty core.yaml file to be present in the working directory to perform the packaging. That’s what touch core.yaml did above . The resulting asset_transfer.zip archive file will be used in the next step to deploy to the Fabric network used in FireFly. ",
    "url": "/firefly/head/tutorials/custom_contracts/fabric.html#create-the-chaincode-package",
    "relUrl": "/tutorials/custom_contracts/fabric.html#create-the-chaincode-package"
  },"390": {
    "doc": "Fabric",
    "title": "Contract deployment",
    "content": "Deployment of smart contracts is not currently within the scope of responsibility for FireFly. You can use your standard blockchain specific tools to deploy your contract to the blockchain you are using. The FireFly CLI provides a convenient function to deploy a chaincode package to a local FireFly stack. NOTE: The contract deployment function of the FireFly CLI is a convenience function to speed up local development, and not intended for production applications . ~ johndoe$ ff help deploy fabric Deploy a packaged chaincode to the Fabric network used by a FireFly stack Usage: ff deploy fabric &lt;stack_name&gt; &lt;chaincode_package&gt; &lt;channel&gt; &lt;chaincodeName&gt; &lt;version&gt; [flags] . Notice the various parameters used by the command ff deploy fabric. We’ll tell the FireFly to deploy using the following parameter values, if your stack setup is different, update the command accordingly: . | stack name: dev | channel: firefly (this is the channel that is created by the FireFly CLI when bootstrapping the stack, replace if you use a different channel in your setup) | chaincode name: asset_transfer (must match the value of the --label parameter when creating the chaincode package) | version: 1.0 | . $ ff deploy fabric dev asset_transfer.zip firefly asset_transfer 1.0 installing chaincode querying installed chaincode approving chaincode committing chaincode { \"chaincode\": \"asset_transfer\", \"channel\": \"firefly\" } . ",
    "url": "/firefly/head/tutorials/custom_contracts/fabric.html#contract-deployment",
    "relUrl": "/tutorials/custom_contracts/fabric.html#contract-deployment"
  },"391": {
    "doc": "Fabric",
    "title": "The FireFly Interface Format",
    "content": "In order to teach FireFly how to interact with the chaincode, a FireFly Interface (FFI) document is needed. While Ethereum (or other EVM based blockchains) requires an Application Binary Interface (ABI) to govern the interaction between the client and the smart contract, which is specific to each smart contract interface design, Fabric defines a generic chaincode interface and leaves the encoding and decoding of the parameter values to the discretion of the chaincode developer. As a result, the FFI document for a Fabric chaincode must be hand-crafted. The following FFI sample demonstrates the specification for the following common cases: . | structured JSON, used here for the list of chaincode function CreateAsset input parameters | array of JSON, used here for the chaincode function GetAllAssets output | structured JSON, used here for the list of chaincode event AssetCreated properties | . { \"namespace\": \"default\", \"name\": \"asset_transfer\", \"description\": \"Spec interface for the asset-transfer-basic golang chaincode\", \"version\": \"1.0\", \"methods\": [ { \"name\": \"GetAllAssets\", \"pathname\": \"\", \"description\": \"\", \"params\": [], \"returns\": [ { \"name\": \"\", \"schema\": { \"type\": \"array\", \"details\": { \"type\": \"object\", \"properties\": { \"type\": \"string\" } } } } ] }, { \"name\": \"CreateAsset\", \"pathname\": \"\", \"description\": \"\", \"params\": [ { \"name\": \"id\", \"schema\": { \"type\": \"string\" } }, { \"name\": \"color\", \"schema\": { \"type\": \"string\" } }, { \"name\": \"size\", \"schema\": { \"type\": \"string\" } }, { \"name\": \"owner\", \"schema\": { \"type\": \"string\" } }, { \"name\": \"value\", \"schema\": { \"type\": \"string\" } } ], \"returns\": [] } ], \"events\": [ { \"name\": \"AssetCreated\" } ] } . Input parameters . For the params section of the CreateAsset function, it is critical that the sequence of the properties (id, color, size, owner, value) matches the order of the input parameters in the chaincode’s function signature: . func CreateAsset(ctx contractapi.TransactionContextInterface, id string, color string, size int, owner string, appraisedValue int) error . Return values . FireFly can automatically decode JSON payloads in the return values. That’s why the returns section of the GetAllAssets function only needs to specify the type as array of objects, without having to specify the detailed structure of the JSON payload. On the other hand, if certain properties of the returned value are to be hidden, then you can provide a detailed structure of the JSON object with the desired properties. This is demonstrated in the JSON structure for the event payload, see below, where the property AppraisedValue is omitted from the output. Event payloads . For events, FireFly automatically decodes JSON payloads. If the event payload is not JSON, base64 encoded bytes will be returned instead. For the events section of the FFI, only the name property needs to be specified. ",
    "url": "/firefly/head/tutorials/custom_contracts/fabric.html#the-firefly-interface-format",
    "relUrl": "/tutorials/custom_contracts/fabric.html#the-firefly-interface-format"
  },"392": {
    "doc": "Fabric",
    "title": "Broadcast the contract interface",
    "content": "Now that we have a FireFly Interface representation of our chaincode, we want to broadcast that to the entire network. This broadcast will be pinned to the blockchain, so we can always refer to this specific name and version, and everyone in the network will know exactly which contract interface we are talking about. We will use the FFI JSON constructed above and POST that to the /contracts/interfaces API endpoint. Request . POST http://localhost:5000/api/v1/namespaces/default/contracts/interfaces . { \"namespace\": \"default\", \"name\": \"asset_transfer\", \"description\": \"Spec interface for the asset-transfer-basic golang chaincode\", \"version\": \"1.0\", \"methods\": [ { \"name\": \"GetAllAssets\", \"pathname\": \"\", \"description\": \"\", \"params\": [], \"returns\": [ { \"name\": \"\", \"schema\": { \"type\": \"array\", \"details\": { \"type\": \"object\", \"properties\": { \"type\": \"string\" } } } } ] }, { \"name\": \"CreateAsset\", \"pathname\": \"\", \"description\": \"\", \"params\": [ { \"name\": \"id\", \"schema\": { \"type\": \"string\" } }, { \"name\": \"color\", \"schema\": { \"type\": \"string\" } }, { \"name\": \"size\", \"schema\": { \"type\": \"string\" } }, { \"name\": \"owner\", \"schema\": { \"type\": \"string\" } }, { \"name\": \"value\", \"schema\": { \"type\": \"string\" } } ], \"returns\": [] } ], \"events\": [ { \"name\": \"AssetCreated\" } ] } . Response . { \"id\": \"f1e5522c-59a5-4787-bbfd-89975e5b0954\", \"message\": \"8a01fc83-5729-418b-9706-6fc17c8d2aac\", \"namespace\": \"default\", \"name\": \"asset_transfer\", \"description\": \"Spec interface for the asset-transfer-basic golang chaincode\", \"version\": \"1.1\", \"methods\": [ { \"id\": \"b31e3623-35e8-4918-bf8c-1b0d6c01de25\", \"interface\": \"f1e5522c-59a5-4787-bbfd-89975e5b0954\", \"name\": \"GetAllAssets\", \"namespace\": \"default\", \"pathname\": \"GetAllAssets\", \"description\": \"\", \"params\": [], \"returns\": [ { \"name\": \"\", \"schema\": { \"type\": \"array\", \"details\": { \"type\": \"object\", \"properties\": { \"type\": \"string\" } } } } ] }, { \"id\": \"e5a170d1-0be1-4697-800b-f4bcfaf71cf6\", \"interface\": \"f1e5522c-59a5-4787-bbfd-89975e5b0954\", \"name\": \"CreateAsset\", \"namespace\": \"default\", \"pathname\": \"CreateAsset\", \"description\": \"\", \"params\": [ { \"name\": \"id\", \"schema\": { \"type\": \"string\" } }, { \"name\": \"color\", \"schema\": { \"type\": \"string\" } }, { \"name\": \"size\", \"schema\": { \"type\": \"string\" } }, { \"name\": \"owner\", \"schema\": { \"type\": \"string\" } }, { \"name\": \"value\", \"schema\": { \"type\": \"string\" } } ], \"returns\": [] } ], \"events\": [ { \"id\": \"27564533-30bd-4536-884e-02e5d79ec238\", \"interface\": \"f1e5522c-59a5-4787-bbfd-89975e5b0954\", \"namespace\": \"default\", \"pathname\": \"AssetCreated\", \"signature\": \"\", \"name\": \"AssetCreated\", \"description\": \"\", \"params\": null } ] } . NOTE: We can broadcast this contract interface conveniently with the help of FireFly Sandbox running at http://127.0.0.1:5108 . | Go to the Contracts Section | Click on Define a Contract Interface | Select FFI - FireFly Interface in the Interface Fromat dropdown | Copy the FFI JSON crafted by you into the Schema Field | Click on Run | . ",
    "url": "/firefly/head/tutorials/custom_contracts/fabric.html#broadcast-the-contract-interface",
    "relUrl": "/tutorials/custom_contracts/fabric.html#broadcast-the-contract-interface"
  },"393": {
    "doc": "Fabric",
    "title": "Create an HTTP API for the contract",
    "content": "Now comes the fun part where we see some of the powerful, developer-friendly features of FireFly. The next thing we’re going to do is tell FireFly to build an HTTP API for this chaincode, complete with an OpenAPI Specification and Swagger UI. As part of this, we’ll also tell FireFly where the chaincode is on the blockchain. Like the interface broadcast above, this will also generate a broadcast which will be pinned to the blockchain so all the members of the network will be aware of and able to interact with this API. We need to copy the id field we got in the response from the previous step to the interface.id field in the request body below. We will also pick a name that will be part of the URL for our HTTP API, so be sure to pick a name that is URL friendly. In this case we’ll call it asset_transfer. Lastly, in the location field, we’re telling FireFly where an instance of the chaincode is deployed on-chain, which is a chaincode named asset_transfer in the channel firefly. NOTE: The location field is optional here, but if it is omitted, it will be required in every request to invoke or query the chaincode. This can be useful if you have multiple instances of the same chaincode deployed to different channels. Request . POST http://localhost:5000/api/v1/namespaces/default/apis . { \"name\": \"asset_transfer\", \"interface\": { \"id\": \"f1e5522c-59a5-4787-bbfd-89975e5b0954\" }, \"location\": { \"channel\": \"firefly\", \"chaincode\": \"asset_transfer\" } } . Response . { \"id\": \"a9a9ab4e-2544-45d5-8824-3c05074fbf75\", \"namespace\": \"default\", \"interface\": { \"id\": \"f1e5522c-59a5-4787-bbfd-89975e5b0954\" }, \"location\": { \"channel\": \"firefly\", \"chaincode\": \"asset_transfer\" }, \"name\": \"asset_transfer\", \"message\": \"5f1556a1-5cb1-4bc6-8611-d8f88ccf9c30\", \"urls\": { \"openapi\": \"http://127.0.0.1:5000/api/v1/namespaces/default/apis/asset_transfer/api/swagger.json\", \"ui\": \"http://127.0.0.1:5000/api/v1/namespaces/default/apis/asset_transfer/api\" } } . NOTE: We can create this Http API conveniently with the help of FireFly Sandbox running at http://127.0.0.1:5108 . | Go to the Contracts Section | Click on Register a Contract API | Select the name of your broadcasted FFI in the Contract Interface dropdown | In the Name Field, give a name that will be part of the URL for your Http API | In the Chaincode Field, give your chaincode name for which you wrote the FFI | In the Channel Field, give the channel name where your chaincode is deployed | Click on Run | . ",
    "url": "/firefly/head/tutorials/custom_contracts/fabric.html#create-an-http-api-for-the-contract",
    "relUrl": "/tutorials/custom_contracts/fabric.html#create-an-http-api-for-the-contract"
  },"394": {
    "doc": "Fabric",
    "title": "View OpenAPI spec for the contract",
    "content": "You’ll notice in the response body that there are a couple of URLs near the bottom. If you navigate to the one labeled ui in your browser, you should see the Swagger UI for your chaincode. /invoke/* endpoints . The /invoke endpoints in the generated API are for submitting transactions. These endpoints will be mapped to the POST /transactions endpoint of the FabConnect API. /query/* endpoints . The /query endpoints in the generated API, on the other hand, are for sending query requests. These endpoints will be mapped to the POST /query endpoint of the Fabconnect API, which under the cover only sends chaincode endorsement requests to the target peer node without sending a trasaction payload to the orderer node. ",
    "url": "/firefly/head/tutorials/custom_contracts/fabric.html#view-openapi-spec-for-the-contract",
    "relUrl": "/tutorials/custom_contracts/fabric.html#view-openapi-spec-for-the-contract"
  },"395": {
    "doc": "Fabric",
    "title": "Invoke the chaincode",
    "content": "Now that we’ve got everything set up, it’s time to use our chaincode! We’re going to make a POST request to the invoke/CreateAsset endpoint to create a new asset. Request . POST http://localhost:5000/api/v1/namespaces/default/apis/asset_transfer/invoke/CreateAsset . { \"input\": { \"color\": \"blue\", \"id\": \"asset-01\", \"owner\": \"Harry\", \"size\": \"30\", \"value\": \"23400\" } } . Response . { \"id\": \"b8e905cc-bc23-434a-af7d-13c6d85ae545\", \"namespace\": \"default\", \"tx\": \"79d2668e-4626-4634-9448-1b40fa0d9dfd\", \"type\": \"blockchain_invoke\", \"status\": \"Pending\", \"plugin\": \"fabric\", \"input\": { \"input\": { \"color\": \"blue\", \"id\": \"asset-02\", \"owner\": \"Harry\", \"size\": \"30\", \"value\": \"23400\" }, \"interface\": \"f1e5522c-59a5-4787-bbfd-89975e5b0954\", \"key\": \"Org1MSP::x509::CN=org_0,OU=client::CN=fabric_ca.org1.example.com,OU=Hyperledger FireFly,O=org1.example.com,L=Raleigh,ST=North Carolina,C=US\", \"location\": { \"chaincode\": \"asset_transfer\", \"channel\": \"firefly\" }, \"method\": { \"description\": \"\", \"id\": \"e5a170d1-0be1-4697-800b-f4bcfaf71cf6\", \"interface\": \"f1e5522c-59a5-4787-bbfd-89975e5b0954\", \"name\": \"CreateAsset\", \"namespace\": \"default\", \"params\": [ { \"name\": \"id\", \"schema\": { \"type\": \"string\" } }, { \"name\": \"color\", \"schema\": { \"type\": \"string\" } }, { \"name\": \"size\", \"schema\": { \"type\": \"string\" } }, { \"name\": \"owner\", \"schema\": { \"type\": \"string\" } }, { \"name\": \"value\", \"schema\": { \"type\": \"string\" } } ], \"pathname\": \"CreateAsset\", \"returns\": [] }, \"methodPath\": \"CreateAsset\", \"type\": \"invoke\" }, \"created\": \"2022-05-02T17:08:40.811630044Z\", \"updated\": \"2022-05-02T17:08:40.811630044Z\" } . You’ll notice that we got an ID back with status Pending, and that’s expected due to the asynchronous programming model of working with custom onchain logic in FireFly. To see what the latest state is now, we can query the chaincode. In a little bit, we’ll also subscribe to the events emitted by this chaincode so we can know when the state is updated in realtime. ",
    "url": "/firefly/head/tutorials/custom_contracts/fabric.html#invoke-the-chaincode",
    "relUrl": "/tutorials/custom_contracts/fabric.html#invoke-the-chaincode"
  },"396": {
    "doc": "Fabric",
    "title": "Query the current state",
    "content": "To make a read-only request to the blockchain to check the current list of assets, we can make a POST to the query/GetAllAssets endpoint. Request . POST http://localhost:5000/api/v1/namespaces/default/apis/asset_transfer/query/GetAllAssets . {} . Response . [ { \"AppraisedValue\": 23400, \"Color\": \"blue\", \"ID\": \"asset-01\", \"Owner\": \"Harry\", \"Size\": 30 } ] . NOTE: Some chaincodes may have queries that require input parameters. That’s why the query endpoint is a POST, rather than a GET so that parameters can be passed as JSON in the request body. This particular function does not have any parameters, so we just pass an empty JSON object. ",
    "url": "/firefly/head/tutorials/custom_contracts/fabric.html#query-the-current-state",
    "relUrl": "/tutorials/custom_contracts/fabric.html#query-the-current-state"
  },"397": {
    "doc": "Fabric",
    "title": "Create a blockchain event listener",
    "content": "Now that we’ve seen how to submit transactions and preform read-only queries to the blockchain, let’s look at how to receive blockchain events so we know when things are happening in realtime. If you look at the source code for the smart contract we’re working with above, you’ll notice that it emits an event when a new asset is created. In order to receive these events, we first need to instruct FireFly to listen for this specific type of blockchain event. To do this, we create an Event Listener. The /contracts/listeners endpoint is RESTful so there are POST, GET, and DELETE methods available on it. To create a new listener, we will make a POST request. We are going to tell FireFly to listen to events with name \"AssetCreated\" from the FireFly Interface we defined earlier, referenced by its ID. We will also tell FireFly which channel and chaincode we expect to emit these events. Request . POST http://localhost:5000/api/v1/namespaces/default/contracts/listeners . { \"interface\": { \"id\": \"f1e5522c-59a5-4787-bbfd-89975e5b0954\" }, \"location\": { \"channel\": \"firefly\", \"chaincode\": \"asset_transfer\" }, \"event\": { \"name\": \"AssetCreated\" }, \"options\": { \"firstEvent\": \"oldest\" }, \"topic\": \"assets\" } . Response . { \"id\": \"6e7f5dd8-5a57-4163-a1d2-5654e784dc31\", \"namespace\": \"default\", \"name\": \"sb-2cac2bfa-38af-4408-4ff3-973421410e5d\", \"backendId\": \"sb-2cac2bfa-38af-4408-4ff3-973421410e5d\", \"location\": { \"channel\": \"firefly\", \"chaincode\": \"asset_transfer\" }, \"created\": \"2022-05-02T17:19:13.144561086Z\", \"event\": { \"name\": \"AssetCreated\", \"description\": \"\", \"params\": null }, \"signature\": \"AssetCreated\", \"topic\": \"assets\", \"options\": { \"firstEvent\": \"oldest\" } } . ",
    "url": "/firefly/head/tutorials/custom_contracts/fabric.html#create-a-blockchain-event-listener",
    "relUrl": "/tutorials/custom_contracts/fabric.html#create-a-blockchain-event-listener"
  },"398": {
    "doc": "Fabric",
    "title": "Subscribe to events from our contract",
    "content": "Now that we’ve told FireFly that it should listen for specific events on the blockchain, we can set up a Subscription for FireFly to send events to our client app. To set up our subscription, we will make a POST to the /subscriptions endpoint. We will set a friendly name asset_transfer to identify the Subscription when we are connecting to it in the next step. We’re also going to set up a filter to only send events blockchain events from our listener that we created in the previous step. To do that, we’ll copy the listener ID from the step above (6e7f5dd8-5a57-4163-a1d2-5654e784dc31) and set that as the value of the listener field in the example below: . Request . POST http://localhost:5000/api/v1/namespaces/default/subscriptions . { \"namespace\": \"default\", \"name\": \"asset_transfer\", \"transport\": \"websockets\", \"filter\": { \"events\": \"blockchain_event_received\", \"blockchainevent\": { \"listener\": \"6e7f5dd8-5a57-4163-a1d2-5654e784dc31\" } }, \"options\": { \"firstEvent\": \"oldest\" } } . Response . { \"id\": \"06d18b49-e763-4f5c-9e97-c25024fe57c8\", \"namespace\": \"default\", \"name\": \"asset_transfer\", \"transport\": \"websockets\", \"filter\": { \"events\": \"blockchain_event_received\", \"message\": {}, \"transaction\": {}, \"blockchainevent\": { \"listener\": \"6e7f5dd8-5a57-4163-a1d2-5654e784dc31\" } }, \"options\": { \"firstEvent\": \"-1\", \"withData\": false }, \"created\": \"2022-05-02T17:22:06.480181291Z\", \"updated\": null } . ",
    "url": "/firefly/head/tutorials/custom_contracts/fabric.html#subscribe-to-events-from-our-contract",
    "relUrl": "/tutorials/custom_contracts/fabric.html#subscribe-to-events-from-our-contract"
  },"399": {
    "doc": "Fabric",
    "title": "Receive custom smart contract events",
    "content": "The last step is to connect a WebSocket client to FireFly to receive the event. You can use any WebSocket client you like, such as Postman or a command line app like websocat. Connect your WebSocket client to ws://localhost:5000/ws. After connecting the WebSocket client, send a message to tell FireFly to: . | Start sending events | For the Subscription named asset_transfer | On the default namespace | Automatically “ack” each event which will let FireFly immediately send the next event when available | . { \"type\": \"start\", \"name\": \"asset_transfer\", \"namespace\": \"default\", \"autoack\": true } . WebSocket event . After creating the subscription, you should see an event arrive on the connected WebSocket client that looks something like this: . { \"id\": \"d9fb86b2-b25b-43b8-80d3-936c5daa5a66\", \"sequence\": 29, \"type\": \"blockchain_event_received\", \"namespace\": \"default\", \"reference\": \"e0d670b4-a1b6-4efd-a985-06dfaaa58fe3\", \"topic\": \"assets\", \"created\": \"2022-05-02T17:26:57.57612001Z\", \"blockchainEvent\": { \"id\": \"e0d670b4-a1b6-4efd-a985-06dfaaa58fe3\", \"source\": \"fabric\", \"namespace\": \"default\", \"name\": \"AssetCreated\", \"listener\": \"6e7f5dd8-5a57-4163-a1d2-5654e784dc31\", \"protocolId\": \"000000000015/000000/000000\", \"output\": { \"AppraisedValue\": 12300, \"Color\": \"red\", \"ID\": \"asset-01\", \"Owner\": \"Jerry\", \"Size\": 10 }, \"info\": { \"blockNumber\": 15, \"chaincodeId\": \"asset_transfer\", \"eventIndex\": 0, \"eventName\": \"AssetCreated\", \"subId\": \"sb-2cac2bfa-38af-4408-4ff3-973421410e5d\", \"timestamp\": 1651512414920972300, \"transactionId\": \"172637bf59a3520ca6dd02f716e1043ba080e10e1cd2f98b4e6b85abcc6a6d69\", \"transactionIndex\": 0 }, \"timestamp\": \"2022-05-02T17:26:54.9209723Z\", \"tx\": { \"type\": \"\", \"blockchainId\": \"172637bf59a3520ca6dd02f716e1043ba080e10e1cd2f98b4e6b85abcc6a6d69\" } }, \"subscription\": { \"id\": \"06d18b49-e763-4f5c-9e97-c25024fe57c8\", \"namespace\": \"default\", \"name\": \"asset_transfer\" } } . You can see in the event received over the WebSocket connection, the blockchain event that was emitted from our first transaction, which happened in the past. We received this event, because when we set up both the Listener, and the Subscription, we specified the \"firstEvent\" as \"oldest\". This tells FireFly to look for this event from the beginning of the blockchain, and that your app is interested in FireFly events since the beginning of FireFly’s event history. In the event, we can also see the blockchainEvent itself, which has an output object. This contains the event payload that was set by the chaincode. ",
    "url": "/firefly/head/tutorials/custom_contracts/fabric.html#receive-custom-smart-contract-events",
    "relUrl": "/tutorials/custom_contracts/fabric.html#receive-custom-smart-contract-events"
  },"400": {
    "doc": "Fabric",
    "title": "Fabric",
    "content": " ",
    "url": "/firefly/head/tutorials/custom_contracts/fabric.html",
    "relUrl": "/tutorials/custom_contracts/fabric.html"
  },"401": {
    "doc": "pages.remote_fabric_network",
    "title": "Work with remote Hyperledger Fabric Network",
    "content": "The FireFly CLI makes it quick and easy to create an entire FireFly development environment on your local machine, including a new blockchain from scratch. However, sometimes a developer may want to connect their local FireFly development environment to a Fabric network that already exists on their machine or elsewhere. This guide describes the steps to connect FireFly to an external Hyperledger Fabric blockchain network (not created by the FireFly CLI), including interacting with a custom chaincode in order to submit transactions and query for state. NOTE: This guide assumes that you are already running a Hyperledger Fabric blockchain network and have a chaicode deployed in that network that you want to connect to with FireFly. ",
    "url": "/firefly/head/tutorials/chains/fabric_remote.html#work-with-remote-hyperledger-fabric-network",
    "relUrl": "/tutorials/chains/fabric_remote.html#work-with-remote-hyperledger-fabric-network"
  },"402": {
    "doc": "pages.remote_fabric_network",
    "title": "Table of contents",
    "content": ". | Creating a FireFly stack with Fabric provider | Configuring the stack to connect to your remote Fabric network . | Add msp folder representing your fabric identity | Edit your fabric connection profile (ccp.yml) | . | Setting up Batchpin chaincode and running your stack . | Deploying batchpin chaincode to fabric network | Update batchpin chaincode details in firefly core config | Starting your FireFly stack | . | Integrate your FireFly stack with your Fabric chaincode | . ",
    "url": "/firefly/head/tutorials/chains/fabric_remote.html#table-of-contents",
    "relUrl": "/tutorials/chains/fabric_remote.html#table-of-contents"
  },"403": {
    "doc": "pages.remote_fabric_network",
    "title": "Creating a FireFly stack with Fabric provider",
    "content": "In the ff init command, pass fabric in the -b flag to select fabric as the blockchain provider. You can also pass an additional --prompt-names flag to give actual names for your organizations in the firefly setup. ff init -b fabric --prompt-names . Choose a stack name. For this guide, I will choose the name my-remote-fabric, but you can pick whatever you want. stack name: my-remote-fabric . For this guide, we will be creating only one supernode for one of the organizations in our fabric network and using that organizational identity to interact with the chaincode. You can create multiple supernodes for different organizations in your fabric network by passing here the number of members in your stack. number of members: 1 . Next, you will be prompted to enter a name for your organization and node. If you selected more than 1 member for your stack in the previous step, it will prompt you to give name for each member. For this guide, I will choose the name my-org and my-org-node, but you can pick whatever you want. name for org 0: my-org name for node 0: my-org-node . At the end of it, you will be greeted with something like : . Stack 'my-remote-fabric' created! To start your new stack run: ff start my-remote-fabric . Next, you need to edit your stack configuration before you run it. ",
    "url": "/firefly/head/tutorials/chains/fabric_remote.html#creating-a-firefly-stack-with-fabric-provider",
    "relUrl": "/tutorials/chains/fabric_remote.html#creating-a-firefly-stack-with-fabric-provider"
  },"404": {
    "doc": "pages.remote_fabric_network",
    "title": "Configuring the stack to connect to your remote Fabric network",
    "content": "Now that you have created a stack, let’s open it up in your favourite code editor to configure it further. By default, the path where it gets created in your system is $HOME/.firefly/stacks/my-remote-fabric. Add msp folder representing your fabric identity . In $HOME/.firefly/stacks/my-remote-fabric, you need to add a msp folder. This msp folder essentially describes the fabric organizational identity which will be interacting with your chaincode. Inside the msp folder, you must have all the certificates and the private key to be used by firefly to query/invoke your chaincode. You should be having this msp folder for an organizational identity from when you would have set up your fabric network. For more details, please refer to Hyperledger Fabric Documentation for MSP. Now, you need to mount this msp directory as a docker volume in your fabconnect service. NOTE: All docker-compose.yml related changes should be done in docker-compose.override.yml. For this, simply copy the fabconnect_0 service as it is from your docker-compose.yml and paste it in your docker-compose.override.yml. Next, in your docker-compose.override.yml, in the volumes section of the fabconnect_0 service, you need to add a new docker volume mapping your host’s msp directory to your fabconnect_0 docker container’s /etc/firefly/msp directory. It will look something like : . -/Users/&lt;username&gt;/.firefly/stacks/my-remote-fabric/msp:/etc/firefly/msp . Your docker-compose.override.yml file after editing should look something like : . # Add custom config overrides here # See https://docs.docker.com/compose/extends version: \"2.1\" services: fabconnect_0: container_name: my-remote-fabric_fabconnect_0 image: ghcr.io/hyperledger/firefly-fabconnect@sha256:0dff97610990414d8ceb24859ced7712fa18b71b1d22b6a6f46fd51266413a22 command: -f /fabconnect/fabconnect.yaml volumes: - fabconnect_receipts_0:/fabconnect/receipts - fabconnect_events_0:/fabconnect/events - /Users/&lt;username&gt;/.firefly/stacks/my-remote-fabric/runtime/blockchain/fabconnect.yaml:/fabconnect/fabconnect.yaml - /Users/&lt;username&gt;/.firefly/stacks/my-remote-fabric/runtime/blockchain/ccp.yaml:/fabconnect/ccp.yaml - /Users/&lt;username&gt;/.firefly/stacks/my-remote-fabric/msp:/etc/firefly/msp - firefly_fabric:/etc/firefly ports: - 5102:3000 depends_on: fabric_ca: condition: service_started fabric_orderer: condition: service_started fabric_peer: condition: service_started healthcheck: test: - CMD - wget - -O - '-' - http://localhost:3000/status logging: driver: json-file options: max-file: \"1\" max-size: 10m . NOTE: If you had multiple members in your stack, with each member representing a different fabric organizational entity, then you would need to add separate msp folders for all of them in a similar manner . Edit your fabric connection profile (ccp.yml) . In $HOME/.firefly/stacks/my-remote-fabric/init/blockchain, you will find a ccp.yml file which is mounted as a volume in our fabconnect service. This file is also commonly referred to as fabric connection profile. This ccp.yml file is written to connect to the default localhost containerized fabric network that is created by firefly CLI when you run your stack. You probably don’t want to connect to that network since you are viewing this guide. So what you need to do is : . | You need to edit this ccp.yml file and give your fabric network and client details here instead. | For the credentialStore/cryptoStore path or the cryptoconfig path in your ccp.yml, you need to provide the path of your msp folder in your fabconnect docker container : /etc/firefly/msp | For the certificates/key paths in your ccp.yml, you need to provide the paths of corresponding key/certificates in your msp folder in your fabconnect docker container :/etc/firefly/msp/&lt;path-to-cert-or-key&gt; | . Your ccp.yml file after editing should look something like : . certificateAuthorities: my-fabric-network-ca: tlsCACerts: path: /etc/firefly/msp/tlscacerts/tls-ca-cert.pem url: https://my-fabric-network-ca.my-domain.com:443 registrar: enrollId: my-enroll-id enrollSecret: my-enroll-secret channels: my-channel: orderers: - my-orderer-node peers: my-peer-node: chaincodeQuery: true endorsingPeer: true eventSource: true ledgerQuery: true client: BCCSP: security: default: provider: SW enabled: true hashAlgorithm: SHA2 level: 256 softVerify: true credentialStore: cryptoStore: path: /etc/firefly/msp path: /etc/firefly/msp cryptoconfig: path: /etc/firefly/msp logging: level: info organization: my-org tlsCerts: client: cert: path: /etc/firefly/msp/signcerts/cert.pem key: path: /etc/firefly/msp/keystore/key.pem orderers: my-orderer-node: tlsCACerts: path: /etc/firefly/msp/tlscacerts/tls-ca-cert.pem url: grpcs://my-orderer-node.my-domain.com:7050 organizations: my-org: certificateAuthorities: - my-fabric-network-ca cryptoPath: /etc/firefly/msp mspid: my-org-mspid peers: - my-peer-node peers: my-peer-node: tlsCACerts: path: /etc/firefly/msp/tlscacerts/tls-ca-cert.pem url: grpcs://my-peer-node.my-domain.com:7051 version: 1.1.0% . NOTE: If you had multiple members in your stack, with each member representing a different fabric organizational entity, then you would need to add separate ccp.yml files for all of them in a similar manner. ",
    "url": "/firefly/head/tutorials/chains/fabric_remote.html#configuring-the-stack-to-connect-to-your-remote-fabric-network",
    "relUrl": "/tutorials/chains/fabric_remote.html#configuring-the-stack-to-connect-to-your-remote-fabric-network"
  },"405": {
    "doc": "pages.remote_fabric_network",
    "title": "Setting up Batchpin chaincode and running your stack",
    "content": "Deploying batchpin chaincode to fabric network . For Firefly to succeesfully integrate and interact with your remote fabric network, you need to also deploy a Firefly batchpin chaincode in your network setup. This chaincode can be found in the FireFly git repo. Once you have successfully packaged, installed, approved and commited this chaincode in your remote fabric network, carefully note down the chaincode name you gave and the channel name where this chaincode is deployed for future reference. NOTE: You can deploy the batchpin chaincode to the same channel where your application chaincode lives or to a separate channel as well. Update batchpin chaincode details in firefly core config . In $HOME/.firefly/stacks/my-remote-fabric/init/config, you will find a firefly_core_0.yml file which is used by firefly core service in our firefly network setup. In this file, under the fabconnect section of blockchain-fabric section, you need to change the chaincode value to your batchpin chaincode name, and the channel value to the channel name where your batchpin chaincode was deployed in the previous step. Starting your FireFly stack . To start your stack now, simply run: . ff start my-remote-fabric . This may take a minute or two and in the background the FireFly CLI will do the following for you: . | Download Docker images for all the components of the Supernode | Set up configuration between all the components | Deploy FireFly’s BatchPin smart contract to our remote fabric network | Register an identity for each member and node in our remote fabric network | It will probably also initialize a new blockchain and blockchain node running inside a container and also deploy an ERC-1155 token smart contract to that local fabric network. This behaviour can be ignored. | . After your stack finishes starting it will print out the links to each member’s UI and the Sandbox for that node. For this guide, it’s just one member. Web UI for member '0': http://127.0.0.1:5000/ui Sandbox UI for member '0': http://127.0.0.1:5108 To see logs for your stack run: ff logs my-remote-fabric . ",
    "url": "/firefly/head/tutorials/chains/fabric_remote.html#setting-up-batchpin-chaincode-and-running-your-stack",
    "relUrl": "/tutorials/chains/fabric_remote.html#setting-up-batchpin-chaincode-and-running-your-stack"
  },"406": {
    "doc": "pages.remote_fabric_network",
    "title": "Integrate your FireFly stack with your Fabric chaincode",
    "content": "Once your stack is up and running, you can define and broadcast FireFly Interface Document for your remote fabric chaincode. You can refer to Broadcast the Contract Interface(Fabric) guide for this. You can also now create an HTTP API for your fabric chaincode which will help you easily query/invoke all your chaincode methods with your organizational context that you set up in fabconnect. You can refer to Create an HTTP API for the contract(Fabric) guide for this. To view the OpenAPI spec for your contract, or to submit transactions, query for states and listen for events, you can further refer to Work with Hyperledger Fabric chaincodes guide. ",
    "url": "/firefly/head/tutorials/chains/fabric_remote.html#integrate-your-firefly-stack-with-your-fabric-chaincode",
    "relUrl": "/tutorials/chains/fabric_remote.html#integrate-your-firefly-stack-with-your-fabric-chaincode"
  },"407": {
    "doc": "pages.remote_fabric_network",
    "title": "pages.remote_fabric_network",
    "content": " ",
    "url": "/firefly/head/tutorials/chains/fabric_remote.html",
    "relUrl": "/tutorials/chains/fabric_remote.html"
  },"408": {
    "doc": "pages.faqs",
    "title": "FAQs",
    "content": "Find answers to the most commonly asked FireFly questions. ",
    "url": "/firefly/head/faqs/faqs.html#faqs",
    "relUrl": "/faqs/faqs.html#faqs"
  },"409": {
    "doc": "pages.faqs",
    "title": "How does FireFly enable multi-chain applications?",
    "content": "It’s best to think about FireFly as a rich orchestration layer that sits one layer above the blockchain. FireFly helps to abstract away much of the complex blockchain functionality (such as data exchange, private messaging, common token functionality, etc) in a loosely coupled microservice architecture with highly pluggable components. This enables application developers to focus on building innovative Web3 applications. There aren’t any out of the box bridges to connect two separate chains together, but with a collection of FireFly instances across a consortium, FireFly could help listen for events on Blockchain A and take an action on Blockchain B when certain conditions are met. ",
    "url": "/firefly/head/faqs/faqs.html#how-does-firefly-enable-multi-chain-applications",
    "relUrl": "/faqs/faqs.html#how-does-firefly-enable-multi-chain-applications"
  },"410": {
    "doc": "pages.faqs",
    "title": "📜 How do I deploy smart contracts?",
    "content": "In order to interact with a smart contract on a public or private Ethereum chain you need to first deploy it to the chain. Deployment means that you’ve sent a transaction with the compiled source code to the chain without a specified recipient and received a contract address that you and others on the network can use to interact with your contract. Refer to the Smart Contract Tutorial for instructions to deploy a smart contract to your private networking using FireFly. ",
    "url": "/firefly/head/faqs/faqs.html#-how-do-i-deploy-smart-contracts",
    "relUrl": "/faqs/faqs.html#-how-do-i-deploy-smart-contracts"
  },"411": {
    "doc": "pages.faqs",
    "title": "🦊 Can I connect FireFly to MetaMask?",
    "content": "Yes! Before you set up MetaMask you’ll likely want to create some tokens that you can use to send between wallets on your FF network. Go to the tokens tab in your FireFly node’s UI, create a token pool, and then mint some tokens. Once you’ve done this, follow the steps listed here to set up MetaMask on your network. ",
    "url": "/firefly/head/faqs/faqs.html#-can-i-connect-firefly-to-metamask",
    "relUrl": "/faqs/faqs.html#-can-i-connect-firefly-to-metamask"
  },"412": {
    "doc": "pages.faqs",
    "title": "🚀 Connect with us on Discord",
    "content": "If your question isn’t answered here or if you have immediate questions please don’t hesitate to reach out to us on Discord in the firefly channel: . ",
    "url": "/firefly/head/faqs/faqs.html#-connect-with-us-on-discord",
    "relUrl": "/faqs/faqs.html#-connect-with-us-on-discord"
  },"413": {
    "doc": "pages.faqs",
    "title": "pages.faqs",
    "content": " ",
    "url": "/firefly/head/faqs/faqs.html",
    "relUrl": "/faqs/faqs.html"
  },"414": {
    "doc": "FFI",
    "title": "FFI",
    "content": " ",
    "url": "/firefly/head/reference/types/ffi.html",
    "relUrl": "/reference/types/ffi.html"
  },"415": {
    "doc": "FFI",
    "title": "Table of contents",
    "content": ". | FFI . | Example | Field Descriptions | . | FFIMethod | FFIParam | FFIEvent | FFIParam | . ",
    "url": "/firefly/head/reference/types/ffi.html#table-of-contents",
    "relUrl": "/reference/types/ffi.html#table-of-contents"
  },"416": {
    "doc": "FFI",
    "title": "FFI",
    "content": "See FireFly Interface Format . Example . { \"id\": \"c35d3449-4f24-4676-8e64-91c9e46f06c4\", \"message\": \"e4ad2077-5714-416e-81f9-7964a6223b6f\", \"namespace\": \"ns1\", \"name\": \"SimpleStorage\", \"description\": \"A simple example contract in Solidity\", \"version\": \"v0.0.1\", \"methods\": [ { \"id\": \"8f3289dd-3a19-4a9f-aab3-cb05289b013c\", \"interface\": \"c35d3449-4f24-4676-8e64-91c9e46f06c4\", \"name\": \"get\", \"namespace\": \"ns1\", \"pathname\": \"get\", \"description\": \"Get the current value\", \"params\": [], \"returns\": [ { \"name\": \"output\", \"schema\": { \"type\": \"integer\", \"details\": { \"type\": \"uint256\" } } } ], \"details\": { \"stateMutability\": \"viewable\" } }, { \"id\": \"fc6f54ee-2e3c-4e56-b17c-4a1a0ae7394b\", \"interface\": \"c35d3449-4f24-4676-8e64-91c9e46f06c4\", \"name\": \"set\", \"namespace\": \"ns1\", \"pathname\": \"set\", \"description\": \"Set the value\", \"params\": [ { \"name\": \"newValue\", \"schema\": { \"type\": \"integer\", \"details\": { \"type\": \"uint256\" } } } ], \"returns\": [], \"details\": { \"stateMutability\": \"payable\" } } ], \"events\": [ { \"id\": \"9f653f93-86f4-45bc-be75-d7f5888fbbc0\", \"interface\": \"c35d3449-4f24-4676-8e64-91c9e46f06c4\", \"namespace\": \"ns1\", \"pathname\": \"Changed\", \"signature\": \"Changed(address,uint256)\", \"name\": \"Changed\", \"description\": \"Emitted when the value changes\", \"params\": [ { \"name\": \"_from\", \"schema\": { \"type\": \"string\", \"details\": { \"type\": \"address\", \"indexed\": true } } }, { \"name\": \"_value\", \"schema\": { \"type\": \"integer\", \"details\": { \"type\": \"uint256\" } } } ] } ] } . Field Descriptions . | Field Name | Description | Type | . | id | The UUID of the FireFly interface (FFI) smart contract definition | UUID | . | message | The UUID of the broadcast message that was used to publish this FFI to the network | UUID | . | namespace | The namespace of the FFI | string | . | name | The name of the FFI - usually matching the smart contract name | string | . | description | A description of the smart contract this FFI represents | string | . | version | A version for the FFI - use of semantic versioning such as ‘v1.0.1’ is encouraged | string | . | methods | An array of smart contract method definitions | FFIMethod[] | . | events | An array of smart contract event definitions | FFIEvent[] | . ",
    "url": "/firefly/head/reference/types/ffi.html",
    "relUrl": "/reference/types/ffi.html"
  },"417": {
    "doc": "FFI",
    "title": "FFIMethod",
    "content": "| Field Name | Description | Type | . | id | The UUID of the FFI method definition | UUID | . | interface | The UUID of the FFI smart contract definition that this method is part of | UUID | . | name | The name of the method | string | . | namespace | The namespace of the FFI | string | . | pathname | The unique name allocated to this method within the FFI for use on URL paths. Supports contracts that have multiple method overrides with the same name | string | . | description | A description of the smart contract method | string | . | params | An array of method parameter/argument definitions | FFIParam[] | . | returns | An array of method return definitions | FFIParam[] | . | details | Additional blockchain specific fields about this method from the original smart contract. Used by the blockchain plugin and for documentation generation. | JSONObject | . ",
    "url": "/firefly/head/reference/types/ffi.html#ffimethod",
    "relUrl": "/reference/types/ffi.html#ffimethod"
  },"418": {
    "doc": "FFI",
    "title": "FFIParam",
    "content": "| Field Name | Description | Type | . | name | The name of the parameter. Note that parameters must be ordered correctly on the FFI, according to the order in the blockchain smart contract | string | . | schema | FireFly uses an extended subset of JSON Schema to describe parameters, similar to OpenAPI/Swagger. Converters are available for native blockchain interface definitions / type systems - such as an Ethereum ABI. See the documentation for more detail | JSONAny | . ",
    "url": "/firefly/head/reference/types/ffi.html#ffiparam",
    "relUrl": "/reference/types/ffi.html#ffiparam"
  },"419": {
    "doc": "FFI",
    "title": "FFIEvent",
    "content": "| Field Name | Description | Type | . | id | The UUID of the FFI event definition | UUID | . | interface | The UUID of the FFI smart contract definition that this event is part of | UUID | . | namespace | The namespace of the FFI | string | . | pathname | The unique name allocated to this event within the FFI for use on URL paths. Supports contracts that have multiple event overrides with the same name | string | . | signature | The stringified signature of the event, as computed by the blockchain plugin | string | . | name | The name of the event | string | . | description | A description of the smart contract event | string | . | params | An array of event parameter/argument definitions | FFIParam[] | . | details | Additional blockchain specific fields about this event from the original smart contract. Used by the blockchain plugin and for documentation generation. | JSONObject | . ",
    "url": "/firefly/head/reference/types/ffi.html#ffievent",
    "relUrl": "/reference/types/ffi.html#ffievent"
  },"420": {
    "doc": "FFI",
    "title": "FFIParam",
    "content": "| Field Name | Description | Type | . | name | The name of the parameter. Note that parameters must be ordered correctly on the FFI, according to the order in the blockchain smart contract | string | . | schema | FireFly uses an extended subset of JSON Schema to describe parameters, similar to OpenAPI/Swagger. Converters are available for native blockchain interface definitions / type systems - such as an Ethereum ABI. See the documentation for more detail | JSONAny | . ",
    "url": "/firefly/head/reference/types/ffi.html#ffiparam-1",
    "relUrl": "/reference/types/ffi.html#ffiparam-1"
  },"421": {
    "doc": "① Install the FireFly CLI",
    "title": "① Install the FireFly CLI",
    "content": " ",
    "url": "/firefly/head/gettingstarted/firefly_cli.html",
    "relUrl": "/gettingstarted/firefly_cli.html"
  },"422": {
    "doc": "① Install the FireFly CLI",
    "title": "Table of contents",
    "content": ". | FireFly CLI | Prerequisites . | Linux Users | Windows Users | . | Install the CLI . | Download the package for your OS | Extract the binary and move it to /usr/bin/local | macOSUsers | Alternative installation method: Install via Go | . | Verify the installation | Next steps: Start your environment | . ",
    "url": "/firefly/head/gettingstarted/firefly_cli.html#table-of-contents",
    "relUrl": "/gettingstarted/firefly_cli.html#table-of-contents"
  },"423": {
    "doc": "① Install the FireFly CLI",
    "title": "FireFly CLI",
    "content": "The FireFly CLI can be used to create local FireFly stacks for offline development of blockchain apps. This allows developers to rapidly iterate on their idea without needing to set up a bunch of infrastructure before they can write the first line of code. ",
    "url": "/firefly/head/gettingstarted/firefly_cli.html#firefly-cli",
    "relUrl": "/gettingstarted/firefly_cli.html#firefly-cli"
  },"424": {
    "doc": "① Install the FireFly CLI",
    "title": "Prerequisites",
    "content": "In order to run the FireFly CLI, you will need a few things installed on your dev machine: . | Docker | Docker Compose | openssl | . Linux Users . NOTE: For Linux users, it is recommended that you add your user to the docker group so that you do not have to run ff or docker as root or with sudo. For more information about Docker permissions on Linux, please see Docker’s documentation on the topic. Windows Users . NOTE: For Windows users, we recommend that you use Windows Subsystem for Linux 2 (WSL2). Binaries provided for Linux will work in this environment. ",
    "url": "/firefly/head/gettingstarted/firefly_cli.html#prerequisites",
    "relUrl": "/gettingstarted/firefly_cli.html#prerequisites"
  },"425": {
    "doc": "① Install the FireFly CLI",
    "title": "Install the CLI",
    "content": "There are several ways to install the FireFly CLI. The easiest way to get up and running with the FireFly CLI is to download a pre-compiled binary of the latest release. Download the package for your OS . Go to the latest release page and download the package for your OS and CPU architecture. Extract the binary and move it to /usr/bin/local . Assuming you downloaded the package from GitHub into your Downloads directory, run the following command: . sudo tar -zxf ~/Downloads/firefly-cli_*.tar.gz -C /usr/local/bin ff &amp;&amp; rm ~/Downloads/firefly-cli_*.tar.gz . If you downloaded the package from GitHub into a different directory, you will need to change the tar command above to wherever the firefly-cli_*.tar.gz file is located. macOSUsers . NOTE: On recent versions of macOS, default security settings will prevent the FireFly CLI binary from running, because it was downloaded from the internet. You will need to allow the FireFly CLI in System Preferences, before it will run. Alternative installation method: Install via Go . If you have a local Go development environment, and you have included ${GOPATH}/bin in your path, you could also use Go to install the FireFly CLI by running: . go install github.com/hyperledger/firefly-cli/ff@latest . ",
    "url": "/firefly/head/gettingstarted/firefly_cli.html#install-the-cli",
    "relUrl": "/gettingstarted/firefly_cli.html#install-the-cli"
  },"426": {
    "doc": "① Install the FireFly CLI",
    "title": "Verify the installation",
    "content": "After using either installation method above, you can verify that the CLI is successfully installed by running ff version. This should print the current version like this: . { \"Version\": \"v0.0.47\", \"License\": \"Apache-2.0\" } . ",
    "url": "/firefly/head/gettingstarted/firefly_cli.html#verify-the-installation",
    "relUrl": "/gettingstarted/firefly_cli.html#verify-the-installation"
  },"427": {
    "doc": "① Install the FireFly CLI",
    "title": "Next steps: Start your environment",
    "content": "Now that you’ve got the FireFly CLI set up on your machine, the next step is to create and start a FireFly stack. ② Start your environment → . ",
    "url": "/firefly/head/gettingstarted/firefly_cli.html#next-steps-start-your-environment",
    "relUrl": "/gettingstarted/firefly_cli.html#next-steps-start-your-environment"
  },"428": {
    "doc": "FireFly Interface Format",
    "title": "FireFly Interface Format",
    "content": "FireFly defines a common, blockchain agnostic way to describe smart contracts. This is referred to as a Contract Interface, and it is written in the FireFly Interface (FFI) format. It is a simple JSON document that has a name, a namespace, a version, a list of methods, and a list of events. ",
    "url": "/firefly/head/reference/firefly_interface_format.html",
    "relUrl": "/reference/firefly_interface_format.html"
  },"429": {
    "doc": "FireFly Interface Format",
    "title": "Table of contents",
    "content": ". | Overview | Method | Event | Param . | Schema | Schema details | . | Automated generation of FireFly Interfaces | Full Example | . ",
    "url": "/firefly/head/reference/firefly_interface_format.html#table-of-contents",
    "relUrl": "/reference/firefly_interface_format.html#table-of-contents"
  },"430": {
    "doc": "FireFly Interface Format",
    "title": "Overview",
    "content": "There are four required fields when broadcasting a contract interface in FireFly: a name, a version, a list of methods, and a list of events. A namespace field will also be filled in automatically based on the URL path parameter. Here is an example of the structure of the required fields: . { \"name\": \"example\", \"version\": \"v1.0.0\", \"methods\": [], \"events\": [] } . NOTE: Contract interfaces are scoped to a namespace. Within a namespace each contract interface must have a unique name and version combination. The same name and version combination can exist in different namespaces simultaneously. ",
    "url": "/firefly/head/reference/firefly_interface_format.html#overview",
    "relUrl": "/reference/firefly_interface_format.html#overview"
  },"431": {
    "doc": "FireFly Interface Format",
    "title": "Method",
    "content": "Let’s look at a what goes inside the methods array now. It is also a JSON object that has a name, a list of params which are the arguments the function will take and a list of returns which are the return values of the function. It also has an optional description which can be helpful in OpenAPI Spec generation. Finally, it has an optional details object which wraps blockchain specific information about this method. This can be used by the blockchain plugin when invoking this function, and it is also used in documentation generation. { \"name\": \"add\", \"description\": \"Add two numbers together\", \"params\": [], \"returns\": [], \"details\": {} } . ",
    "url": "/firefly/head/reference/firefly_interface_format.html#method",
    "relUrl": "/reference/firefly_interface_format.html#method"
  },"432": {
    "doc": "FireFly Interface Format",
    "title": "Event",
    "content": "What goes into the events array is very similar. It is also a JSON object that has a name and a list of params. The difference is that events don’t have returns. Arguments that are passed to the event when it is emitted are in params. It also has an optional description which can be helpful in OpenAPI Spec generation. Finally, it has an optional details object which wraps blockchain specific information about this event. This can be used by the blockchain plugin when invoking this function, and it is also used in documentation generation. { \"name\": \"added\", \"description\": \"An event that occurs when numbers have been added\", \"params\": [], \"details\": {} } . ",
    "url": "/firefly/head/reference/firefly_interface_format.html#event",
    "relUrl": "/reference/firefly_interface_format.html#event"
  },"433": {
    "doc": "FireFly Interface Format",
    "title": "Param",
    "content": "Both methods, and events have lists of params or returns, and the type of JSON object that goes in each of these arrays is the same. It is simply a JSON object with a name and a schema. There is also an optional details field that is passed to the blockchain plugin for blockchain specific requirements. { \"name\": \"x\", \"schema\": { \"type\": \"integer\", \"details\": {} } } . Schema . The param schema is an important field which tells FireFly the type information about this particular field. This is used in several different places, such as OpenAPI Spec generation, API request validation, and blockchain request preparation. The schema field accepts JSON Schema (version 2020-12) with several additional requirements: . | A type field is always mandatory | The list of valid types is: . | boolean | integer | string | object | array | . | Blockchain plugins can add their own specific requirements to this list of validation rules | . NOTE: Floats or decimals are not currently accepted because certain underlying blockchains (e.g. Ethereum) only allow integers . The type field here is the JSON input type when making a request to FireFly to invoke or query a smart contract. This type can be different from the actual blockchain type, usually specified in the details field, if there is a compatible type mapping between the two. Schema details . The details field is quite important in some cases. Because the details field is passed to the blockchain plugin, it is used to encapsulate blockchain specific type information about a particular field. Additionally, because each blockchain plugin can add rules to the list of schema requirements above, a blockchain plugin can enforce that certain fields are always present within the details field. For example, the Ethereum plugin always needs to know what Solidity type the field is. It also defines several optional fields. A full Ethereum details field may look like: . { \"type\": \"uint256\", \"internalType\": \"uint256\", \"indexed\": false } . ",
    "url": "/firefly/head/reference/firefly_interface_format.html#param",
    "relUrl": "/reference/firefly_interface_format.html#param"
  },"434": {
    "doc": "FireFly Interface Format",
    "title": "Automated generation of FireFly Interfaces",
    "content": "A convenience endpoint exists on the API to facilitate converting from native blockchain interface formats such as an Ethereum ABI to the FireFly Interface format. For details, please see the API documentation for the contract interface generation endpoint. For an example of using this endpoint with a specific Ethereum contract, please see the Tutorial to Work with custom smart contracts. ",
    "url": "/firefly/head/reference/firefly_interface_format.html#automated-generation-of-firefly-interfaces",
    "relUrl": "/reference/firefly_interface_format.html#automated-generation-of-firefly-interfaces"
  },"435": {
    "doc": "FireFly Interface Format",
    "title": "Full Example",
    "content": "Putting it all together, here is a full example of the FireFly Interface format with all the fields filled in: . { \"namespace\": \"default\", \"name\": \"SimpleStorage\", \"description\": \"A simple smart contract that stores and retrieves an integer on-chain\", \"version\": \"v1.0.0\", \"methods\": [ { \"name\": \"get\", \"description\": \"Retrieve the value of the stored integer\", \"params\": [], \"returns\": [ { \"name\": \"output\", \"schema\": { \"type\": \"integer\", \"details\": { \"type\": \"uint256\", \"internalType\": \"uint256\" } } } ], \"details\": { \"stateMutability\": \"viewable\" } }, { \"name\": \"set\", \"description\": \"Set the stored value on-chain\", \"params\": [ { \"name\": \"newValue\", \"schema\": { \"type\": \"integer\", \"details\": { \"type\": \"uint256\", \"internalType\": \"uint256\" } } } ], \"returns\": [], \"details\": { \"stateMutability\": \"payable\" } } ], \"events\": [ { \"name\": \"Changed\", \"description\": \"An event that is fired when the stored integer value changes\", \"params\": [ { \"name\": \"from\", \"schema\": { \"type\": \"string\", \"details\": { \"type\": \"address\", \"internalType\": \"address\", \"indexed\": true } } }, { \"name\": \"value\", \"schema\": { \"type\": \"integer\", \"details\": { \"type\": \"uint256\", \"internalType\": \"uint256\" } } } ], \"details\": {} } ] } . ",
    "url": "/firefly/head/reference/firefly_interface_format.html#full-example",
    "relUrl": "/reference/firefly_interface_format.html#full-example"
  },"436": {
    "doc": "The FireFly node",
    "title": "The FireFly node",
    "content": " ",
    "url": "/firefly/head/overview/firefly_node.html",
    "relUrl": "/overview/firefly_node.html"
  },"437": {
    "doc": "The FireFly node",
    "title": "Table of contents",
    "content": ". | FireFly node runtimes | Pluggable microservices architecture | . ",
    "url": "/firefly/head/overview/firefly_node.html#table-of-contents",
    "relUrl": "/overview/firefly_node.html#table-of-contents"
  },"438": {
    "doc": "The FireFly node",
    "title": "FireFly node runtimes",
    "content": "A FireFly node is a collection of multiple microservice runtimes with a single unified HTTPS/Websocket API (exposed by the Core). The minimum set of runtimes is as follows: . | FireFly Core - the API and event server for your multi-party applications | Blockchain node - the decentralized ledger technology establishing a shared source of truth | Blockchain interface - transaction submission and event streams for your chosen protocol | Shared storage node - a network-wide peer-to-peer store of shared data | Data exchange - for private member to member communications of messages and files | . Check out the FireFly CLI to get a a multi-party system running on your laptop in minutes. ",
    "url": "/firefly/head/overview/firefly_node.html#firefly-node-runtimes",
    "relUrl": "/overview/firefly_node.html#firefly-node-runtimes"
  },"439": {
    "doc": "The FireFly node",
    "title": "Pluggable microservices architecture",
    "content": "The runtimes are pluggable, allowing technology choice, and extensibility. | FireFly Core . | Orchestration engine - manages lifecycle of assets and data | Hosts the API and UI - applications connect here | Maintains private storage | Written in Go | . | Connectors . | Runtimes that bridge the core to multi-party infrastructure | Can be written in any language Go, Java, Node.js etc. | Can be stateful or stateless, depending on requirements | Can contain significant function, such as managed file transfer, or e2e encryption | . | Infrastructure runtimes . | Can be local runtimes, or cloud services | Blockchain nodes - Fabric, Ethereum, Corda etc. | Database servers - PostgreSQL, SQLite, CouchDB etc. | Private messaging - Kafka, RabbitMQ, ActiveMQ, Mosquitto etc. | Private blob storage - Kubernetes PVCs, AWS S3, Azure File etc. | Public blob storage - IPFS, etc. | … and more - token bridges, trusted compute engines, etc. | . | . ",
    "url": "/firefly/head/overview/firefly_node.html#pluggable-microservices-architecture",
    "relUrl": "/overview/firefly_node.html#pluggable-microservices-architecture"
  },"440": {
    "doc": "Introduction to Supernodes",
    "title": "Introduction to Supernodes",
    "content": " ",
    "url": "/firefly/head/overview/firefly_supernode.html",
    "relUrl": "/overview/firefly_supernode.html"
  },"441": {
    "doc": "Introduction to Supernodes",
    "title": "Table of contents",
    "content": ". | What is a Supernode | Your project with or without a Supernode | Types of blockchain project that benefit . | Solution builders | Organizations needing a gateway to Web3 | . | Feature view | Application features . | API Gateway | Event Streams | API Generation | . | Flow features . | Private data flow | Multi-party business process flow | Data exchange | . | Digital asset features . | Token API | Transfer history / audit trail | Wallets | . | . ",
    "url": "/firefly/head/overview/firefly_supernode.html#table-of-contents",
    "relUrl": "/overview/firefly_supernode.html#table-of-contents"
  },"442": {
    "doc": "Introduction to Supernodes",
    "title": "What is a Supernode",
    "content": "Over the last decade of enterprise blockchain projects, architects and developers have realized that they need much more than a blockchain node for their projects to be successful. The development stack needed for an enterprise grade Web3 application, is just as sophisticated as the stack required for the Web 2.0 applications that came before. A raw blockchain node is simply not enough. ",
    "url": "/firefly/head/overview/firefly_supernode.html#what-is-a-supernode",
    "relUrl": "/overview/firefly_supernode.html#what-is-a-supernode"
  },"443": {
    "doc": "Introduction to Supernodes",
    "title": "Your project with or without a Supernode",
    "content": ". So your choice as a development team for a blockchain project becomes whether you build and update all of the “plumbing” / “middleware” components needed underneath your business logic yourself, or whether you look for pre-built solutions. The Hyperledger FireFly approach is to allow the community to collaborate on the development and hardening of these components, across industries and projects. Then fit them into an open source, enterprise grade, pluggable development and runtime stack… the Supernode. The application developers then code against these APIs, and can be confident that the business logic that works on their local laptop against a sandbox, is being written in a way that scales to an enterprise decentralized application and can be deployed against one or more public/private blockchains in production. Thus allowing development teams to focus on differentiation where it matters - at the solution layer. ",
    "url": "/firefly/head/overview/firefly_supernode.html#your-project-with-or-without-a-supernode",
    "relUrl": "/overview/firefly_supernode.html#your-project-with-or-without-a-supernode"
  },"444": {
    "doc": "Introduction to Supernodes",
    "title": "Types of blockchain project that benefit",
    "content": "There are two main reasons your project might be exploring Supernodes, and considering the open source approach of Hyperledger FireFly. Solution builders . Teams building new decentralized Web3 solutions need a full technology stack for the application, to manage both private and blockchain data. Particularly in the enterprise space due to data security, regulatory and privacy concerns. For theses solutions to be successful, they need decentralized deployment to multiple parties. Each party needs to customize the deployment to their SecDevOps environment, as well as onboard it to their key management solution etc. So the complexity of requiring a bespoke technology stack for a solution can be a barrier to its adoption. Whereas, building on top of a standardized and open technology stack can ease adoption, as well as radically reducing the amount of engineering needed by the solution developer. Organizations needing a gateway to Web3 . Organizations are increasingly participating in multiple blockchain projects, and integrating with digital assets in multiple blockchain ecosystems. This means core IT security policy needs to scale to the challenge of adding these connections, and managing the wallets / signing identities, data flow, and SecDevOps requirements across multiple projects. A gateway tier at the edge between the core systems of the enterprise, and the Web3 transactions, helps reduce the overhead, and reduce risk. ",
    "url": "/firefly/head/overview/firefly_supernode.html#types-of-blockchain-project-that-benefit",
    "relUrl": "/overview/firefly_supernode.html#types-of-blockchain-project-that-benefit"
  },"445": {
    "doc": "Introduction to Supernodes",
    "title": "Feature view",
    "content": "So what makes a Supernode? . Let’s break down the functionality that is needed for an enterprise blockchain solution. ",
    "url": "/firefly/head/overview/firefly_supernode.html#feature-view",
    "relUrl": "/overview/firefly_supernode.html#feature-view"
  },"446": {
    "doc": "Introduction to Supernodes",
    "title": "Application features",
    "content": "Rapidly accelerating development is a key requirement of any Supernode. The business logic APIs, web and mobile user experiences for Web3 applications need to be just as rich and feature-full as the Web 2.0 / centralized applications. That means developers skilled in these application layers, must have the tools they need. Capabilities fitting their application development toolchain, and optimized to their skillset. API Gateway . Modern APIs that: . | Are fast and efficient | Have rich query support | Give deterministic outcomes and clear instruction for safe use | Integrate with your security frameworks like OAuth 2.0 / OpenID Connect single sign-on | Provide Open API 3 / Swagger definitions | Come with code SDKs, with rich type information | Conform as closely as possible to the principles of REST | Do not pretend to be RESTful in cases when it is impossible to be | . Event Streams . The reality is that the only programming paradigm that works for a decentralized solutions, is an event-driven one. All blockchain technologies are for this reason event-driven programming interfaces at their core. In an overall solution, those on-chain events must be coordinated with off-chain private data transfers, and existing core-systems / human workflows. This means great event support is a must: . | Convenient WebSocket APIs that work for your microservices development stack | Support for Webhooks to integrated serverless functions | Integration with your core enterprise message queue (MQ) or enterprise service bus (ESB) | At-least-once delivery assurance, with simple instructions at the application layer | . API Generation . The blockchain is going to be at the heart of your Web3 project. While usually small in overall surface area compared to the lines of code in the traditional application tiers, this kernel of mission-critical code is what makes your solution transformational compared to a centralized / Web 2.0 solution. Whether the smart contract is hand crafted for your project, an existing contract on a public blockchain, or a built-in pattern of a framework like FireFly - it must be interacted with correctly. So there can be no room for misinterpretation in the hand-off between the blockchain Smart Contract specialist, familiar with EVM contracts in Solidity/Vyper, Fabric chaincode (or maybe even raw block transition logic in Rust or Go), and the backend/full-stack application developer / core-system integrator. Well documented APIs are the modern norm for this, and it is no different for blockchain. This means: . | Generating the interface for methods and events on your smart contract | Providing robust transaction submission, and event streaming | Publishing the API, version, and location, of your smart contracts to the network | . ",
    "url": "/firefly/head/overview/firefly_supernode.html#application-features",
    "relUrl": "/overview/firefly_supernode.html#application-features"
  },"447": {
    "doc": "Introduction to Supernodes",
    "title": "Flow features",
    "content": "Data, value, and process flow are how decentralized systems function. In an enterprise context not all of this data can be shared with all parties, and some is very sensitive. Private data flow . Managing the flows of data so that the right information is shared with the right parties, at the right time, means thinking carefully about what data flows over what channel. The number of enterprise solutions where all data can flow directly through the blockchain, is vanishingly small. Coordinating these different data flows is often one of the biggest pieces of heavy lifting solved on behalf of the application by a robust framework like FireFly: . | Establishing the identity of participants so data can be shared | Securing the transfer of data off-chain | Coordinating off-chain data flow with on-chain data flow | Managing sequence for deterministic outcomes for all parties | Integrating off-chain private execution with multi-step stateful business logic | . Multi-party business process flow . Web3 has the potential to transform how ecosystems interact. Digitally transforming legacy process flows, by giving deterministic outcomes that are trusted by all parties, backed by new forms of digital trust between parties. Some of the most interesting use cases require complex multi-step business process across participants. The Web3 version of business process management, comes with a some new challenges. So you need the platform to: . | Provide a robust event-driven programming model fitting a “state machine” approach | Integrate with the decentralized application stack of each participant | Allow integration with the core-systems and human decision making of each participant | Provide deterministic ordering between all parties | Provide identity assurance and proofs for data flow / transition logic | . Data exchange . Business processes need data, and that data comes in many shapes and sizes. The platform needs to handle all of them: . | Large files and documents, as well as application data | Uniqueness / Enterprise NFTs - agreement on a single “foreign key” for a record | Non-repudiation, and acknowledgement of receipt | Coordination of flows of data, with flows of value - delivery vs. payment scenarios | . ",
    "url": "/firefly/head/overview/firefly_supernode.html#flow-features",
    "relUrl": "/overview/firefly_supernode.html#flow-features"
  },"448": {
    "doc": "Introduction to Supernodes",
    "title": "Digital asset features",
    "content": "The modelling, transfer and management of digital assets is the core programming foundation of blockchain. Yet out of the box, raw blockchains designed to efficiently manage these assets in large ecosystems, do not come with all the building blocks needed by applications. Token API . Tokens are such a fundamental construct, that they justify a standard API. This has been evolving in the industry through standards like ERC-20/ERC-721, and Web3 signing wallets and that support these. Supernodes bring this same standardization to applications. Providing APIs that work across token standards, and blockchain implementations, providing consistent and interoperable support. This means one application or set of back-end systems, can integrate with multiple blockchains, and different token implementations. Pluggability here is key, so that the rules of governance of each digital asset ecosystem can be exposed and enforced. Whether tokens are fungible, non-fungible, or some hybrid in between. Transfer history / audit trail . For efficiency blockchains seldom provide in their core the ability to query historical transaction information. Sometimes even the ability to query balances is unavailable, for blockchains based on a UTXO model. So off-chain indexing of transaction history is an absolute must-have for any digital asset solution, or even a simple wallet application. A platform like Hyperledger FireFly provides: . | Automatic indexing of tokens, whether existing or newly deployed | Off-chain indexing of fungible and non-fungible asset transfers &amp; balances | Off-chain indexing of approvals | Integration with digital identity | Full extensibility across both token standards and blockchain technologies | . Wallets . Wallet and signing-key management is a critical requirement for any blockchain solution, particularly those involving the transfer of digital assets between wallets. A platform like Hyperledger FireFly provides you the ability to: . | Integrate multiple different signing/custody solutions in a proven way | Manage the mapping of off-chain identities to on-chain signing identities | Provide a plug-point for policy-based decision making on high value transactions | Manage connections to multiple different blockchain solutions | . ",
    "url": "/firefly/head/overview/firefly_supernode.html#digital-asset-features",
    "relUrl": "/overview/firefly_supernode.html#digital-asset-features"
  },"449": {
    "doc": "Group",
    "title": "Group",
    "content": " ",
    "url": "/firefly/head/reference/types/group.html",
    "relUrl": "/reference/types/group.html"
  },"450": {
    "doc": "Group",
    "title": "Table of contents",
    "content": ". | Group . | Group identity hash | Private messaging architecture | Example | Field Descriptions | . | Member | . ",
    "url": "/firefly/head/reference/types/group.html#table-of-contents",
    "relUrl": "/reference/types/group.html#table-of-contents"
  },"451": {
    "doc": "Group",
    "title": "Group",
    "content": "A privacy group is a list of identities that should receive a private communication. When you send a private message, you can specify the list of participants in-line and it will be resolved to a group. Or you can reference the group using its identifying hash. The sender of a message must be included in the group along with the other participants. The sender receives an event confirming the message, just as any other participant would do. The sender is included automatically in the group when members are specified in-line, if it is omitted. Group identity hash . The identifying hash for a group is determined as follows: . | All identities are resolved to their DID. | An organization name or identity UUID can be used on input | . | The UUID of the node that should receive the data for each participant is determined (if not specified). | The first node found that is in the same identity hierarchy as the participant identity, will be chosen. | . | The list of participants is ordered by DID, with de-duplication of any identities. | The namespace, name, and members array are then serialized into a JSON object, without whitespace. | A SHA256 hash of the JSON object is calculated | . Private messaging architecture . The mechanism that keeps data private and ordered, without leaking data to the blockchain, is summarized in the below diagram. The key points are: . | Data is sent off-chain to all participants via the Data Exchange plugin . | The Data Exchange is responsible for encryption and off-chain identity verification | . | Only parties that are involved in the privacy group receive the data . | Other parties are only able to view the blockchain transaction | . | The hash and member list of the group are not shared outside of the privacy group . | The name of the group can be used as an additional salt in generation of the group hash | The member list must be known by all members of the group to verify the blockchain transactions, so the full group JSON structure is communicated privately with the first message sent on a group | . | The blockchain transaction is the source of truth for ordering . | All members are able to detect a blockchain transaction is part of a group they are a member of, from only the blockchain transaction - so they can block processing of subsequent messages until the off-chain data arrives (asynchronously) | . | The ordering context for messages is masked on the blockchain, so that two messages that are for same group do not contain the same context . | The ordering context (topic+group) is combined with a nonce that is incremented for each individual sender, to form a message-specific hash. | For each blockchain transaction, this hash can be compared against the expected next hash for each member to determine if it is a message on a known group - even without the private data (which might arrive later) | . | . Example . { \"namespace\": \"ns1\", \"name\": \"\", \"members\": [ { \"identity\": \"did:firefly:org/1111\", \"node\": \"4f563179-b4bd-4161-86e0-c2c1c0869c4f\" }, { \"identity\": \"did:firefly:org/2222\", \"node\": \"61a99af8-c1f7-48ea-8fcc-489e4822a0ed\" } ], \"localNamespace\": \"ns1\", \"message\": \"0b9dfb76-103d-443d-92fd-b114fe07c54d\", \"hash\": \"c52ad6c034cf5c7382d9a294f49297096a52eb55cc2da696c564b2a276633b95\", \"created\": \"2022-05-16T01:23:16Z\" } . Field Descriptions . | Field Name | Description | Type | . | namespace | The namespace of the group within the multiparty network | string | . | name | The optional name of the group, allowing multiple unique groups to exist with the same list of recipients | string | . | members | The list of members in this privacy group | Member[] | . | localNamespace | The local namespace of the group | string | . | message | The message used to broadcast this group privately to the members | UUID | . | hash | The identifier hash of this group. Derived from the name and group members | Bytes32 | . | created | The time when the group was first used to send a message in the network | FFTime | . ",
    "url": "/firefly/head/reference/types/group.html",
    "relUrl": "/reference/types/group.html"
  },"452": {
    "doc": "Group",
    "title": "Member",
    "content": "| Field Name | Description | Type | . | identity | The DID of the group member | string | . | node | The UUID of the node that receives a copy of the off-chain message for the identity | UUID | . ",
    "url": "/firefly/head/reference/types/group.html#member",
    "relUrl": "/reference/types/group.html#member"
  },"453": {
    "doc": "Identities",
    "title": "Identities",
    "content": " ",
    "url": "/firefly/head/reference/identities.html",
    "relUrl": "/reference/identities.html"
  },"454": {
    "doc": "Identities",
    "title": "Table of contents",
    "content": ". | Overview | Types of Identities . | org | node | custom | . | Identity Claims | Messaging . | Sender | Recipients | Verification | . | . ",
    "url": "/firefly/head/reference/identities.html#table-of-contents",
    "relUrl": "/reference/identities.html#table-of-contents"
  },"455": {
    "doc": "Identities",
    "title": "Overview",
    "content": "Identities are a critical part of using FireFly in a multi-party system. Every party that joins a multi-party system must begin by claiming an on- and off-chain identity, which is described with a unique DID. Each type of identity is also associated with an on- or off-chain verifier, which can be used in some way to check the authorship of a piece of data. Together, these concepts form the backbone of the trust model for exchanging multi-party data. ",
    "url": "/firefly/head/reference/identities.html#overview",
    "relUrl": "/reference/identities.html#overview"
  },"456": {
    "doc": "Identities",
    "title": "Types of Identities",
    "content": "There are three types of identities: . org . Organizations are the primary identity type in FireFly. They represent a logical on-chain signing identity, and the attached verifier is therefore a blockchain key (with the exact format depending on the blockchain being used). Every party in a multi-party system must claim a root organization identity as the first step to joining the network. The root organization name and key must be defined in the FireFly config (once for every multi-party system). It can be claimed with a POST to /network/organizations/self. Organizations may have child identities of any type. node . Nodes represent a logical off-chain identity - and specifically, they are tied to an instance of a data exchange connector. The format of the attached verifier depends on the data exchange plugin being used, but it will be mapped to some validation provided by that plugin (ie the name of an X.509 certificate or similar). Every party in a multi-party system must claim a node identity when joining the network, which must be a child of one of its organization identities (but it is possible for many nodes to share a parent organization). The node name must be defined in the FireFly config (once for every multi-party system). It can be claimed with a POST to /network/nodes/self. Nodes must be a child of an organization, and cannot have any child identities of their own. Note that “nodes” as an identity concept are distinct from FireFly supernodes, from underlying blockchain nodes, and from anywhere else the term “node” happens to be used. custom . Custom identities are similar to organizations, but are provided for applications to define their own more granular notions of identity. They are associated with an on-chain verifier in the same way as organizations. They can only have child identities which are also of type “custom”. ",
    "url": "/firefly/head/reference/identities.html#types-of-identities",
    "relUrl": "/reference/identities.html#types-of-identities"
  },"457": {
    "doc": "Identities",
    "title": "Identity Claims",
    "content": "Before an identity can be used within a multi-party system, it must be claimed. The identity claim is a special type of broadcast message sent by FireFly to establish an identity uniquely among the parties in the multi-party system. As with other broadcasts, this entails an on-chain transaction which contains a public reference to an off-chain piece of data (such as an IPFS reference) describing the details of the identity claim. The claim data consists of information on the identity being claimed - such as the type, the DID, and the parent (if applicable). The DID must be unique and unclaimed. The verifier will be inferred from the message - for on-chain identities (org and custom), it is the blockchain key that was used to sign the on-chain portion of the message, while for off-chain identities (nodes), is is an identifier queried from data exchange. For on-chain identities with a parent, two messages are actually required - the claim message signed with the new identity’s blockchain key, as well as a separate verification message signed with the parent identity’s blockchain key. Both messages must be received before the identity is confirmed. ",
    "url": "/firefly/head/reference/identities.html#identity-claims",
    "relUrl": "/reference/identities.html#identity-claims"
  },"458": {
    "doc": "Identities",
    "title": "Messaging",
    "content": "In the context of a multi-party system, FireFly provides capabilities for sending off-chain messages that are pinned to an on-chain proof. The sender of every message must therefore have an on-chain and off-chain identity. For private messages, every recipient must also have an on-chain and off-chain identity. Sender . When sending a message, the on-chain identity of the sender is controlled by the author and key fields. | If both are blank, the root organization is assumed. | If author alone is specified, it should be the DID of an org or custom identity. The associated verifier will be looked up to use as the key. | If key alone is specified, it must match the registered blockchain verifier for an org or custom identity that was previously claimed. A reverse lookup will be used to populate the DID for the author. | If author and key are both specified, they will be used as-is (can be used to send private messages with an unregistered blockchain key). | . The resolved key will be used to sign the blockchain transaction, which establishes the sender’s on-chain identity. The sender’s off-chain identity is always controlled by the node.name from the config along with the data exchange plugin. Recipients . When specifying private message recipients, each one has an identity and a node. | If identity alone is specified, it should be the DID of an org or custom identity. The first node owned by that identity or one of its ancestors will be automatically selected. | If both identity and node are specified, they will be used as-is. The node should be a child of the given identity or one of its ancestors. | . The node in this case will control how the off-chain portion of the message is routed via data exchange. Verification . When a message is received, FireFly verifies the following: . | The sender’s author and key are specified in the message. The author must be a known org or custom identity. The key must match the blockchain key that was used to sign the on-chain portion of the message. For broadcast messages, the key must match the registered verifier for the author. | For private messages, the sending node (as reported by data exchange) must be a known node identity which is a child of the message’s author identity or one of its ancestors. The combination of the author identity and the node must also be found in the message group. | . In addition, the data exchange plugin is responsible for verifying the sending and receiving identities for the off-chain data (such as validating the relevant certificates). ",
    "url": "/firefly/head/reference/identities.html#messaging",
    "relUrl": "/reference/identities.html#messaging"
  },"459": {
    "doc": "Identity",
    "title": "Identity",
    "content": " ",
    "url": "/firefly/head/reference/types/identity.html",
    "relUrl": "/reference/types/identity.html"
  },"460": {
    "doc": "Identity",
    "title": "Table of contents",
    "content": ". | Identity . | DIDs | Example | Field Descriptions | . | IdentityMessages | . ",
    "url": "/firefly/head/reference/types/identity.html#table-of-contents",
    "relUrl": "/reference/types/identity.html#table-of-contents"
  },"461": {
    "doc": "Identity",
    "title": "Identity",
    "content": "FireFly contains an address book of identities, which is managed in a decentralized way across a multi-party system through claim and verification system. See FIR-12 for evolution that is happening to Hyperledger FireFly to allow: . | Private address books that are not shared with other participants | Multiple address books backed by different chains, in the same node | . Root identities are registered with only a claim - which is a signed transaction from a particular blockchain account, to bind a DID with a name that is unique within the network, to that signing key. The signing key then becomes a Verifier for that identity. Using that key the root identity can be used to register a new FireFly node in the network, send and receive messages, and register child identities. When child identities are registered, a claim using a key that is going to be the Verifier for that child identity is required. However, this is insufficient to establish that identity as a child identity of the parent. There must be an additional verification that references the claim (by UUID) using the key verifier of the parent identity. DIDs . FireFly has adopted the DID standard for representing identities. A “DID Method” name of firefly is used to represent that the built-in identity system of Hyperledger FireFly is being used to resolve these DIDs. So an example FireFly DID for organization abcd1234 is: . | did:firefly:org/abcd1234 | . The adoption of DIDs in Hyperledger FireFly v1.0 is also a stepping stone to allowing pluggable DID based identity resolvers into FireFly in the future. You can also download a DID Document for a FireFly identity, which represents the verifiers and other information about that identity according to the JSON format in the DID standard. Example . { \"id\": \"114f5857-9983-46fb-b1fc-8c8f0a20846c\", \"did\": \"did:firefly:org/org_1\", \"type\": \"org\", \"parent\": \"688072c3-4fa0-436c-a86b-5d89673b8938\", \"namespace\": \"ff_system\", \"name\": \"org_1\", \"messages\": { \"claim\": \"911b364b-5863-4e49-a3f8-766dbbae7c4c\", \"verification\": \"24636f11-c1f9-4bbb-9874-04dd24c7502f\", \"update\": null }, \"created\": \"2022-05-16T01:23:15Z\" } . Field Descriptions . | Field Name | Description | Type | . | id | The UUID of the identity | UUID | . | did | The DID of the identity. Unique across namespaces within a FireFly network | string | . | type | The type of the identity | FFEnum:\"org\"\"node\"\"custom\" | . | parent | The UUID of the parent identity. Unset for root organization identities | UUID | . | namespace | The namespace of the identity. Organization and node identities are always defined in the ff_system namespace | string | . | name | The name of the identity. The name must be unique within the type and namespace | string | . | description | A description of the identity. Part of the updatable profile information of an identity | string | . | profile | A set of metadata for the identity. Part of the updatable profile information of an identity | JSONObject | . | messages | References to the broadcast messages that established this identity and proved ownership of the associated verifiers (keys) | IdentityMessages | . | created | The creation time of the identity | FFTime | . | updated | The last update time of the identity profile | FFTime | . ",
    "url": "/firefly/head/reference/types/identity.html",
    "relUrl": "/reference/types/identity.html"
  },"462": {
    "doc": "Identity",
    "title": "IdentityMessages",
    "content": "| Field Name | Description | Type | . | claim | The UUID of claim message | UUID | . | verification | The UUID of claim message. Unset for root organization identities | UUID | . | update | The UUID of the most recently applied update message. Unset if no updates have been confirmed | UUID | . ",
    "url": "/firefly/head/reference/types/identity.html#identitymessages",
    "relUrl": "/reference/types/identity.html#identitymessages"
  },"463": {
    "doc": "pages.getting_started",
    "title": "Getting Started",
    "content": "If you’re new to FireFly, this is the perfect place to start! With the FireFly CLI and the FireFly Sandbox it’s really easy to get started building powerful blockchain apps. Just follow along with the steps below and you’ll be up and running in no time! . What you will accomplish with this guide . With this easy-to-follow guide, you’ll go from “zero” to blockchain-hero in the time it takes to drink a single cup of coffee. It will walk you through setting up your machine, all the way through sending your first blockchain transactions using the FireFly Sandbox. We’re here to help! . We want to make it as easy as possible for anyone to get started with FireFly, and we don’t want anyone to feel like they’re stuck. If you’re having trouble, or are just curious about what else you can do with FireFly we encourage you to join the Hyperledger Discord server and come chat with us in the #firefly channel. ",
    "url": "/firefly/head/gettingstarted/#getting-started",
    "relUrl": "/gettingstarted/#getting-started"
  },"464": {
    "doc": "pages.getting_started",
    "title": "Get started: Install the FireFly CLI",
    "content": "Now that you’ve got the FireFly CLI set up on your machine, the next step is to create and start a FireFly stack. ① Install the FireFly CLI → . ",
    "url": "/firefly/head/gettingstarted/#get-started-install-the-firefly-cli",
    "relUrl": "/gettingstarted/#get-started-install-the-firefly-cli"
  },"465": {
    "doc": "pages.getting_started",
    "title": "pages.getting_started",
    "content": " ",
    "url": "/firefly/head/gettingstarted/",
    "relUrl": "/gettingstarted/"
  },"466": {
    "doc": "Core Resources",
    "title": "Core Resources",
    "content": " ",
    "url": "/firefly/head/reference/types/",
    "relUrl": "/reference/types/"
  },"467": {
    "doc": "pages.reference",
    "title": "Reference",
    "content": ". This section contains detailed reference information for developers using FireFly. ",
    "url": "/firefly/head/reference/#reference",
    "relUrl": "/reference/#reference"
  },"468": {
    "doc": "pages.reference",
    "title": "pages.reference",
    "content": " ",
    "url": "/firefly/head/reference/",
    "relUrl": "/reference/"
  },"469": {
    "doc": "Use tokens",
    "title": "Quick reference",
    "content": "Tokens are a critical building block in many blockchain-backed applications. Fungible tokens can represent a store of value or a means of rewarding participation in a multi-party system, while non-fungible tokens provide a clear way to identify and track unique entities across the network. FireFly provides flexible mechanisms to operate on any type of token and to tie those operations to on- and off-chain data. | FireFly provides an abstraction layer for multiple types of tokens | Tokens are grouped into pools, which each represent a particular type or class of token | Each pool is classified as fungible or non-fungible | In the case of non-fungible tokens, the pool is subdivided into individual tokens with a unique token index | Within a pool, you may mint (issue), transfer, and burn (redeem) tokens | Each operation can be optionally accompanied by a broadcast or private message, which will be recorded alongside the transfer on-chain | FireFly tracks a history of all token operations along with all current token balances | The blockchain backing each token connector may be the same or different from the one backing FireFly message pinning | . ",
    "url": "/firefly/head/tutorials/tokens/#quick-reference",
    "relUrl": "/tutorials/tokens/#quick-reference"
  },"470": {
    "doc": "Use tokens",
    "title": "What is a pool?",
    "content": "Token pools are a FireFly construct for describing a set of tokens. The exact definition of a token pool is dependent on the token connector implementation. Some examples of how pools might map to various well-defined Ethereum standards: . | ERC-1155: a single contract instance can efficiently allocate many isolated pools of fungible or non-fungible tokens | ERC-20 / ERC-777: each contract instance represents a single fungible pool of value, e.g. “a coin” | ERC-721: each contract instance represents a single pool of NFTs, each with unique identities within the pool | ERC-1400 / ERC-1410: partially supported in the same manner as ERC-20/ERC-777, but would require new features for working with partitions | . These are provided as examples only - a custom token connector could be backed by any token technology (Ethereum or otherwise) as long as it can support the basic operations described here (create pool, mint, burn, transfer). Other FireFly repos include a sample implementation of a token connector for ERC-20 and ERC-721 as well as ERC-1155. ",
    "url": "/firefly/head/tutorials/tokens/#what-is-a-pool",
    "relUrl": "/tutorials/tokens/#what-is-a-pool"
  },"471": {
    "doc": "Use tokens",
    "title": "Use tokens",
    "content": " ",
    "url": "/firefly/head/tutorials/tokens/",
    "relUrl": "/tutorials/tokens/"
  },"472": {
    "doc": "pages.chains",
    "title": "Connecting to remote blockchains",
    "content": "If you want to connect a local development environment, created with the FireFly CLI to another chain, there are several tutorials below to help you do that. These other chains could also be on the same machine as FireFly, or they could be somewhere on the public internet, depending on the tutorial. ",
    "url": "/firefly/head/tutorials/chains/#connecting-to-remote-blockchains",
    "relUrl": "/tutorials/chains/#connecting-to-remote-blockchains"
  },"473": {
    "doc": "pages.chains",
    "title": "pages.chains",
    "content": " ",
    "url": "/firefly/head/tutorials/chains/",
    "relUrl": "/tutorials/chains/"
  },"474": {
    "doc": "pages.custom_smart_contracts",
    "title": "Quick reference",
    "content": "Almost all blockchain platforms offer the ability to execute smart contracts on-chain in order to manage states on the shared ledger. FireFly provides support to use RESTful APIs to interact with the smart contracts deployed in the target blockchains, and listening to events via websocket. FireFly’s unified API creates a consistent application experience regardless of the specific underlying blockchain implementation. It also provides developer-friendly features like automatic OpenAPI Specification generation for smart contracts, plus a built-in Swagger UI. ",
    "url": "/firefly/head/tutorials/custom_contracts/#quick-reference",
    "relUrl": "/tutorials/custom_contracts/#quick-reference"
  },"475": {
    "doc": "pages.custom_smart_contracts",
    "title": "Key concepts",
    "content": "FireFly defines the following constructs to support custom smart contracts: . | Contract Interface: FireFly defines a common, blockchain agnostic way to describe smart contracts. This is referred to as a Contract Interface. A contract interface is written in the FireFly Interface (FFI) format. It is a simple JSON document that has a name, a namespace, a version, a list of methods, and a list of events. | . For more details, you can also have a look at the Reference page for the FireFly Interface Format. For blockchains that offer a DSL describing the smart contract interface, such as Ethereum’s ABI (Application Binary Interface), FireFly offers a convenience tool to convert the DSL into the FFI format. NOTE: Contract interfaces are scoped to a namespace. Within a namespace each contract interface must have a unique name and version combination. The same name and version combination can exist in different namespaces simultaneously. | HTTP API: Based on a Contract Interface, FireFly further defines an HTTP API for the smart contract, which is complete with an OpenAPI Specification and the Swagger UI. An HTTP API defines an /invoke root path to submit transactions, and a /query root path to send query requests to read the state back out. | . How the invoke vs. query requests get interpreted into the native blockchain requests are specific to the blockchain’s connector. For instance, the Ethereum connector translates /invoke calls to eth_sendTransaction JSON-RPC requests, while /query calls are translated into eth_call JSON-RPC requests. One the other hand, the Fabric connector translates /invoke calls to the multiple requests required to submit a transaction to a Fabric channel (which first collects endorsements from peer nodes, and then sends the assembled transaction payload to an orderer, for details please refer to the Fabric documentation). | Blockchain Event Listener: Regardless of a blockchain’s specific design, transaction processing are always asynchronous. This means a transaction is submitted to the network, at which point the submitting client gets an acknowledgement that it has been accepted for further processing. The client then listens for notifications by the blockchain when the transaction gets committed to the blockchain’s ledger. | . FireFly defines event listeners to allow the client application to specify the relevant blockchain events to keep track of. A client application can then receive the notifications from FireFly via an event subscription. | Event Subscription: While an event listener tells FireFly to keep track of certain events emitted by the blockchain, an event subscription tells FireFly to relay those events to the client application. Each subscriptions represents a stream of events that can be delivered to a listening client with various modes of delivery with at-least-once delivery guarantee. | . This is exactly the same as listening for any other events from FireFly. For more details on how Subscriptions work in FireFly you can read the Getting Started guide to Listen for events. ",
    "url": "/firefly/head/tutorials/custom_contracts/#key-concepts",
    "relUrl": "/tutorials/custom_contracts/#key-concepts"
  },"476": {
    "doc": "pages.custom_smart_contracts",
    "title": "Custom onchain logic async programming in FireFly",
    "content": "Like the rest of FireFly, custom onchin logic support are implemented with an asynchronous programming model. The key concepts here are: . | Transactions are submitted to FireFly and an ID is returned. This is the Operation ID. | The transaction itself happens asynchronously from the HTTP request that initiated it | Blockchain events emitted by the custom onchain logic (Ethereum smart contracts, Fabric chaincodes, Corda flows, etc.) will be stored in FireFly’s database if FireFly has a Event Listener set up for that specific type of event. FireFly will also emit an event of type blockchain_event_received when this happens. | . ",
    "url": "/firefly/head/tutorials/custom_contracts/#custom-onchain-logic-async-programming-in-firefly",
    "relUrl": "/tutorials/custom_contracts/#custom-onchain-logic-async-programming-in-firefly"
  },"477": {
    "doc": "pages.custom_smart_contracts",
    "title": "pages.custom_smart_contracts",
    "content": " ",
    "url": "/firefly/head/tutorials/custom_contracts/",
    "relUrl": "/tutorials/custom_contracts/"
  },"478": {
    "doc": "pages.tutorials",
    "title": "Tutorials",
    "content": " ",
    "url": "/firefly/head/tutorials/#tutorials",
    "relUrl": "/tutorials/#tutorials"
  },"479": {
    "doc": "pages.tutorials",
    "title": "pages.tutorials",
    "content": " ",
    "url": "/firefly/head/tutorials/",
    "relUrl": "/tutorials/"
  },"480": {
    "doc": "pages.understanding_firefly",
    "title": "Understanding FireFly",
    "content": ". ",
    "url": "/firefly/head/overview/#understanding-firefly",
    "relUrl": "/overview/#understanding-firefly"
  },"481": {
    "doc": "pages.understanding_firefly",
    "title": "pages.understanding_firefly",
    "content": " ",
    "url": "/firefly/head/overview/",
    "relUrl": "/overview/"
  },"482": {
    "doc": "pages.contributors",
    "title": "Contributors’ Guide",
    "content": " ",
    "url": "/firefly/head/contributors/#contributors-guide",
    "relUrl": "/contributors/#contributors-guide"
  },"483": {
    "doc": "pages.contributors",
    "title": "Table of contents",
    "content": ". | 🚀 Connect with us on Discord | 📅 Join our Community Calls | 🔍 Find your first issue . | Any level of experience | Go experience | Little or no Go experience, but want to learn | TypeScript experience | React/TypeScript experience | Go and blockchain experience | . | 📝 Make changes | 📑 Commit with Developer Certificate of Origin | 📥 Open a Pull Request | . We welcome anyone to contribute to the FireFly project! If you’re interested, this is a guide on how to get started. You don’t have to be a blockchain expert to make valuable contributions! There are lots of places for developers of all experience levels to get involved. 🧑🏽‍💻 👩🏻‍💻 👩🏾‍💻 🧑🏻‍💻 🧑🏿‍💻 👨🏽‍💻 👩🏽‍💻 🧑🏾‍💻 👨🏿‍💻 👨🏾‍💻 👩🏿‍💻 👨🏻‍💻 . ",
    "url": "/firefly/head/contributors/#table-of-contents",
    "relUrl": "/contributors/#table-of-contents"
  },"484": {
    "doc": "pages.contributors",
    "title": "🚀 Connect with us on Discord",
    "content": "You can chat with maintainers and other contributors on Discord in the firefly channel: https://discord.gg/hyperledger . Join Discord Server . ",
    "url": "/firefly/head/contributors/#-connect-with-us-on-discord",
    "relUrl": "/contributors/#-connect-with-us-on-discord"
  },"485": {
    "doc": "pages.contributors",
    "title": "📅 Join our Community Calls",
    "content": "Community calls are a place to talk to other contributors, maintainers, and other people interested in FireFly. Maintainers often discuss upcoming changes and proposed new features on these calls. These calls are a great way for the community to give feedback on new ideas, ask questions about FireFly, and hear how others are using FireFly to solve real world problems. Please see the FireFly Calendar for the current meeting schedule, and the link to join. Everyone is welcome to join, regardless of background or experience level. ",
    "url": "/firefly/head/contributors/#-join-our-community-calls",
    "relUrl": "/contributors/#-join-our-community-calls"
  },"486": {
    "doc": "pages.contributors",
    "title": "🔍 Find your first issue",
    "content": "If you’re looking for somewhere to get started in the FireFly project and want something small and relatively easy, take a look at issues tagged with “Good first issue”. You can definitely work on other things if you want to. These are only suggestions for easy places to get started. See “Good First Issues” . NOTE Hyperledger FireFly has a microservice architecture so it has many different GitHub repos. Use the link or the button above to look for “Good First Issues” across all the repos at once. Here are some other suggestions of places to get started, based on experience you may already have: . Any level of experience . If you looking to make your first open source contribution the FireFly documentation is a great place to make small, easy improvements. These improvements are also very valuable, because they help the next person that may want to know the same thing. Here are some detailed instructions on Contributing to Documentation . Go experience . If you have some experience in Go and really want to jump into FireFly, the FireFly Core is the heart of the project. Here are some detailed instructions on Setting up a FireFly Core Development Environment. Little or no Go experience, but want to learn . If you don’t have a lot of experience with Go, but are interested in learning, the FireFly CLI might be a good place to start. The FireFly CLI is a tool to set up local instances of FireFly for building apps that use FireFly, and for doing development on FireFly itself. TypeScript experience . If you have some experience in TypeScript, there are several FireFly microservices that are written in TypeScript. The Data Exchange is used for private messaging between FireFly nodes. The ERC-20/ERC-271 Tokens Connector and ERC-1155 Tokens Connector are used to abstract token contract specifics from the FireFly Core. React/TypeScript experience . If you want to do some frontend development, the FireFly UI is written in TypeScript and React. Go and blockchain experience . If you already have some experience with blockchain and want to work on some backend components, the blockchain connectors, firefly-ethconnect (for Ethereum) and firefly-fabconnect (for Fabric) are great places to get involved. ",
    "url": "/firefly/head/contributors/#-find-your-first-issue",
    "relUrl": "/contributors/#-find-your-first-issue"
  },"487": {
    "doc": "pages.contributors",
    "title": "📝 Make changes",
    "content": "To contribute to the repository, please fork the repository that you want to change. Then clone your fork locally on your machine and make your changes. As you commit your changes, push them to your fork. More information on making commits below. ",
    "url": "/firefly/head/contributors/#-make-changes",
    "relUrl": "/contributors/#-make-changes"
  },"488": {
    "doc": "pages.contributors",
    "title": "📑 Commit with Developer Certificate of Origin",
    "content": "As with all Hyperledger repositories, FireFly requires proper sign-off on every commit that is merged into the main branch. The sign-off indicates that you certify the changes you are submitting are in accordance with the Developer Certificate of Origin. To sign-off on your commit, you can use the -s flag when you commit changes. git commit -s -m \"Your commit message\" . This will add a string like this to the end of your commit message: . \"Signed-off-by: Your Name &lt;your-email@address&gt;\" . NOTE: Sign-off is not the same thing as signing your commits with a private key. Both operations use a similar flag, which can be confusing. The one you want is the lowercase -s 🙂 . ",
    "url": "/firefly/head/contributors/#-commit-with-developer-certificate-of-origin",
    "relUrl": "/contributors/#-commit-with-developer-certificate-of-origin"
  },"489": {
    "doc": "pages.contributors",
    "title": "📥 Open a Pull Request",
    "content": "When you’re ready to submit your changes for review, open a Pull Request back to the upstream repository. When you open your pull request, the maintainers will automatically be notified. Additionally, a series of automated checks will be performed on your code to make sure it passes certain repository specific requirements. Maintainers may have suggestions on things to improve in your pull request. It is our goal to get code that is beneficial to the project merged as quickly as possible, so we don’t like to leave pull requests hanging around for a long time. If the project maintainers are satisfied with the changes, they will approve and merge the pull request. Thanks for your interest in collaborating on this project! . ",
    "url": "/firefly/head/contributors/#-open-a-pull-request",
    "relUrl": "/contributors/#-open-a-pull-request"
  },"490": {
    "doc": "pages.contributors",
    "title": "pages.contributors",
    "content": " ",
    "url": "/firefly/head/contributors/",
    "relUrl": "/contributors/"
  },"491": {
    "doc": "pages.architecture",
    "title": "Architecture",
    "content": "This section contains a collection of technical architecture diagrams detailing the various runtime components of a FireFly deployment. ",
    "url": "/firefly/head/architecture/#architecture",
    "relUrl": "/architecture/#architecture"
  },"492": {
    "doc": "pages.architecture",
    "title": "pages.architecture",
    "content": " ",
    "url": "/firefly/head/architecture/",
    "relUrl": "/architecture/"
  },"493": {
    "doc": "pages.home",
    "title": "Hyperledger FireFly",
    "content": ". Hyperledger FireFly is the first open source Supernode: a complete stack for enterprises to build and scale secure Web3 applications. The FireFly API for digital assets, data flows, and blockchain transactions makes it radically faster to build production-ready apps on popular chains and protocols. | Understanding FireFly | Reference | Architecture | Contributors | API Spec | . ",
    "url": "/firefly/head/#hyperledger-firefly",
    "relUrl": "/#hyperledger-firefly"
  },"494": {
    "doc": "pages.home",
    "title": "pages.home",
    "content": " ",
    "url": "/firefly/head/",
    "relUrl": "/"
  },"495": {
    "doc": "Internal Event Sequencing",
    "title": "Internal Event Sequencing",
    "content": " ",
    "url": "/firefly/head/architecture/internal_event_sequencing.html",
    "relUrl": "/architecture/internal_event_sequencing.html"
  },"496": {
    "doc": "Internal Event Sequencing",
    "title": "Table of contents",
    "content": ". | Overview | App Instances | Outbound Sequencers | Inbound Aggregator . | Events Table | . | Subscription Manager | Event Dispatcher | . ",
    "url": "/firefly/head/architecture/internal_event_sequencing.html#table-of-contents",
    "relUrl": "/architecture/internal_event_sequencing.html#table-of-contents"
  },"497": {
    "doc": "Internal Event Sequencing",
    "title": "Overview",
    "content": ". One of the most important roles FireFly has, is to take actions being performed by the local apps, process them, get them confirmed, and then deliver back as “stream of consciousness” to the application alongside all the other events that are coming into the application from other FireFly Nodes in the network. You might observe the problems solved in this architecture are similar to those in a message queuing system (like Apache Kafka, or a JMS/AMQP provider like ActiveMQ etc.). However, we cannot directly replace the internal logic with such a runtime - because FireFly’s job is to aggregate data from multiple runtimes that behave similarly to these: . | Private messaging in the Data Exchange | The blockchain ledger(s) themselves, which are a stream of sequenced events | The event dispatcher delivering messages to applications that have been sequenced by FireFly | . So FireFly provides the convenient REST based management interface to simplify the world for application developers, by aggregating the data from multiple locations, and delivering it to apps in a deterministic sequence. The sequence is made deterministic: . | Globally to all apps within the scope of the ledger, when a Blockchain ledger is used to pin events (see #10) | Locally for messages delivered through a single FireFly node into the network | Locally for all messages delivered to applications connected to a FireFly node, across blockchain | . ",
    "url": "/firefly/head/architecture/internal_event_sequencing.html#overview",
    "relUrl": "/architecture/internal_event_sequencing.html#overview"
  },"498": {
    "doc": "Internal Event Sequencing",
    "title": "App Instances",
    "content": ". | Broadcast messages to the network | Ingest ack when message persisted in local messages table | Consume events via Websocket connection into FireFly | . ",
    "url": "/firefly/head/architecture/internal_event_sequencing.html#app-instances",
    "relUrl": "/architecture/internal_event_sequencing.html#app-instances"
  },"499": {
    "doc": "Internal Event Sequencing",
    "title": "Outbound Sequencers",
    "content": ". | Broadcast or Private through IPFS or Private Data Storage | Long-running leader-elected jobs listening to the database (via event tables in SQL, etc.) | . ",
    "url": "/firefly/head/architecture/internal_event_sequencing.html#outbound-sequencers",
    "relUrl": "/architecture/internal_event_sequencing.html#outbound-sequencers"
  },"500": {
    "doc": "Internal Event Sequencing",
    "title": "Inbound Aggregator",
    "content": ". | Triggered each time an event is detected by the associated plugin. | It is the responsibility of the plugin to fire events sequentially. Can be workload managed but must be sequential. | . Events Table . | Deliberately lightweight persisted object, that is generated as a byproduct of other persistent actions. | Records the local sequence of a specific event within the local node. | The highest level event type is the confirmation of a message, however the table can be extended for more granularity on event types. | . ",
    "url": "/firefly/head/architecture/internal_event_sequencing.html#inbound-aggregator",
    "relUrl": "/architecture/internal_event_sequencing.html#inbound-aggregator"
  },"501": {
    "doc": "Internal Event Sequencing",
    "title": "Subscription Manager",
    "content": ". | Responsible for filtering and delivering batches of events to the active event dispatchers. | Records the latest offset confirmed by each dispatcher. | . ",
    "url": "/firefly/head/architecture/internal_event_sequencing.html#subscription-manager",
    "relUrl": "/architecture/internal_event_sequencing.html#subscription-manager"
  },"502": {
    "doc": "Internal Event Sequencing",
    "title": "Event Dispatcher",
    "content": ". | Created with leadership election when WebSocket connection is made from an app into FireFly. | Extensible to other dispatchers (AMQP, etc.). | . ",
    "url": "/firefly/head/architecture/internal_event_sequencing.html#event-dispatcher",
    "relUrl": "/architecture/internal_event_sequencing.html#event-dispatcher"
  },"503": {
    "doc": "Message",
    "title": "Message",
    "content": " ",
    "url": "/firefly/head/reference/types/message.html",
    "relUrl": "/reference/types/message.html"
  },"504": {
    "doc": "Message",
    "title": "Table of contents",
    "content": ". | Message . | Hash | Tag | Topics . | Using multiple topics | . | Transaction type | In-line data | Example | Field Descriptions | . | MessageHeader | DataRef | . ",
    "url": "/firefly/head/reference/types/message.html#table-of-contents",
    "relUrl": "/reference/types/message.html#table-of-contents"
  },"505": {
    "doc": "Message",
    "title": "Message",
    "content": "Message is the envelope by which coordinated data exchange can happen between parties in the network. Data is passed by reference in these messages, and a chain of hashes covering the data and the details of the message, provides a verification against tampering. A message is made up of three sections: . | The header - a set of metadata that determines how the message is ordered, who should receive it, and how they should process it | The data - an array of data attachments | Status information - fields that are calculated independently by each node, and hence update as the message makes it way through the system | . Hash . Sections (1) and (2) are fixed once the message is sent, and a hash is generated that provides tamper protection. The hash is a function of the header, and all of the data payloads. Calculated as follows: . | The hash of each Data element is calculated individually | A JSON array of [{\"id\":\"\",\"hash\":\"\"}] is hashed, and that hash is stored in header.datahash | The header is serialized as JSON with the deterministic order (listed below) and hashed . | JSON data is serialized without whitespace to hash it. | The hashing algorithm is SHA-256 | . | . Each node independently calculates the hash, and the hash is included in the manifest of the Batch by the node that sends the message. Because the hash of that batch manifest is included in the blockchain transaction, a message transferred to a node that does not match the original message hash is rejected. Tag . The header.tag tells the processors of the message how it should be processed, and what data they should expect it to contain. If you think of your decentralized application like a state machine, then you need to have a set of well defined transitions that can be performed between states. Each of these transitions that requires off-chain transfer of private data (optionally coordinated with an on-chain transaction) should be expressed as a type of message, with a particular tag. Every copy of the application that runs in the participants of the network should look at this tag to determine what logic to execute against it. Note: For consistency in ordering, the sender should also wait to process the state machine transitions associated with the message they send until it is ordered by the blockchain. They should not consider themselves special because they sent the message, and process it immediately - otherwise they could end up processing it in a different order to other parties in the network that are also processing the message. Topics . The header.topics strings allow you to set the the ordering context for each message you send, and you are strongly encouraged to set it explicitly on every message you send (falling back to the default topic is not recommended). A key difference between blockchain backed decentralized applications and other event-driven applications, is that there is a single source of truth for the order in which things happen. In a multi-party system with off-chain transfer of data as well as on-chain transfer of data, the two sets of data need to be coordinated together. The off-chain transfer might happen at different times, and is subject to the reliability of the parties &amp; network links involved in that off-chain communication. A “stop the world” approach to handling a single piece of missing data is not practical for a high volume production business network. The ordering context is a function of: . | Whether the message is broadcast or private | If it is private, the privacy group associated with the message | The topic of the message | . When an on-chain transaction is detected by FireFly, it can determine the above ordering - noting that privacy is preserved for private messages by masking this ordering context message-by-message with a nonce and the group ID, so that only the participants in that group can decode the ordering context. If a piece of off-chain data is unavailable, then the FireFly node will block only streams of data that are associated with that ordering context. For your application, you should choose the most granular identifier you can for your topic to minimize the scope of any blockage if one item of off-chain data fails to be delivered or is delayed. Some good examples are: . | A business transaction identifier - to ensure all data related to particular business transaction are processed in order | A globally agreed customer identifier - to ensure all data related to a particular business entity are processed in order | . Using multiple topics . There are some advanced scenarios where you need to merge streams of ordered data, so that two previously separately ordered streams of communication (different state machines) are joined together to process a critical decision/transition in a deterministic order. A synchronization point between two otherwise independent streams of communication. To do this, simply specify two topics in the message you sent, and the message will be independently ordered against both of those topics. You will also receive two events for the confirmation of that message, one for each topic. Some examples: . | Agreeing to join two previously separate business transactions with ids 000001 and 000002, by discarding business transaction 000001 as a duplicate . | Specify topics: [\"000001\",\"000002\"] on the special merge message, and then from that point onwards you would only need to specify topics: [\"000002\"]. | . | Agreeing to join two previously separate entities with id1 and id2, into a merged entity with id3. | Specify topics: [\"id1\",\"id2\",\"id3\"] on the special merge message, and then from that point onwards you would only need to specify topics: [\"id3\"]. | . | . Transaction type . By default messages are pinned to the blockchain, within a Batch. For private messages, you can choose to disable this pinning by setting header.txtype: \"unpinned\". Broadcast messages must be pinned to the blockchain. In-line data . When sending a message you can specify the array of Data attachments in-line, as part of the same JSON payload. For example, a minimal broadcast message could be: . { \"data\": [ {\"value\": \"hello world\"} ] } . When you send this message with /api/v1/namespaces/{ns}/messages/broadcast: . | The header will be initialized with the default values, including txtype: \"batch_pin\" | The data[0] entry will be stored as a Data resource | The message will be assembled into a batch and broadcast | . Example . { \"header\": { \"id\": \"4ea27cce-a103-4187-b318-f7b20fd87bf3\", \"cid\": \"00d20cba-76ed-431d-b9ff-f04b4cbee55c\", \"type\": \"private\", \"txtype\": \"batch_pin\", \"author\": \"did:firefly:org/acme\", \"key\": \"0xD53B0294B6a596D404809b1d51D1b4B3d1aD4945\", \"created\": \"2022-05-16T01:23:10Z\", \"namespace\": \"ns1\", \"group\": \"781caa6738a604344ae86ee336ada1b48a404a85e7041cf75b864e50e3b14a22\", \"topics\": [ \"topic1\" ], \"tag\": \"blue_message\", \"datahash\": \"c07be180b147049baced0b6219d9ce7a84ab48f2ca7ca7ae949abb3fe6491b54\" }, \"localNamespace\": \"ns1\", \"state\": \"confirmed\", \"confirmed\": \"2022-05-16T01:23:16Z\", \"data\": [ { \"id\": \"fdf9f118-eb81-4086-a63d-b06715b3bb4e\", \"hash\": \"34cf848d896c83cdf433ea7bd9490c71800b316a96aac3c3a78a42a4c455d67d\" } ] } . Field Descriptions . | Field Name | Description | Type | . | header | The message header contains all fields that are used to build the message hash | MessageHeader | . | localNamespace | The local namespace of the message | string | . | hash | The hash of the message. Derived from the header, which includes the data hash | Bytes32 | . | batch | The UUID of the batch in which the message was pinned/transferred | UUID | . | state | The current state of the message | FFEnum:\"staged\"\"ready\"\"sent\"\"pending\"\"confirmed\"\"rejected\" | . | confirmed | The timestamp of when the message was confirmed/rejected | FFTime | . | data | The list of data elements attached to the message | DataRef[] | . | pins | For private messages, a unique pin hash:nonce is assigned for each topic | string[] | . ",
    "url": "/firefly/head/reference/types/message.html",
    "relUrl": "/reference/types/message.html"
  },"506": {
    "doc": "Message",
    "title": "MessageHeader",
    "content": "| Field Name | Description | Type | . | id | The UUID of the message. Unique to each message | UUID | . | cid | The correlation ID of the message. Set this when a message is a response to another message | UUID | . | type | The type of the message | FFEnum:\"definition\"\"broadcast\"\"private\"\"groupinit\"\"transfer_broadcast\"\"transfer_private\" | . | txtype | The type of transaction used to order/deliver this message | FFEnum:\"none\"\"unpinned\"\"batch_pin\"\"network_action\"\"token_pool\"\"token_transfer\"\"contract_invoke\"\"token_approval\"\"data_publish\" | . | author | The DID of identity of the submitter | string | . | key | The on-chain signing key used to sign the transaction | string | . | created | The creation time of the message | FFTime | . | namespace | The namespace of the message within the multiparty network | string | . | topics | A message topic associates this message with an ordered stream of data. A custom topic should be assigned - using the default topic is discouraged | string[] | . | tag | The message tag indicates the purpose of the message to the applications that process it | string | . | datahash | A single hash representing all data in the message. Derived from the array of data ids+hashes attached to this message | Bytes32 | . ",
    "url": "/firefly/head/reference/types/message.html#messageheader",
    "relUrl": "/reference/types/message.html#messageheader"
  },"507": {
    "doc": "Message",
    "title": "DataRef",
    "content": "| Field Name | Description | Type | . | id | The UUID of the referenced data resource | UUID | . | hash | The hash of the referenced data | Bytes32 | . ",
    "url": "/firefly/head/reference/types/message.html#dataref",
    "relUrl": "/reference/types/message.html#dataref"
  },"508": {
    "doc": "pages.moonbeam_testnet",
    "title": "Moonbeam Testnet",
    "content": " ",
    "url": "/firefly/head/tutorials/chains/moonbeam.html#moonbeam-testnet",
    "relUrl": "/tutorials/chains/moonbeam.html#moonbeam-testnet"
  },"509": {
    "doc": "pages.moonbeam_testnet",
    "title": "Table of contents",
    "content": ". | Previous steps: Install the FireFly CLI | Create an evmconnect.yml config file | Creating a new stack | Start the stack | Get some DEV . | Confirm the transaction on Moonscan | . | Use the public testnet | . Starting with FireFly v1.1, it’s easy to connect to public Ethereum chains. This guide will walk you through the steps to create a local FireFly development environment and connect it to the public Moonbeam Alpha testnet. ",
    "url": "/firefly/head/tutorials/chains/moonbeam.html#table-of-contents",
    "relUrl": "/tutorials/chains/moonbeam.html#table-of-contents"
  },"510": {
    "doc": "pages.moonbeam_testnet",
    "title": "Previous steps: Install the FireFly CLI",
    "content": "If you haven’t set up the FireFly CLI already, please go back to the Getting Started guide and read the section on how to Install the FireFly CLI. ← ① Install the FireFly CLI . ",
    "url": "/firefly/head/tutorials/chains/moonbeam.html#previous-steps-install-the-firefly-cli",
    "relUrl": "/tutorials/chains/moonbeam.html#previous-steps-install-the-firefly-cli"
  },"511": {
    "doc": "pages.moonbeam_testnet",
    "title": "Create an evmconnect.yml config file",
    "content": "In order to connect to the Moonbeam testnet, you will need to set a few configuration options for the evmconnect blockchain connector. Create a text file called evmconnect.yml with the following contents: . confirmations: required: 4 # choose the number of confirmations you require policyengine.simple: fixedGasPrice: null gasOracle: mode: connector . For more info about confirmations, see Public vs. Permissioned . For this tutorial, we will assume this file is saved at ~/Desktop/evmconnect.yml. If your path is different, you will need to adjust the path in the next command below. ",
    "url": "/firefly/head/tutorials/chains/moonbeam.html#create-an-evmconnectyml-config-file",
    "relUrl": "/tutorials/chains/moonbeam.html#create-an-evmconnectyml-config-file"
  },"512": {
    "doc": "pages.moonbeam_testnet",
    "title": "Creating a new stack",
    "content": "To create a local FireFly development stack and connect it to the Moonbeam Alpha testnet, we will use command line flags to customize the following settings: . | Create a new stack named moonbeam with 1 member | Disable multiparty mode. We are going to be using this FireFly node as a Web3 gateway, and we don’t need to communicate with a consortium here | Connect to an ethereum network | Use the evmconnect blockchain connector | Use an remote RPC node. This will create a signer locally, so that our signing key never leaves the development machine. | See the moonbeam docs and select an HTTPS RPC endpoint | Set the chain ID to 1287 (the correct ID for the Moonbeam Alpha testnet) | Merge the custom config created above with the generated evmconnect config file | . To do this, run the following command: . ff init moonbeam 1 \\ --multiparty=false \\ -b ethereum \\ -c evmconnect \\ -n remote-rpc \\ --remote-node-url &lt;selected RPC endpoint&gt; \\ --chain-id 1287 \\ --connector-config ~/Desktop/evmconnect.yml . ",
    "url": "/firefly/head/tutorials/chains/moonbeam.html#creating-a-new-stack",
    "relUrl": "/tutorials/chains/moonbeam.html#creating-a-new-stack"
  },"513": {
    "doc": "pages.moonbeam_testnet",
    "title": "Start the stack",
    "content": "Now you should be able to start your stack by running: . ff start moonbeam . After some time it should print out the following: . Web UI for member '0': http://127.0.0.1:5000/ui Sandbox UI for member '0': http://127.0.0.1:5109 To see logs for your stack run: ff logs moonbeam . ",
    "url": "/firefly/head/tutorials/chains/moonbeam.html#start-the-stack",
    "relUrl": "/tutorials/chains/moonbeam.html#start-the-stack"
  },"514": {
    "doc": "pages.moonbeam_testnet",
    "title": "Get some DEV",
    "content": "At this point you should have a working FireFly stack, talking to a public chain. However, you won’t be able to run any transactions just yet, because you don’t have any way to pay for gas. A testnet faucet can give us some DEV, the native token for Moonbeam. First, you will need to know what signing address your FireFly node is using. To check that, you can run: . ff accounts list moonbeam [ { \"address\": \"0x02d42c32a97c894486afbc7b717edff50c70b292\", \"privateKey\": \"...\" } ] . Copy the address listed in the output from this command. Go to https://apps.moonbeam.network/moonbase-alpha/faucet/ and paste the address in the form. Click the Submit button. Confirm the transaction on Moonscan . You should be able to go lookup your account on Moonscan for the Moonbase Alpha testnet and see that you now have a sufficient balance of DEV. Simply paste in your account address to search for it. ",
    "url": "/firefly/head/tutorials/chains/moonbeam.html#get-some-dev",
    "relUrl": "/tutorials/chains/moonbeam.html#get-some-dev"
  },"515": {
    "doc": "pages.moonbeam_testnet",
    "title": "Use the public testnet",
    "content": "Now that you have everything set up, you can follow one of the other FireFly guides such as Using Tokens or Custom Smart Contracts. For detailed instructions on interacting with the Moonbeam Alpha testnet, please see the Moonbeam docs. ",
    "url": "/firefly/head/tutorials/chains/moonbeam.html#use-the-public-testnet",
    "relUrl": "/tutorials/chains/moonbeam.html#use-the-public-testnet"
  },"516": {
    "doc": "pages.moonbeam_testnet",
    "title": "pages.moonbeam_testnet",
    "content": " ",
    "url": "/firefly/head/tutorials/chains/moonbeam.html",
    "relUrl": "/tutorials/chains/moonbeam.html"
  },"517": {
    "doc": "Multi-party Systems",
    "title": "Enterprise multi-party systems",
    "content": " ",
    "url": "/firefly/head/overview/multiparty.html#enterprise-multi-party-systems",
    "relUrl": "/overview/multiparty.html#enterprise-multi-party-systems"
  },"518": {
    "doc": "Multi-party Systems",
    "title": "Table of contents",
    "content": ". | Introduction | Points of difference | . ",
    "url": "/firefly/head/overview/multiparty.html#table-of-contents",
    "relUrl": "/overview/multiparty.html#table-of-contents"
  },"519": {
    "doc": "Multi-party Systems",
    "title": "Introduction",
    "content": "Multi-party systems are a class of application empowered by the technology revolution of blockchain digital ledger technology (DLT), and emerging cryptographic proof technologies like zero-knowledge proofs (ZKPs) and trusted execution environments (TEEs). By combining these technologies with existing best practice technologies for data security in regulated industries, multi-party systems allow businesses to collaborate in ways previously impossible. Through agreement on a common source of truth, such as the completion of a step in a business process to proceed, or the existence and ownership of a unique asset, businesses can cut out huge inefficiencies in existing multi-party processes. New business and transaction models can be achieved, unlocking value in assets and data that were previously siloed within a single organization. Governance and incentive models can be created to enable secure collaboration in new ways, without compromising the integrity of an individual organization. The technology is most powerful in ecosystems of “coopetition”, where privacy and security requirements are high. Multi-party systems establish new models of trust, with easy to prove outcomes that minimize the need for third party arbitration, and costly investigation into disputes. ",
    "url": "/firefly/head/overview/multiparty.html#introduction",
    "relUrl": "/overview/multiparty.html#introduction"
  },"520": {
    "doc": "Multi-party Systems",
    "title": "Points of difference",
    "content": "Integration with existing systems of record is critical to unlock the potential of these new ecosystems. So multi-party systems embrace the existing investments of each party, rather than seeking to unify or replace them. Multi-party systems are different from centralized third-party systems, because each party retains sovereignty over: . | Their application instance | Their private data | Their business processes | Their proprietary business logic | Their internal business processes and IT controls | . ",
    "url": "/firefly/head/overview/multiparty.html#points-of-difference",
    "relUrl": "/overview/multiparty.html#points-of-difference"
  },"521": {
    "doc": "Multi-party Systems",
    "title": "Multi-party Systems",
    "content": " ",
    "url": "/firefly/head/overview/multiparty.html",
    "relUrl": "/overview/multiparty.html"
  },"522": {
    "doc": "Multiparty Event Sequencing",
    "title": "Multiparty Event Sequencing",
    "content": " ",
    "url": "/firefly/head/architecture/multiparty_event_sequencing.html",
    "relUrl": "/architecture/multiparty_event_sequencing.html"
  },"523": {
    "doc": "Multiparty Event Sequencing",
    "title": "Table of contents",
    "content": ". | Transaction Submission | Blockchain Ordering | Message Assembly | Event Processing | . ",
    "url": "/firefly/head/architecture/multiparty_event_sequencing.html#table-of-contents",
    "relUrl": "/architecture/multiparty_event_sequencing.html#table-of-contents"
  },"524": {
    "doc": "Multiparty Event Sequencing",
    "title": "Transaction Submission",
    "content": ". | An individual FireFly instance preserves the order that it received messages from application instances. | Where possible, batching is used to roll-up hundreds of transactions into a single blockchain transaction. | Blockchain allows these messages to be globally sequenced with messages submitted by other members of the network. | . ",
    "url": "/firefly/head/architecture/multiparty_event_sequencing.html#transaction-submission",
    "relUrl": "/architecture/multiparty_event_sequencing.html#transaction-submission"
  },"525": {
    "doc": "Multiparty Event Sequencing",
    "title": "Blockchain Ordering",
    "content": ". | All member FireFly runtimes see every transaction in the same sequence. | This includes when transactions are being submitted by both sides concurrently. | . ",
    "url": "/firefly/head/architecture/multiparty_event_sequencing.html#blockchain-ordering",
    "relUrl": "/architecture/multiparty_event_sequencing.html#blockchain-ordering"
  },"526": {
    "doc": "Multiparty Event Sequencing",
    "title": "Message Assembly",
    "content": ". | A queue of events is maintained for each matching app subscription. | The public/private payloads travel separately to the blockchain, and arrive at different times. FireFly assembles these together prior to delivery. | If data associated with a blockchain transaction is late, or does not arrive, all messages on the same “context” will be blocked. | It is good practice to send messages that don’t need to be processed in order, with different “context” fields. For example use the ID of your business transaction, or other long-running process / customer identifier. | . ",
    "url": "/firefly/head/architecture/multiparty_event_sequencing.html#message-assembly",
    "relUrl": "/architecture/multiparty_event_sequencing.html#message-assembly"
  },"527": {
    "doc": "Multiparty Event Sequencing",
    "title": "Event Processing",
    "content": ". | Events are processed consistently by all parties. | All FireFly runtimes see every event that they are subscribed to, in the same sequence. | The submitter must also apply the logic only in the sequence ordered by the blockhain. It cannot assume the order even if it is the member that submitted it. | . ",
    "url": "/firefly/head/architecture/multiparty_event_sequencing.html#event-processing",
    "relUrl": "/architecture/multiparty_event_sequencing.html#event-processing"
  },"528": {
    "doc": "Multi-party process flow",
    "title": "Multi-party process flow",
    "content": " ",
    "url": "/firefly/head/overview/multiparty_process_flow.html",
    "relUrl": "/overview/multiparty_process_flow.html"
  },"529": {
    "doc": "Multi-party process flow",
    "title": "Table of contents",
    "content": ". | Building multi-party flows | Innovate fast | Consider the on-chain toolbox too | . ",
    "url": "/firefly/head/overview/multiparty_process_flow.html#table-of-contents",
    "relUrl": "/overview/multiparty_process_flow.html#table-of-contents"
  },"530": {
    "doc": "Multi-party process flow",
    "title": "Building multi-party flows",
    "content": "The ability to globally sequence events across parties is a game changing capability of multi-party systems. FireFly is designed to allow developers to harnesses that power in the application layer, to build sophisticated multi-party APIs and user experiences. | Build multi-party business processes where there is one agreed outcome: . | Agree the trigger, inputs, outputs of each step in the process | Agree any common “rules of the road” must be adhered to | . | Look back at your shared history, when deciding to commit to the next step: . | Fast rich-query cache, backed by a private database | Initiate the next step through automated or manual decision making | Only consider a step final once it’s multi-party sequence has been confirmed | . | Gain big efficiencies in how multi-party business processes work: . | Once locked in, a step is consider final - attested to by the party | If two parties submit conflicting actions, one wins, and one loses | Avoids complex compensation logic in the business orchestration layer | Provides one clear source of truth to quickly resolve multi-party disputes | . | Program multi-party apps using the tools you know: . | REST APIs for triggering the next step in a process, and querying history | WebSockets and Webhooks for events (pluggable to other event transports) | Remember - each party runs their own copy of the app, with their own private data | . | Allow each party to integrate into their existing core systems: . | Realtime or batch | Human workflows | Proprietary business logic that is unique to one party | . | Avoid sensitive data written to the blockchain: . | Works in bi-lateral and multi-lateral scenarios | Designed to limit leaking other “metadata” about the transaction as well | Share partial history with different participants in a | . | No requirement to write custom on-chain smart contract logic: . | Can be combined with rich custom on-chain logic as well | . | . ",
    "url": "/firefly/head/overview/multiparty_process_flow.html#building-multi-party-flows",
    "relUrl": "/overview/multiparty_process_flow.html#building-multi-party-flows"
  },"531": {
    "doc": "Multi-party process flow",
    "title": "Innovate fast",
    "content": "Building a successful multi-party system is often about business experimentation, and business results. Proving the efficiency gains, and new business models, made possible by working together in a new way under a new system of trust. Things that can get in the way of that innovation, can include concerns over data privacy, technology maturity, and constraints on autonomy of an individual party in the system. An easy to explain position on how new technology components are used, where data lives, and how business process independence is maintained can really help parties make the leap of faith necessary to take the step towards a new model. Keys to success often include building great user experiences that help digitize clunky decades old manual processes. Also easy to integrate with APIs, what embrace the existing core systems of record that are establish within each party. ",
    "url": "/firefly/head/overview/multiparty_process_flow.html#innovate-fast",
    "relUrl": "/overview/multiparty_process_flow.html#innovate-fast"
  },"532": {
    "doc": "Multi-party process flow",
    "title": "Consider the on-chain toolbox too",
    "content": "In the deterministic compute section we talked about the value that deterministic execution of multi-party logic can have. Either through on-chain execution, or advanced privacy preserving techniques. It’s important to state that almost every process can be enhanced with more sophisticated on-chain constructs like tokens. Maybe it’s to build a token economy that enhances the value parties get from the system, or encourages healthy participation (and discourages leaching value). Or maybe it’s to track exactly which party owns a document, asset, or action within a process using NFTs. There are also cases where the foundation constructs are insufficient to implement the level of automation or efficiency you need in your multi-party process. Here making the investment in building bespoke on-chain logic, or apply advanced cryptographic techniques, is the linchpin to a successful multi-party ecosystem. ",
    "url": "/firefly/head/overview/multiparty_process_flow.html#consider-the-on-chain-toolbox-too",
    "relUrl": "/overview/multiparty_process_flow.html#consider-the-on-chain-toolbox-too"
  },"533": {
    "doc": "Namespace",
    "title": "Namespace",
    "content": " ",
    "url": "/firefly/head/reference/types/namespace.html",
    "relUrl": "/reference/types/namespace.html"
  },"534": {
    "doc": "Namespace",
    "title": "Table of contents",
    "content": ". | Namespace . | Example | Field Descriptions | . | . ",
    "url": "/firefly/head/reference/types/namespace.html#table-of-contents",
    "relUrl": "/reference/types/namespace.html#table-of-contents"
  },"535": {
    "doc": "Namespace",
    "title": "Namespace",
    "content": "A namespace is a logical isolation domain for different applications, or tenants, that share the FireFly node. Significant evolution of the Hyperledger FireFly namespace construct, is proposed under FIR-12 . Example . { \"name\": \"default\", \"networkName\": \"default\", \"description\": \"Default predefined namespace\", \"created\": \"2022-05-16T01:23:16Z\" } . Field Descriptions . | Field Name | Description | Type | . | name | The local namespace name | string | . | networkName | The shared namespace name within the multiparty network | string | . | description | A description of the namespace | string | . | created | The time the namespace was created | FFTime | . ",
    "url": "/firefly/head/reference/types/namespace.html",
    "relUrl": "/reference/types/namespace.html"
  },"536": {
    "doc": "Namespaces",
    "title": "Namespaces",
    "content": " ",
    "url": "/firefly/head/reference/namespaces.html",
    "relUrl": "/reference/namespaces.html"
  },"537": {
    "doc": "Namespaces",
    "title": "Table of contents",
    "content": ". | Introduction to Namespaces . | Multi-party Namespaces | Gateway Namespaces | . | Configuration . | Config Restrictions | . | Definitions | Local Definitions | . ",
    "url": "/firefly/head/reference/namespaces.html#table-of-contents",
    "relUrl": "/reference/namespaces.html#table-of-contents"
  },"538": {
    "doc": "Namespaces",
    "title": "Introduction to Namespaces",
    "content": "Namespaces are a construct for segregating data and operations within a FireFly supernode. Each namespace is an isolated environment within a FireFly runtime, that allows independent configuration of: . | Plugin and infrastructure components | API security | Identity broadcasting | On-chain data indexing | How datatypes, locations of on-chain contrats, etc. should be shared | . They can be thought of in two basic modes: . Multi-party Namespaces . This namespace is shared with one or more other FireFly nodes. It requires three types of communication plugins - blockchain, data exchange, and shared storage. Organization and node identities must be claimed with an identity broadcast when joining the namespace, which establishes credentials for blockchain and off-chain communication. Shared objects can be defined in the namespace (such as datatypes and token pools), and details of them will be implicitly broadcast to other members. This type of namespace is used when multiple parties need to share on- and off-chain data and agree upon the ordering and authenticity of that data. For more information, see the multi-party system overview. Gateway Namespaces . Nothing in this namespace will be shared automatically, and no assumptions are made about whether other parties connected through this namespace are also using Hyperledger FireFly. Plugins for data exchange and shared storage are not supported. If any identities or definitions are created in this namespace, they will be stored in the local database, but will not be shared implicitly outside the node. This type of namespace is mainly used when interacting directly with a blockchain, without assuming that the interaction needs to conform to FireFly’s multi-party system model. ",
    "url": "/firefly/head/reference/namespaces.html#introduction-to-namespaces",
    "relUrl": "/reference/namespaces.html#introduction-to-namespaces"
  },"539": {
    "doc": "Namespaces",
    "title": "Configuration",
    "content": "FireFly nodes can be configured with one or many namespaces of different modes. This means that a single FireFly node can be used to interact with multiple distinct blockchains, multiple distinct token economies, and multiple business networks. Below is an example plugin and namespace configuration containing both a multi-party and gateway namespace: . plugins: database: - name: database0 type: sqlite3 sqlite3: migrations: auto: true url: /etc/firefly/db?_busy_timeout=5000 blockchain: - name: blockchain0 type: ethereum ethereum: ethconnect: url: http://ethconnect_0:8080 topic: \"0\" - name: blockchain1 type: ethereum ethereum: ethconnect: url: http://ethconnect_01:8080 topic: \"0\" dataexchange: - name: dataexchange0 type: ffdx ffdx: url: http://dataexchange_0:3000 sharedstorage: - name: sharedstorage0 type: ipfs ipfs: api: url: http://ipfs_0:5001 gateway: url: http://ipfs_0:8080 tokens: - name: erc20_erc721 broadcastName: erc20_erc721 type: fftokens fftokens: url: http://tokens_0_0:3000 namespaces: default: alpha predefined: - name: alpha description: Default predefined namespace defaultKey: 0x123456 plugins: [database0, blockchain0, dataexchange0, sharedstorage0, erc20_erc721] multiparty: networkNamespace: alpha enabled: true org: name: org0 description: org0 key: 0x123456 node: name: node0 description: node0 contract: - location: address: 0x4ae50189462b0e5d52285f59929d037f790771a6 firstEvent: 0 - location: address: 0x3c1bef20a7858f5c2f78bda60796758d7cafff27 firstEvent: 5000 - name: omega defaultkey: 0x48a54f9964d7ceede2d6a8b451bf7ad300c7b09f description: Gateway namespace plugins: [database0, blockchain1, erc20_erc721] . The namespaces.predefined object contains the follow sub-keys: . | defaultKey is a blockchain key used to sign transactions when none is specified (in multi-party mode, defaults to the org key) | plugins is an array of plugin names to be activated for this namespace (defaults to all available plugins if omitted) | multiparty.networkNamespace is the namespace name to be sent in plugin calls, if it differs from the locally used name (useful for interacting with multiple shared namespaces of the same name - defaults to the value of name) | multiparty.enabled controls if multi-party mode is enabled (defaults to true if an org key or org name is defined on this namespace or in the deprecated org section at the root) | multiparty.org is the root org identity for this multi-party namespace (containing name, description, and key) | multiparty.node is the local node identity for this multi-party namespace (containing name and description) | multiparty.contract is an array of objects describing the location(s) of a FireFly multi-party smart contract. Its children are blockchain-agnostic location and firstEvent fields, with formats identical to the same fields on custom contract interfaces and contract listeners. The blockchain plugin will interact with the first contract in the list until instructions are received to terminate it and migrate to the next. | . Config Restrictions . | name must be unique on this node | for historical reasons, “ff_system” is a reserved string and cannot be used as a name or multiparty.networkNamespace | a database plugin is required for every namespace | if multiparty.enabled is true, plugins must include one each of blockchain, dataexchange, and sharedstorage | if multiparty.enabled is false, plugins must not include dataexchange or sharedstorage | at most one of each type of plugin is allowed per namespace, except for tokens (which may have many per namespace) | . All namespaces must be called out in the FireFly config file in order to be valid. Namespaces found in the database but not represented in the config file will be ignored. ",
    "url": "/firefly/head/reference/namespaces.html#configuration",
    "relUrl": "/reference/namespaces.html#configuration"
  },"540": {
    "doc": "Namespaces",
    "title": "Definitions",
    "content": "In FireFly, definitions are immutable payloads that are used to define identities, datatypes, smart contract interfaces, token pools, and other constructs. Each type of definition in FireFly has a schema that it must adhere to. Some definitions also have a name and a version which must be unique within a namespace. In a multiparty namespace, definitions are broadcasted to other organizations. ",
    "url": "/firefly/head/reference/namespaces.html#definitions",
    "relUrl": "/reference/namespaces.html#definitions"
  },"541": {
    "doc": "Namespaces",
    "title": "Local Definitions",
    "content": "The following are all “definition” types in FireFly: . | datatype | group | token pool | contract interface | contract API | organization (deprecated) | node (deprecated) | identity claim | identity verification | identity update | . For gateway namespaces, the APIs which create these definitions will become an immediate local database insert, instead of performing a broadcast. Additional caveats: . | identities in this mode will not undergo any claim/verification process, but will be created and stored locally | datatypes and groups will not be supported, as they are only useful in the context of messaging (which is disabled in gateway namespaces) | . ",
    "url": "/firefly/head/reference/namespaces.html#local-definitions",
    "relUrl": "/reference/namespaces.html#local-definitions"
  },"542": {
    "doc": "Node Component Architecture",
    "title": "Node Component Architecture",
    "content": " ",
    "url": "/firefly/head/architecture/node_component_architecture.html",
    "relUrl": "/architecture/node_component_architecture.html"
  },"543": {
    "doc": "Node Component Architecture",
    "title": "Table of contents",
    "content": ". | What is a FireFly Node? | Runtimes | Responsibilities &amp; Pluggable Elements | Code Structure | . ",
    "url": "/firefly/head/architecture/node_component_architecture.html#table-of-contents",
    "relUrl": "/architecture/node_component_architecture.html#table-of-contents"
  },"544": {
    "doc": "Node Component Architecture",
    "title": "What is a FireFly Node?",
    "content": "The core architecture of a FireFly node can be broken down into the following three areas: . | The various runtimes encapsulating the node. | The core runtime responsibilities and pluggable elements. | The actual code running inside the node. | . ",
    "url": "/firefly/head/architecture/node_component_architecture.html#what-is-a-firefly-node",
    "relUrl": "/architecture/node_component_architecture.html#what-is-a-firefly-node"
  },"545": {
    "doc": "Node Component Architecture",
    "title": "Runtimes",
    "content": "What fundamentally is a node - left side of the above diagram. | It is a collection of multiple runtimes with a single unified HTTPS/Websocket API (exposed by the Core). | It has a private database, containing your private data, and data received from others in the network. | It has connectivity out to other parties in the network, through runtimes (Blockchain, Shared Filesystems, Messaging etc.). | . ",
    "url": "/firefly/head/architecture/node_component_architecture.html#runtimes",
    "relUrl": "/architecture/node_component_architecture.html#runtimes"
  },"546": {
    "doc": "Node Component Architecture",
    "title": "Responsibilities &amp; Pluggable Elements",
    "content": "What are the core runtime responsibilities, and pluggable elements - right side of the above diagram. | The core elements of function that FireFly performs, and which runtime is responsible. | This means some insight into core itself, and the jobs it performs, but not full code structure. | More importantly, what the split of responsibilities is between Connectors and Infrastructure Runtimes. | Connectors are the bridging runtimes, that know how to talk to a particular runtime. | They run separately to the core (like a microservice architecture of an app). | They can be written in any language (not just Go) - Java, TypeScript, Rust, Python, .NET etc. | They can use any network transport (not just HTTPS/Websockets) - GRPC, AMQP, UDP etc. | They connect to the core with a Golang shim - see separate Plugin Architecture discussion. | In some special cases (like the Database) the Golang shim does not need a connector runtime. | . | . | Infrastructure Runtimes are the core runtimes for multi-party system activities. | Blockchain nodes - Ethereum (Hyperledger Besu, Quorum, Geth), Hyperledger Fabric, Corda etc. | Shared strorage - IPFS etc. | Database - PostreSQL, CouchDB etc. | . | . | . | . ",
    "url": "/firefly/head/architecture/node_component_architecture.html#responsibilities--pluggable-elements",
    "relUrl": "/architecture/node_component_architecture.html#responsibilities--pluggable-elements"
  },"547": {
    "doc": "Node Component Architecture",
    "title": "Code Structure",
    "content": "What is the code structure inside the core. | The README.md is the reference for this. | Developers contributing to FireFly, on the core, or building new plugins, need this level of detail. | A reconciliation is underway to ensure the medium-level view correlates well with this code structure. | . | . ",
    "url": "/firefly/head/architecture/node_component_architecture.html#code-structure",
    "relUrl": "/architecture/node_component_architecture.html#code-structure"
  },"548": {
    "doc": "Operation",
    "title": "Operation",
    "content": " ",
    "url": "/firefly/head/reference/types/operation.html",
    "relUrl": "/reference/types/operation.html"
  },"549": {
    "doc": "Operation",
    "title": "Table of contents",
    "content": ". | Operation . | Example | Field Descriptions | . | . ",
    "url": "/firefly/head/reference/types/operation.html#table-of-contents",
    "relUrl": "/reference/types/operation.html#table-of-contents"
  },"550": {
    "doc": "Operation",
    "title": "Operation",
    "content": "Operations are stateful external actions that FireFly triggers via plugins. They can succeed or fail. They are grouped into Transactions in order to accomplish a single logical task. The diagram below shows the different types of operation that are performed by each FireFly plugin type. The color coding (and numbers) map those different types of operation to the Transaction types that include those operations. Example . { \"id\": \"04a8b0c4-03c2-4935-85a1-87d17cddc20a\", \"namespace\": \"ns1\", \"tx\": \"99543134-769b-42a8-8be4-a5f8873f969d\", \"type\": \"sharedstorage_upload_batch\", \"status\": \"Succeeded\", \"plugin\": \"ipfs\", \"input\": { \"id\": \"80d89712-57f3-48fe-b085-a8cba6e0667d\" }, \"output\": { \"payloadRef\": \"QmWj3tr2aTHqnRYovhS2mQAjYneRtMWJSU4M4RdAJpJwEC\" }, \"created\": \"2022-05-16T01:23:15Z\" } . Field Descriptions . | Field Name | Description | Type | . | id | The UUID of the operation | UUID | . | namespace | The namespace of the operation | string | . | tx | The UUID of the FireFly transaction the operation is part of | UUID | . | type | The type of the operation | FFEnum:\"blockchain_pin_batch\"\"blockchain_network_action\"\"blockchain_invoke\"\"sharedstorage_upload_batch\"\"sharedstorage_upload_blob\"\"sharedstorage_upload_value\"\"sharedstorage_download_batch\"\"sharedstorage_download_blob\"\"dataexchange_send_batch\"\"dataexchange_send_blob\"\"token_create_pool\"\"token_activate_pool\"\"token_transfer\"\"token_approval\" | . | status | The current status of the operation | OpStatus | . | plugin | The plugin responsible for performing the operation | string | . | input | The input to this operation | JSONObject | . | output | Any output reported back from the plugin for this operation | JSONObject | . | error | Any error reported back from the plugin for this operation | string | . | created | The time the operation was created | FFTime | . | updated | The last update time of the operation | FFTime | . | retry | If this operation was initiated as a retry to a previous operation, this field points to the UUID of the operation being retried | UUID | . ",
    "url": "/firefly/head/reference/types/operation.html",
    "relUrl": "/reference/types/operation.html"
  },"551": {
    "doc": "pages.optimism",
    "title": "Optimism Testnet",
    "content": " ",
    "url": "/firefly/head/tutorials/chains/optimism.html#optimism-testnet",
    "relUrl": "/tutorials/chains/optimism.html#optimism-testnet"
  },"552": {
    "doc": "pages.optimism",
    "title": "Table of contents",
    "content": ". | Previous steps: Install the FireFly CLI | Create an evmconnect.yml config file | Creating a new stack | Start the stack | Get some Optimism . | Confirm the transaction on Blockcscout | . | Use the public testnet | . Starting with FireFly v1.1, it’s easy to connect to public Ethereum chains. This guide will walk you through the steps to create a local FireFly development environment and connect it to the Optimism Goerli testnet. ",
    "url": "/firefly/head/tutorials/chains/optimism.html#table-of-contents",
    "relUrl": "/tutorials/chains/optimism.html#table-of-contents"
  },"553": {
    "doc": "pages.optimism",
    "title": "Previous steps: Install the FireFly CLI",
    "content": "If you haven’t set up the FireFly CLI already, please go back to the Getting Started guide and read the section on how to Install the FireFly CLI. ← ① Install the FireFly CLI . ",
    "url": "/firefly/head/tutorials/chains/optimism.html#previous-steps-install-the-firefly-cli",
    "relUrl": "/tutorials/chains/optimism.html#previous-steps-install-the-firefly-cli"
  },"554": {
    "doc": "pages.optimism",
    "title": "Create an evmconnect.yml config file",
    "content": "In order to connect to the Optimism testnet, you will need to set a few configuration options for the evmconnect blockchain connector. Create a text file called evmconnect.yml with the following contents: . confirmations: required: 4 # choose the number of confirmations you require policyengine.simple: fixedGasPrice: null gasOracle: mode: connector . For more info about confirmations, see Public vs. Permissioned . For this tutorial, we will assume this file is saved at ~/Desktop/evmconnect.yml. If your path is different, you will need to adjust the path in the next command below. ",
    "url": "/firefly/head/tutorials/chains/optimism.html#create-an-evmconnectyml-config-file",
    "relUrl": "/tutorials/chains/optimism.html#create-an-evmconnectyml-config-file"
  },"555": {
    "doc": "pages.optimism",
    "title": "Creating a new stack",
    "content": "To create a local FireFly development stack and connect it to the Optimism testnet, we will use command line flags to customize the following settings: . | Create a new stack named optimism with 1 member | Disable multiparty mode. We are going to be using this FireFly node as a Web3 gateway, and we don’t need to communicate with a consortium here | Connect to an ethereum network | Use the evmconnect blockchain connector | Use an remote RPC node. This will create a signer locally, so that our signing key never leaves the development machine. | See the optimism docs and select an HTTPS RPC endpoint. | Set the chain ID to 420 (the correct ID for the Optimism testnet) | Merge the custom config created above with the generated evmconnect config file | . To do this, run the following command: . ff init optimism 1 \\ --multiparty=false \\ -b ethereum \\ -c evmconnect \\ -n remote-rpc \\ --remote-node-url &lt;selected RPC endpoint&gt; \\ --chain-id 420 \\ --connector-config ~/Desktop/evmconnect.yml . ",
    "url": "/firefly/head/tutorials/chains/optimism.html#creating-a-new-stack",
    "relUrl": "/tutorials/chains/optimism.html#creating-a-new-stack"
  },"556": {
    "doc": "pages.optimism",
    "title": "Start the stack",
    "content": "Now you should be able to start your stack by running: . ff start optimism . After some time it should print out the following: . Web UI for member '0': http://127.0.0.1:5000/ui Sandbox UI for member '0': http://127.0.0.1:5109 To see logs for your stack run: ff logs optimism . ",
    "url": "/firefly/head/tutorials/chains/optimism.html#start-the-stack",
    "relUrl": "/tutorials/chains/optimism.html#start-the-stack"
  },"557": {
    "doc": "pages.optimism",
    "title": "Get some Optimism",
    "content": "At this point you should have a working FireFly stack, talking to a public chain. However, you won’t be able to run any transactions just yet, because you don’t have any way to pay for gas. A testnet faucet can give us some OP, the native token for Optimism. First, you will need to know what signing address your FireFly node is using. To check that, you can run: . ff accounts list optimism [ { \"address\": \"0x235461d246ab95d367925b4e91bd2755a921fdd8\", \"privateKey\": \"...\" } ] . Copy the address listed in the output from this command. Go to https://optimismfaucet.xyz/. You will need to login to your Github account and paste the address in the form. Confirm the transaction on Blockcscout . You should be able to go lookup your account on Blockscout for Optimism testnet https://blockscout.com/optimism/goerli and see that you now have a balance of 100 OP. Simply paste in your account address to search for it. ",
    "url": "/firefly/head/tutorials/chains/optimism.html#get-some-optimism",
    "relUrl": "/tutorials/chains/optimism.html#get-some-optimism"
  },"558": {
    "doc": "pages.optimism",
    "title": "Use the public testnet",
    "content": "Now that you have everything set up, you can follow one of the other FireFly guides such as Using Tokens or Custom Smart Contracts. For detailed instructions on deploying a custom smart contract to Optimism, please see the Optimism docs for instructions using various tools. ",
    "url": "/firefly/head/tutorials/chains/optimism.html#use-the-public-testnet",
    "relUrl": "/tutorials/chains/optimism.html#use-the-public-testnet"
  },"559": {
    "doc": "pages.optimism",
    "title": "pages.optimism",
    "content": " ",
    "url": "/firefly/head/tutorials/chains/optimism.html",
    "relUrl": "/tutorials/chains/optimism.html"
  },"560": {
    "doc": "Example Transaction Flow",
    "title": "Example Transaction Flow (Ping Pong)",
    "content": " ",
    "url": "/firefly/head/architecture/ping_pong_txflow.html#example-transaction-flow-ping-pong",
    "relUrl": "/architecture/ping_pong_txflow.html#example-transaction-flow-ping-pong"
  },"561": {
    "doc": "Example Transaction Flow",
    "title": "Table of contents",
    "content": ". | Overview | Broadcast Public Description of Binary Data Asset (Member 1) | Receive Public Description &amp; Request Asset Data (Member 2) | Authorize &amp; Transfer Data (Member 1) | Receive Data Asset (Member 2) | . ",
    "url": "/firefly/head/architecture/ping_pong_txflow.html#table-of-contents",
    "relUrl": "/architecture/ping_pong_txflow.html#table-of-contents"
  },"562": {
    "doc": "Example Transaction Flow",
    "title": "Overview",
    "content": ". This demonstrates the problem that at its core FireFly is there to solve. The internal plumbing complexity of just a very simple set of Enterprise blockchain / multi-party system interactions. | Party A: Establish existence of a digital asset. | Nothing more than some binary data (an image, a document, a specification etc.). | . | Party A: Broadcast some information about that asset to everyone, using blockchain to record, sequence and propagate. | So people can find it, or part of a more sophisticated workflow. | . | Party B: Request the actual data - with evidence of that request tied to the blockchain. | Including some private data that’s sent to the Party A, reliably off-chain. | . | Party A: Authorize the request, and send the data privately to Party B. | In this example there’s no blockchain involved in this step. | . | . This is the kind of thing that enterprise projects have been solving ground-up since the dawn of enterprise blockchain, and the level of engineering required that is completely detached from business value, is very high. The “tramlines” view shows how FireFly’s pluggable model makes the job of the developer really simple: . | A few simple API calls from a modern web app. | Event triggered execution of application logic. | . This is deliberately a simple flow, and all kinds of additional layers might well layer on (and fit within the FireFly model): . | NFTs to track ownership etc. related to the digital asset. | Tokenized rewards/payments integrated with the authorization of the transfer of data. | Proof of deterministic execution of the logic to perform the authorization (on-chain, TEEs, ZKPs). | Human workflow, that is of course completely non-deterministic. | Multiple additional process steps, deterministic or not. | Inclusion of multiple additional parties (maybe it’s a request-for-tender, submit-tender flow for example). | etc. | . ",
    "url": "/firefly/head/architecture/ping_pong_txflow.html#overview",
    "relUrl": "/architecture/ping_pong_txflow.html#overview"
  },"563": {
    "doc": "Example Transaction Flow",
    "title": "Broadcast Public Description of Binary Data Asset (Member 1)",
    "content": ". | Upload Blob of the actual data . | Returns a hash of the payload | . | Upload JSON containing the public index data . | Includes the hash of the full payload | . | Send a broadcast message with the public index data . | Agree upon a primary key of the data as the “context” | . | . ",
    "url": "/firefly/head/architecture/ping_pong_txflow.html#broadcast-public-description-of-binary-data-asset-member-1",
    "relUrl": "/architecture/ping_pong_txflow.html#broadcast-public-description-of-binary-data-asset-member-1"
  },"564": {
    "doc": "Example Transaction Flow",
    "title": "Receive Public Description &amp; Request Asset Data (Member 2)",
    "content": ". | Store data in your own off-chain database for rich, efficient query | Run automated logic to decide if you want to request the full data | Upload JSON for data request | Send a private message . | Backed by blockchain in this flow | . | . ",
    "url": "/firefly/head/architecture/ping_pong_txflow.html#receive-public-description--request-asset-data-member-2",
    "relUrl": "/architecture/ping_pong_txflow.html#receive-public-description--request-asset-data-member-2"
  },"565": {
    "doc": "Example Transaction Flow",
    "title": "Authorize &amp; Transfer Data (Member 1)",
    "content": ". | Inpsect the request data | Retrieve data asset by hash | Send the private data in a private message . | No blockchain in this flow | . | . ",
    "url": "/firefly/head/architecture/ping_pong_txflow.html#authorize--transfer-data-member-1",
    "relUrl": "/architecture/ping_pong_txflow.html#authorize--transfer-data-member-1"
  },"566": {
    "doc": "Example Transaction Flow",
    "title": "Receive Data Asset (Member 2)",
    "content": ". | Receive a link to your local copy of the asset data | . ",
    "url": "/firefly/head/architecture/ping_pong_txflow.html#receive-data-asset-member-2",
    "relUrl": "/architecture/ping_pong_txflow.html#receive-data-asset-member-2"
  },"567": {
    "doc": "Example Transaction Flow",
    "title": "Example Transaction Flow",
    "content": " ",
    "url": "/firefly/head/architecture/ping_pong_txflow.html",
    "relUrl": "/architecture/ping_pong_txflow.html"
  },"568": {
    "doc": "Plugin Architecture",
    "title": "Plugin Architecture",
    "content": " ",
    "url": "/firefly/head/architecture/plugin_architecture.html",
    "relUrl": "/architecture/plugin_architecture.html"
  },"569": {
    "doc": "Plugin Architecture",
    "title": "Table of contents",
    "content": ". | Overview | FireFly Core | Plugin for Connector | Connector | Infrastructure Runtime | . This diagram shows the various plugins that are currently in the codebase and the layers in each plugin . This diagram shows the details of what goes into each layer of a FireFly plugin . ",
    "url": "/firefly/head/architecture/plugin_architecture.html#table-of-contents",
    "relUrl": "/architecture/plugin_architecture.html#table-of-contents"
  },"570": {
    "doc": "Plugin Architecture",
    "title": "Overview",
    "content": "The FireFly node is built for extensibility, with separate pluggable runtimes orchestrated into a common API for developers. The mechanics of that pluggability for developers of new connectors is explained below: . This architecture is designed to provide separations of concerns to account for: . | Differences in code language for the low-level connection to a backend (Java for Corda for example) | Differences in transports, particularly for delivery of events: . | Between FireFly Core and the Connector . | Different transports other than HTTPS/WebSockets (GRPC etc.), and different wire protocols (socket.io, etc.) | . | Between the Connector and the underlying Infrastructure Runtime . | Often this is heavy lifting engineering within the connector | . | . | Differences in High Availability (HA) / Scale architectures . | Between FireFly Core, and the Connector . | Often for event management, and active/passive connector runtime is sufficient | . | Between the Connector and the Infrastructure Runtime . | The infrastructure runtimes have all kinds of variation here… think of the potential landscape here from PostreSQL through Besu/Fabric/Corda, to Hyperledger Avalon and even Main-net ethereum | . | . | . ",
    "url": "/firefly/head/architecture/plugin_architecture.html#overview",
    "relUrl": "/architecture/plugin_architecture.html#overview"
  },"571": {
    "doc": "Plugin Architecture",
    "title": "FireFly Core",
    "content": ". | Golang | N-way scalable cluster . | Database is also pluggable via this architecture | . | No long lived in-memory processing . | All micro-batching must be recoverable | . | Driven by single configuration set . | Viper semantics - file, env var, cmdline flags | . | . ",
    "url": "/firefly/head/architecture/plugin_architecture.html#firefly-core",
    "relUrl": "/architecture/plugin_architecture.html#firefly-core"
  },"572": {
    "doc": "Plugin Architecture",
    "title": "Plugin for Connector",
    "content": ". | Golang | Statically compiled in support at runtime . | Go dynamic plugin support too immature | . | Must be 100% FLOSS code (no GPL/LGPL etc.) | Contributed via PR to FF Core | Intended to be lightweight binding/mapping | Must adhere to FF Core Coding Standards | Scrutiny on addition of new frameworks/transports | . ",
    "url": "/firefly/head/architecture/plugin_architecture.html#plugin-for-connector",
    "relUrl": "/architecture/plugin_architecture.html#plugin-for-connector"
  },"573": {
    "doc": "Plugin Architecture",
    "title": "Connector",
    "content": ". | Node.js / Java / Golang, etc. | Runs/scales independently from FF core | Coded in any language, OSS or proprietary | One runtime or multiple | HA model can be active/passive or active/active | Expectation is all plugins need a connector . | Some exceptions exist (e.g. database plugin) | . | . ",
    "url": "/firefly/head/architecture/plugin_architecture.html#connector",
    "relUrl": "/architecture/plugin_architecture.html#connector"
  },"574": {
    "doc": "Plugin Architecture",
    "title": "Infrastructure Runtime",
    "content": ". | Besu, Quorum, Corda, Fabric, IPFS, Kafka, etc. | Runs/scales independently from FF Core | Coded in any language, OSS or proprietary | Not specific to FireFly | HA model can be active/passive or active/active | . ",
    "url": "/firefly/head/architecture/plugin_architecture.html#infrastructure-runtime",
    "relUrl": "/architecture/plugin_architecture.html#infrastructure-runtime"
  },"575": {
    "doc": "pages.polygon_testnet",
    "title": "Polygon Testnet",
    "content": " ",
    "url": "/firefly/head/tutorials/chains/polygon_testnet.html#polygon-testnet",
    "relUrl": "/tutorials/chains/polygon_testnet.html#polygon-testnet"
  },"576": {
    "doc": "pages.polygon_testnet",
    "title": "Table of contents",
    "content": ". | Previous steps: Install the FireFly CLI | Create an evmconnect.yml config file | Creating a new stack | Start the stack | Get some MATIC . | Confirm the transaction on Polygonscan | . | Use the public testnet | . Starting with FireFly v1.1, it’s easy to connect to public Ethereum chains. This guide will walk you through the steps to create a local FireFly development environment and connect it to the public Polygon Mumbai testnet. ",
    "url": "/firefly/head/tutorials/chains/polygon_testnet.html#table-of-contents",
    "relUrl": "/tutorials/chains/polygon_testnet.html#table-of-contents"
  },"577": {
    "doc": "pages.polygon_testnet",
    "title": "Previous steps: Install the FireFly CLI",
    "content": "If you haven’t set up the FireFly CLI already, please go back to the Getting Started guide and read the section on how to Install the FireFly CLI. ← ① Install the FireFly CLI . ",
    "url": "/firefly/head/tutorials/chains/polygon_testnet.html#previous-steps-install-the-firefly-cli",
    "relUrl": "/tutorials/chains/polygon_testnet.html#previous-steps-install-the-firefly-cli"
  },"578": {
    "doc": "pages.polygon_testnet",
    "title": "Create an evmconnect.yml config file",
    "content": "In order to connect to the Polygon testnet, you will need to set a few configuration options for the evmconnect blockchain connector. Create a text file called evmconnect.yml with the following contents: . confirmations: required: 4 # choose the number of confirmations you require policyengine.simple: fixedGasPrice: null gasOracle: mode: connector . For more info about confirmations, see Public vs. Permissioned . For this tutorial, we will assume this file is saved at ~/Desktop/evmconnect.yml. If your path is different, you will need to adjust the path in the next command below. ",
    "url": "/firefly/head/tutorials/chains/polygon_testnet.html#create-an-evmconnectyml-config-file",
    "relUrl": "/tutorials/chains/polygon_testnet.html#create-an-evmconnectyml-config-file"
  },"579": {
    "doc": "pages.polygon_testnet",
    "title": "Creating a new stack",
    "content": "To create a local FireFly development stack and connect it to the Polygon Mumbai testnet, we will use command line flags to customize the following settings: . | Create a new stack named polygon with 1 member | Disable multiparty mode. We are going to be using this FireFly node as a Web3 gateway, and we don’t need to communicate with a consortium here | Connect to an ethereum network | Use the evmconnect blockchain connector | Use an remote RPC node. This will create a signer locally, so that our signing key never leaves the development machine. | See the polygon docs and select an HTTPS RPC endpoint. | Set the chain ID to 80001 (the correct ID for the Polygon Mumbai testnet) | Merge the custom config created above with the generated evmconnect config file | . To do this, run the following command: . ff init polygon 1 \\ --multiparty=false \\ -b ethereum \\ -c evmconnect \\ -n remote-rpc \\ --remote-node-url &lt;selected RPC endpoint&gt; \\ --chain-id 80001 \\ --connector-config ~/Desktop/evmconnect.yml . ",
    "url": "/firefly/head/tutorials/chains/polygon_testnet.html#creating-a-new-stack",
    "relUrl": "/tutorials/chains/polygon_testnet.html#creating-a-new-stack"
  },"580": {
    "doc": "pages.polygon_testnet",
    "title": "Start the stack",
    "content": "Now you should be able to start your stack by running: . ff start polygon . After some time it should print out the following: . Web UI for member '0': http://127.0.0.1:5000/ui Sandbox UI for member '0': http://127.0.0.1:5109 To see logs for your stack run: ff logs polygon . ",
    "url": "/firefly/head/tutorials/chains/polygon_testnet.html#start-the-stack",
    "relUrl": "/tutorials/chains/polygon_testnet.html#start-the-stack"
  },"581": {
    "doc": "pages.polygon_testnet",
    "title": "Get some MATIC",
    "content": "At this point you should have a working FireFly stack, talking to a public chain. However, you won’t be able to run any transactions just yet, because you don’t have any way to pay for gas. A testnet faucet can give us some MATIC, the native token for Polygon. First, you will need to know what signing address your FireFly node is using. To check that, you can run: . ff accounts list polygon [ { \"address\": \"0x02d42c32a97c894486afbc7b717edff50c70b292\", \"privateKey\": \"...\" } ] . Copy the address listed in the output from this command. Go to https://faucet.polygon.technology/ and paste the address in the form. Click the Submit button, and then Confirm. Confirm the transaction on Polygonscan . You should be able to go lookup your account on Polygonscan for the Mumbai testnet https://mumbai.polygonscan.com/ and see that you now have a balance of 0.2 MATIC. Simply paste in your account address to search for it. You can also click on the Internal Txns tab from you account page to see the actual transfer of the MATIC from the faucet. ",
    "url": "/firefly/head/tutorials/chains/polygon_testnet.html#get-some-matic",
    "relUrl": "/tutorials/chains/polygon_testnet.html#get-some-matic"
  },"582": {
    "doc": "pages.polygon_testnet",
    "title": "Use the public testnet",
    "content": "Now that you have everything set up, you can follow one of the other FireFly guides such as Using Tokens or Custom Smart Contracts. For detailed instructions on deploying a custom smart contract to Polygon, please see the Polygon docs for instructions using various tools. ",
    "url": "/firefly/head/tutorials/chains/polygon_testnet.html#use-the-public-testnet",
    "relUrl": "/tutorials/chains/polygon_testnet.html#use-the-public-testnet"
  },"583": {
    "doc": "pages.polygon_testnet",
    "title": "pages.polygon_testnet",
    "content": " ",
    "url": "/firefly/head/tutorials/chains/polygon_testnet.html",
    "relUrl": "/tutorials/chains/polygon_testnet.html"
  },"584": {
    "doc": "Privately send data",
    "title": "Privately send data",
    "content": " ",
    "url": "/firefly/head/tutorials/private_send.html",
    "relUrl": "/tutorials/private_send.html"
  },"585": {
    "doc": "Privately send data",
    "title": "Table of contents",
    "content": ". | Quick reference | Additional info | Example 1: Pinned private send of in-line string data | Example message response | Example 2: Unpinned private send of in-line string data | Example 3: Inline object data to a topic (no datatype verification) | Notes on why setting a topic is important | Example 3: Upload a blob with metadata and send privately . | Multipart form post of a file | Example data response from Blob upload | Send the uploaded data privately | . | Sending Private Messages using the Sandbox | . ",
    "url": "/firefly/head/tutorials/private_send.html#table-of-contents",
    "relUrl": "/tutorials/private_send.html#table-of-contents"
  },"586": {
    "doc": "Privately send data",
    "title": "Quick reference",
    "content": ". | Sends a message to a restricted set of parties . | The message describes who sent it, to whom, and exactly what data was sent | . | A message has one or more attached pieces of business data . | Can be sent in-line, uploaded in advanced, or received from other parties | Can include smaller JSON payloads suitable for database storage . | These can be verified against a datatype | . | Can include references to large (multi megabyte/gigabyte) Blob data | . | A group specifies who has visibility to the data . | The author must be included in the group - auto-added if omitted | Can be specified in-line in the message by listing recipients directly | Can be referred to by hash | . | Private sends are optionally sequenced via pinning to the blockchain . | If the send is pinned: . | The blockchain does not contain any data, just a hash pin . | Even the ordering context (topic) is obscured in the on-chain data | This is true regardless of whether a restricted set of participants are maintaining the ledger, such as in the case of a Fabric Channel. | . | The message should not be considered confirmed (even by the sender) until it has been sequenced via the blockchain and a message_confirmed event occurs | Batched for efficiency . | One batch can pin hundreds of private message sends | The batch flows privately off-chain from the sender to each recipient | . | . | If the send is unpinned: . | No data is written to the blockchain at all | The message is marked confirmed immediately . | The sender receives a message_confirmed event immediately | . | The other parties in the group get message_confirmed events as soon as the data arrives | . | . | . ",
    "url": "/firefly/head/tutorials/private_send.html#quick-reference",
    "relUrl": "/tutorials/private_send.html#quick-reference"
  },"587": {
    "doc": "Privately send data",
    "title": "Additional info",
    "content": ". | Key Concepts: Private data exchange | Swagger: POST /api/v1/namespaces/{ns}/messages/private | . ",
    "url": "/firefly/head/tutorials/private_send.html#additional-info",
    "relUrl": "/tutorials/private_send.html#additional-info"
  },"588": {
    "doc": "Privately send data",
    "title": "Example 1: Pinned private send of in-line string data",
    "content": "POST /api/v1/namespaces/default/messages/private . { \"data\": [ { \"value\": \"a string\" } ], \"group\": { \"members\": [ { \"identity\": \"org_1\" } ] } } . ",
    "url": "/firefly/head/tutorials/private_send.html#example-1-pinned-private-send-of-in-line-string-data",
    "relUrl": "/tutorials/private_send.html#example-1-pinned-private-send-of-in-line-string-data"
  },"589": {
    "doc": "Privately send data",
    "title": "Example message response",
    "content": "Status: 202 Accepted - the message is on it’s way, but has not yet been confirmed. { \"header\": { \"id\": \"c387e9d2-bdac-44cc-9dd5-5e7f0b6b0e58\", // uniquely identifies this private message \"type\": \"private\", // set automatically \"txtype\": \"batch_pin\", // message will be batched, and sequenced via the blockchain \"author\": \"0x0a65365587a65ce44938eab5a765fe8bc6532bdf\", // set automatically in this example to the node org \"created\": \"2021-07-02T02:37:13.4642085Z\", // set automatically \"namespace\": \"default\", // the 'default' namespace was set in the URL // The group hash is calculated from the resolved list of group participants. // The first time a group is used, the participant list is sent privately along with the // batch of messages in a `groupinit` message. \"group\": \"2aa5297b5eed0c3a612a667c727ca38b54fb3b5cc245ebac4c2c7abe490bdf6c\", \"topics\": [ \"default\" // the default topic that the message is published on, if no topic is set ], // datahash is calculated from the data array below \"datahash\": \"24b2d583b87eda952fa00e02c6de4f78110df63218eddf568f0240be3d02c866\" }, \"hash\": \"423ad7d99fd30ff679270ad2b6b35cdd85d48db30bafb71464ca1527ce114a60\", // hash of the header \"state\": \"ready\", // this message is stored locally but not yet confirmed \"data\": [ // one item of data was stored { \"id\": \"8d8635e2-7c90-4963-99cc-794c98a68b1d\", // can be used to query the data in the future \"hash\": \"c95d6352f524a770a787c16509237baf7eb59967699fb9a6d825270e7ec0eacf\" // sha256 hash of `\"a string\"` } ] } . ",
    "url": "/firefly/head/tutorials/private_send.html#example-message-response",
    "relUrl": "/tutorials/private_send.html#example-message-response"
  },"590": {
    "doc": "Privately send data",
    "title": "Example 2: Unpinned private send of in-line string data",
    "content": "Set header.txtype: \"none\" to disable pinning of the private message send to the blockchain. The message is sent immediately (no batching) over the private data exchange. POST /api/v1/namespaces/default/messages/private . { \"header\": { \"txtype\": \"none\" }, \"data\": [ { \"value\": \"a string\" } ], \"group\": { \"members\": [ { \"identity\": \"org_1\" } ] } } . ",
    "url": "/firefly/head/tutorials/private_send.html#example-2-unpinned-private-send-of-in-line-string-data",
    "relUrl": "/tutorials/private_send.html#example-2-unpinned-private-send-of-in-line-string-data"
  },"591": {
    "doc": "Privately send data",
    "title": "Example 3: Inline object data to a topic (no datatype verification)",
    "content": "It is very good practice to set a tag and topic in each of your messages: . | tag should tell the apps receiving the private send (including the local app), what to do when it receives the message. Its the reason for the send - an application specific type for the message. | topic should be something like a well known identifier that relates to the information you are publishing. It is used as an ordering context, so all sends on a given topic are assured to be processed in order. | . POST /api/v1/namespaces/default/messages/private . { \"header\": { \"tag\": \"new_widget_created\", \"topics\": [\"widget_id_12345\"] }, \"group\": { \"members\": [ { \"identity\": \"org_1\" } ] }, \"data\": [ { \"value\": { \"id\": \"widget_id_12345\", \"name\": \"superwidget\" } } ] } . ",
    "url": "/firefly/head/tutorials/private_send.html#example-3-inline-object-data-to-a-topic-no-datatype-verification",
    "relUrl": "/tutorials/private_send.html#example-3-inline-object-data-to-a-topic-no-datatype-verification"
  },"592": {
    "doc": "Privately send data",
    "title": "Notes on why setting a topic is important",
    "content": "The FireFly aggregator uses the topic (obfuscated on chain) to determine if a message is the next message in an in-flight sequence for any groups the node is involved in. If it is, then that message must receive all off-chain private data and be confirmed before any subsequent messages can be confirmed on the same sequence. So if you use the same topic in every message, then a single failed send on one topic blocks delivery of all messages between those parties, until the missing data arrives. Instead it is best practice to set the topic on your messages to value that identifies an ordered stream of business processing. Some examples: . | A long-running business process instance identifier assigned at initiation | A real-world business transaction identifier used off-chain | The agreed identifier of an asset you are attaching a stream of evidence to | An NFT identifier that is assigned to an asset (digital twin scenarios) | An agreed primary key for a data resource being reconciled between multiple parties | . The topic field is an array, because there are cases (such as merging two identifiers) where you need a message to be deterministically ordered across multiple sequences. However, this is an advanced use case and you are likely to set a single topic on the vast majority of your messages. ",
    "url": "/firefly/head/tutorials/private_send.html#notes-on-why-setting-a-topic-is-important",
    "relUrl": "/tutorials/private_send.html#notes-on-why-setting-a-topic-is-important"
  },"593": {
    "doc": "Privately send data",
    "title": "Example 3: Upload a blob with metadata and send privately",
    "content": "Here we make two API calls. 1) Create the data object explicitly, using a multi-party form upload . | You can also just post JSON to this endpoint | . 2) Privately send a message referring to that data . | The Blob is sent privately to each party | A pin goes to the blockchain | The metadata goes into a batch with the message | . Multipart form post of a file . Example curl command (Linux/Mac) to grab an image from the internet, and pipe it into a multi-part form post to FireFly. Note we use autometa to cause FireFly to automatically add the filename, and size, to the JSON part of the data object for us. curl -sLo - https://github.com/hyperledger/firefly/raw/main/docs/firefly_logo.png \\ | curl --form autometa=true --form file=@- \\ http://localhost:5000/api/v1/namespaces/default/data . Example data response from Blob upload . Status: 200 OK - your data is uploaded to your local FireFly node . At this point the data has not be shared with anyone else in the network . { // A uniquely generated ID, we can refer to when sending this data to other parties \"id\": \"97eb750f-0d0b-4c1d-9e37-1e92d1a22bb8\", \"validator\": \"json\", // the \"value\" part is JSON \"namespace\": \"default\", // from the URL // The hash is a combination of the hash of the \"value\" metadata, and the // hash of the blob \"hash\": \"997af6a9a19f06cc8a46872617b8bf974b106f744b2e407e94cc6959aa8cf0b8\", \"created\": \"2021-07-01T20:20:35.5462306Z\", \"value\": { \"filename\": \"-\", // dash is how curl represents the filename for stdin \"size\": 31185 // the size of the blob data }, \"blob\": { // A hash reference to the blob \"hash\": \"86e6b39b04b605dd1b03f70932976775962509d29ae1ad2628e684faabe48136\" } } . Send the uploaded data privately . Just include a reference to the id returned from the upload. POST /api/v1/namespaces/default/messages/private . { \"data\": [ { \"id\": \"97eb750f-0d0b-4c1d-9e37-1e92d1a22bb8\" } ], \"group\":{ \"members\": [ { \"identity\":\"org_1\" } ] } } . ",
    "url": "/firefly/head/tutorials/private_send.html#example-3-upload-a-blob-with-metadata-and-send-privately",
    "relUrl": "/tutorials/private_send.html#example-3-upload-a-blob-with-metadata-and-send-privately"
  },"594": {
    "doc": "Privately send data",
    "title": "Sending Private Messages using the Sandbox",
    "content": "All of the functionality discussed above can be done through the FireFly Sandbox. To get started, open up the Web UI and Sanbox UI for at least one of your members. The URLs for these were printed in your terminal when you started your FireFly stack. Make sure to expand the “Send a Private Message” section. Enter your message into the message field as seen in the screenshot below. Because we are sending a private message, make sure you’re in the “Send a Private Message” section and that you choose a message recipient . Notice how the data field in the center panel updates in real time as you update the message you wish to send. Click the blue Run button. This should return a 202 response immediately in the Server Response section and will populate the right hand panel with transaction information after a few seconds. Go back to the FireFly UI (the URL for this would have been shown in the terminal when you started the stack) and you’ll see your successful blockchain transaction. Compare the “Recent Network Changes” widget With private messages, your . ",
    "url": "/firefly/head/tutorials/private_send.html#sending-private-messages-using-the-sandbox",
    "relUrl": "/tutorials/private_send.html#sending-private-messages-using-the-sandbox"
  },"595": {
    "doc": "Public and Permissioned",
    "title": "Public and Permissioned Blockchain",
    "content": " ",
    "url": "/firefly/head/overview/public_vs_permissioned.html#public-and-permissioned-blockchain",
    "relUrl": "/overview/public_vs_permissioned.html#public-and-permissioned-blockchain"
  },"596": {
    "doc": "Public and Permissioned",
    "title": "Table of contents",
    "content": ". | Public and Permissioned Blockchain | Public blockchain variations | Common public considerations | FireFly architecture for public chains | . ",
    "url": "/firefly/head/overview/public_vs_permissioned.html#table-of-contents",
    "relUrl": "/overview/public_vs_permissioned.html#table-of-contents"
  },"597": {
    "doc": "Public and Permissioned",
    "title": "Public and Permissioned Blockchain",
    "content": "A separate choice to the technology for your blockchain, is what combination of blockchain ecosystems you will integrate with. There are a huge variety of options, and increasingly you might find yourself integrating with multiple ecosystems in your solutions. A rough (and incomplete) high level classification of the blockchains available is as follows: . | Layer 1 public blockchains . | This is where most token ecosystems are rooted | . | Layer 2 public scaling solutions backed by a Layer 1 blockchain . | These are increasing where transaction execution takes place that needs to be reflected eventually back to a Layer 1 blockchain (due to cost/congestion in the Layer 1 chains) | . | Permissioned side-chains . | Historically this has been where the majority of production adoption of enterprise blockchain has focussed, due to the predictable cost, performance, and ability to manage the validator set and boundary API security alongside a business network governance policy | These might have their state check-pointed/rolled-up to a Layer 2 or Layer 1 chain | . | . The lines are blurring between these categorizations as the technologies and ecosystems evolve. ",
    "url": "/firefly/head/overview/public_vs_permissioned.html#public-and-permissioned-blockchain-1",
    "relUrl": "/overview/public_vs_permissioned.html#public-and-permissioned-blockchain-1"
  },"598": {
    "doc": "Public and Permissioned",
    "title": "Public blockchain variations",
    "content": "For the public Layer 1 and 2 solutions, there are too many subclassifications to go into in detail here: . | Whether ecosystems supports custom smart contract execution (EVM based is most common, where contracts are supported) | What types of token standards are supported, or other chain specific embedded smart contracts | Whether the chain follows an unspent transaction output (UTXO) or Account model | How value is bridged in-to / out-of the ecosystem | How the validator set of the chain is established - most common is Proof of Stake (PoS) | How data availability is maintained - to check the working of the validators ensure the historical state is not lost | The consensus algorithm, and how it interacts with the consensus of other blockchains | How state in a Layer 2 is provable in a parent Layer 1 chain (rollup technologies etc.) | . ",
    "url": "/firefly/head/overview/public_vs_permissioned.html#public-blockchain-variations",
    "relUrl": "/overview/public_vs_permissioned.html#public-blockchain-variations"
  },"599": {
    "doc": "Public and Permissioned",
    "title": "Common public considerations",
    "content": "The thing most consistent across public blockchain technologies, is that the technical decisions are backed by token economics. Put simply, creating a system where it’s more financially rewarding to behave honestly, than it is to subvert and cheat the system. This means that participation costs, and that the mechanisms needed to reliably get your transactions into these systems are complex. Also that the time it might take to get a transaction onto the chain can be much longer than for a permissioned blockchain, with the potential to have to make a number of adjustments/resubmissions. The choice of whether to run your own node, or use a managed API, to access these blockchain ecosystems is also a factor in the behavior of the transaction submission and event streaming. ",
    "url": "/firefly/head/overview/public_vs_permissioned.html#common-public-considerations",
    "relUrl": "/overview/public_vs_permissioned.html#common-public-considerations"
  },"600": {
    "doc": "Public and Permissioned",
    "title": "FireFly architecture for public chains",
    "content": "One of the fastest evolving aspects of the Hyperledger FireFly ecosystem, is how it facilitates enterprises to participate in these. The architecture is summarized as follows: . | New FireFly Transaction Manager runtime . | Operates as a microservice extension of the FireFly Core | Uses the operation resource within FireFly Core to store and update state | Runs as a singleton and is responsible for nonce assignment | Takes as much heavy lifting away from blockchain specific connectors as possible | . | Lightweight FireFly Connector API (ffcapi) . | Simple synchronous RPC operations that map to the most common operations supported across public blockchain technologies | Examples: . | Find the next nonce for a given signing key | Serialize a transaction from a set of JSON inputs and an interface definition | Submit an un-signed transaction with a given gas price to the blockchain, via a signing wallet | Establish a new block listener | Poll for new blocks | Establish a new event log listener | Poll for new events | . | . | Pluggable Policy Engine . | Invoked to make decisions on transaction submission | Responsible for gas price calculation | Able to intervene and adjust the characteristics of signing/submission | OSS reference implementation provided with Gas Station REST API integration | . | Confirmation Manager . | Extracted from the Ethconnect codebase | Coupled to both transaction submission and event confirmation | Embeds an efficient block cache | . | Event Streams . | Extracted from the Ethconnect codebase | Checkpoint restart based reliable at-least-once delivery of events | WebSockets interface upstream to FireFly Core | . | . This evolution involves a significant refactoring of components used for production solutions in the FireFly Ethconnect microservice since mid 2018. This was summarized in firefly-ethconnect#149, and cumulated in the creation of a new repository in 2022. You can follow the progress and contribute in this repo: https://github.com/hyperledger/firefly-transaction-manager . ",
    "url": "/firefly/head/overview/public_vs_permissioned.html#firefly-architecture-for-public-chains",
    "relUrl": "/overview/public_vs_permissioned.html#firefly-architecture-for-public-chains"
  },"601": {
    "doc": "Public and Permissioned",
    "title": "Public and Permissioned",
    "content": " ",
    "url": "/firefly/head/overview/public_vs_permissioned.html",
    "relUrl": "/overview/public_vs_permissioned.html"
  },"602": {
    "doc": "Explore messages",
    "title": "Explore messages",
    "content": " ",
    "url": "/firefly/head/tutorials/query_messages.html",
    "relUrl": "/tutorials/query_messages.html"
  },"603": {
    "doc": "Explore messages",
    "title": "Table of contents",
    "content": ". | Quick reference | Additional info . | Example 1: Query confirmed messages | . | Example response . | Example 2: Query all messages | . | . ",
    "url": "/firefly/head/tutorials/query_messages.html#table-of-contents",
    "relUrl": "/tutorials/query_messages.html#table-of-contents"
  },"604": {
    "doc": "Explore messages",
    "title": "Quick reference",
    "content": "The FireFly Explorer is a great way to view the messages sent and received by your node. Just open /ui on your FireFly node to access it. This builds on the APIs to query and filter messages, described below . ",
    "url": "/firefly/head/tutorials/query_messages.html#quick-reference",
    "relUrl": "/tutorials/query_messages.html#quick-reference"
  },"605": {
    "doc": "Explore messages",
    "title": "Additional info",
    "content": ". | Reference: API Query Syntax | Swagger: GET /api/v1/namespaces/{ns}/messages | . Example 1: Query confirmed messages . These are the messages ready to be processed in your application. All data associated with the message (including Blob attachments) is available, and if they are sequenced by the blockchain, then those blockchain transactions are complete. The order in which you process messages should be determined by absolute order of message_confirmed events - queryable via the events collection, or through event listeners (discussed next in the getting started guide). That is because messages are ordered by timestamp, which is potentially subject to adjustments of the clock. Whereas events are ordered by the insertion order into the database, and as such changes in the clock do not affect the order. GET /api/v1/namespaces/{ns}/messages?pending=false&amp;limit=100 . ",
    "url": "/firefly/head/tutorials/query_messages.html#additional-info",
    "relUrl": "/tutorials/query_messages.html#additional-info"
  },"606": {
    "doc": "Explore messages",
    "title": "Example response",
    "content": "[ { \"header\": { \"id\": \"423302bb-abfc-4d64-892d-38b2fdfe1549\", \"type\": \"private\", // this was a private send \"txtype\": \"batch_pin\", // pinned in a batch to the blockchain \"author\": \"0x1d14b65d2dd5c13f6cb6d3dc4aa13c795a8f3b28\", \"created\": \"2021-07-02T03:09:40.2606238Z\", \"namespace\": \"default\", \"group\": \"2aa5297b5eed0c3a612a667c727ca38b54fb3b5cc245ebac4c2c7abe490bdf6c\", // sent to this group \"topic\": [ \"widget_id_12345\" ], \"tag\": \"new_widget_created\", \"datahash\": \"551dd261e80ce76b1908c031cff8a707bd76376d6eddfdc1040c2ed6481ec8dd\" }, \"hash\": \"bf2ca94db8c31bae3cae974bb626fa822c6eee5f572d274d72281e72537b30b3\", \"batch\": \"f7ac773d-885a-4d73-ac6b-c09f5346a051\", // the batch ID that pinned this message to the chain \"state\": \"confirmed\", // message is now confirmed \"confirmed\": \"2021-07-02T03:09:49.9207211Z\", // timestamp when this node confirmed the message \"data\": [ { \"id\": \"914eed77-8789-451c-b55f-ba9570a71eba\", \"hash\": \"9541cabc750c692e553a421a6c5c07ebcae820774d2d8d0b88fac2a231c10bf2\" } ], \"pins\": [ // A \"pin\" is an identifier that is used by FireFly for sequencing messages. // // For private messages, it is an obfuscated representation of the sequence of this message, // on a topic, within this group, from this sender. There will be one pin per topic. You will find these // pins in the blockchain transaction, as well as the off-chain data. // Each one is unqiue, and without the group hash, very difficult to correlate - meaning // the data on-chain provides a high level of privacy. // // Note for broadcast (which does not require obfuscation), it is simply a hash of the topic. // So you will see the same pin for all messages on the same topic. \"ee56de6241522ab0ad8266faebf2c0f1dc11be7bd0c41d847998135b45685b77\" ] } ] . Example 2: Query all messages . The natural sort order the API will return for messages is: . | Pending messages first . | In descending created timestamp order | . | Confirmed messages . | In descending confirmed timestamp order | . | . GET /api/v1/namespaces/{ns}/messages . ",
    "url": "/firefly/head/tutorials/query_messages.html#example-response",
    "relUrl": "/tutorials/query_messages.html#example-response"
  },"607": {
    "doc": "Release Guide",
    "title": "Release Guide",
    "content": " ",
    "url": "/firefly/head/contributors/release_guide.html",
    "relUrl": "/contributors/release_guide.html"
  },"608": {
    "doc": "Release Guide",
    "title": "Table of contents",
    "content": ". | Release Guide . | Versioning scheme | The manifest.json file | Creating a new release . | 1) Navigate to the release page for the repo | 2) Click the Draft a new release button | 3) Fill out the form for your release | . | Automatic Docker builds | . | . This guide will walk you through creating a release. ",
    "url": "/firefly/head/contributors/release_guide.html#table-of-contents",
    "relUrl": "/contributors/release_guide.html#table-of-contents"
  },"609": {
    "doc": "Release Guide",
    "title": "Versioning scheme",
    "content": "FireFly follows semantic versioning. For more details on how we determine which version to use please see the Versioning Scheme guide. ",
    "url": "/firefly/head/contributors/release_guide.html#versioning-scheme",
    "relUrl": "/contributors/release_guide.html#versioning-scheme"
  },"610": {
    "doc": "Release Guide",
    "title": "The manifest.json file",
    "content": "FireFly has a manifest.json file in the root of the repo. This file contains a list of versions (both tag and sha) for each of the microservices that should be used with this specific commit. If you need FireFly to use a newer version of a microservice listed in this file, you should update the manifest.json file, commit it, and include it in your PR. This will trigger an end-to-end test run, using the specified versions. Here is an example of what the manifest.json looks like: . { \"ethconnect\": { \"image\": \"ghcr.io/hyperledger/firefly-ethconnect\", \"tag\": \"v3.0.4\", \"sha\": \"0b7ce0fb175b5910f401ff576ced809fe6f0b83894277c1cc86a73a2d61c6f41\" }, \"fabconnect\": { \"image\": \"ghcr.io/hyperledger/firefly-fabconnect\", \"tag\": \"v0.9.0\", \"sha\": \"a79a4c66b0a2551d5122d019c15c6426e8cdadd6566ce3cbcb36e008fb7861ca\" }, \"dataexchange-https\": { \"image\": \"ghcr.io/hyperledger/firefly-dataexchange-https\", \"tag\": \"v0.9.0\", \"sha\": \"0de5b1db891a02871505ba5e0507821416d9fa93c96ccb4b1ba2fac45eb37214\" }, \"tokens-erc1155\": { \"image\": \"ghcr.io/hyperledger/firefly-tokens-erc1155\", \"tag\": \"v0.9.0-20211019-01\", \"sha\": \"aabc6c483db408896838329dab5f4b9e3c16d1e9fa9fffdb7e1ff05b7b2bbdd4\" } } . NOTE: You can run make manifest in the FireFly core source directory, and a script will run to automatically get the latests non-pre-release version of each of FireFly’s microservices. If you need to use a snapshot or pre-release version you should edit manifest.json file manually, as this script will not fetch those versions. ",
    "url": "/firefly/head/contributors/release_guide.html#the-manifestjson-file",
    "relUrl": "/contributors/release_guide.html#the-manifestjson-file"
  },"611": {
    "doc": "Release Guide",
    "title": "Creating a new release",
    "content": "Releases and builds are managed by GitHub. New binaries and/or Docker images will automatically be created when a new release is published. The easiest way to create a release is through the web UI for the repo that you wish to release. 1) Navigate to the release page for the repo . 2) Click the Draft a new release button . 3) Fill out the form for your release . It is recommended to start with the auto-generated release notes. Additional notes can be added as-needed. ",
    "url": "/firefly/head/contributors/release_guide.html#creating-a-new-release",
    "relUrl": "/contributors/release_guide.html#creating-a-new-release"
  },"612": {
    "doc": "Release Guide",
    "title": "Automatic Docker builds",
    "content": "After cutting a new release, a GitHub Action will automatically start a new Docker build, if the repo has a Docker image associated with it. You can check the status of the build by clicking the “Actions” tab along the top of the page, for that repo. ",
    "url": "/firefly/head/contributors/release_guide.html#automatic-docker-builds",
    "relUrl": "/contributors/release_guide.html#automatic-docker-builds"
  },"613": {
    "doc": "③ Use the Sandbox",
    "title": "Use the Sandbox",
    "content": " ",
    "url": "/firefly/head/gettingstarted/sandbox.html#use-the-sandbox",
    "relUrl": "/gettingstarted/sandbox.html#use-the-sandbox"
  },"614": {
    "doc": "③ Use the Sandbox",
    "title": "Table of contents",
    "content": ". | Previous steps: Start your environment | Video walkthrough | What is the FireFly Sandbox? | What is the FireFly Explorer? | Open the FireFly Sandbox for the first member | Sandbox Layout . | Left column: Prepare your request | Middle column: Preview server code and see response | Right column: Events received on the WebSocket | . | Messages . | Things to try out | . | Tokens . | Things to try out | . | Contracts . | Things to try out | . | Go forth and build! | . ",
    "url": "/firefly/head/gettingstarted/sandbox.html#table-of-contents",
    "relUrl": "/gettingstarted/sandbox.html#table-of-contents"
  },"615": {
    "doc": "③ Use the Sandbox",
    "title": "Previous steps: Start your environment",
    "content": "If you haven’t started a FireFly stack already, please go back to the previous step and read the guide on how to Start your environment. ← ② Start your environment . Now that you have a full network of three Supernodes running on your machine, let’s look at the first two components that you will interact with: the FireFly Sandbox and the FireFly Explorer. ",
    "url": "/firefly/head/gettingstarted/sandbox.html#previous-steps-start-your-environment",
    "relUrl": "/gettingstarted/sandbox.html#previous-steps-start-your-environment"
  },"616": {
    "doc": "③ Use the Sandbox",
    "title": "Video walkthrough",
    "content": "This video is a walkthrough of the FireFly Sandbox and FireFly Explorer from the FireFly 1.0 launch webinar. At this point you should be able to follow along and try all these same things on your own machine. ",
    "url": "/firefly/head/gettingstarted/sandbox.html#video-walkthrough",
    "relUrl": "/gettingstarted/sandbox.html#video-walkthrough"
  },"617": {
    "doc": "③ Use the Sandbox",
    "title": "What is the FireFly Sandbox?",
    "content": ". The FireFly Sandbox sits logically outside the Supernode, and it acts like an “end-user” application written to use FireFly’s API. In your setup, you have one Sandbox per member, each talking to their own FireFly API. The purpose of the Sandbox is to provide a quick and easy way to try out all of the fundamental building blocks that FireFly provides. It also shows developers, through example code snippets, how they would implement the same functionality in their own app’s backend. 🗒 Technical details: The FireFly Sandbox is an example “full-stack” web app. It has a backend written in TypeScript / Node.js, and a frontend in TypeScript / React. When you click a button in your browser, the frontend makes a request to the backend, which then uses the FireFly Node.js SDK to make requests to FireFly’s API. ",
    "url": "/firefly/head/gettingstarted/sandbox.html#what-is-the-firefly-sandbox",
    "relUrl": "/gettingstarted/sandbox.html#what-is-the-firefly-sandbox"
  },"618": {
    "doc": "③ Use the Sandbox",
    "title": "What is the FireFly Explorer?",
    "content": "The FireFly explorer is a part of FireFly Core itself. It is a view into the system that allows operators to monitor the current state of the system and investigate specific transactions, messages, and events. It is also a great way for developers to see the results of running their code against FireFly’s API. ",
    "url": "/firefly/head/gettingstarted/sandbox.html#what-is-the-firefly-explorer",
    "relUrl": "/gettingstarted/sandbox.html#what-is-the-firefly-explorer"
  },"619": {
    "doc": "③ Use the Sandbox",
    "title": "Open the FireFly Sandbox for the first member",
    "content": "When you set up your FireFly stack in the previous section, it should have printed some URLs like the following. Open the link in a browser for the `Sandbox UI for member ‘0’. It should be: http://127.0.0.1:5109 . ff start demo this will take a few seconds longer since this is the first time you're running this stack... done Web UI for member '0': http://127.0.0.1:5000/ui Sandbox UI for member '0': http://127.0.0.1:5109 Web UI for member '1': http://127.0.0.1:5001/ui Sandbox UI for member '1': http://127.0.0.1:5209 Web UI for member '2': http://127.0.0.1:5002/ui Sandbox UI for member '2': http://127.0.0.1:5309 To see logs for your stack run: ff logs demo . ",
    "url": "/firefly/head/gettingstarted/sandbox.html#open-the-firefly-sandbox-for-the-first-member",
    "relUrl": "/gettingstarted/sandbox.html#open-the-firefly-sandbox-for-the-first-member"
  },"620": {
    "doc": "③ Use the Sandbox",
    "title": "Sandbox Layout",
    "content": ". The Sandbox is split up into three columns: . Left column: Prepare your request . On the left-hand side of the page, you can fill out simple form fields to construct messages and more. Some tabs have more types of requests on them in sections that can be expanded or collapsed. Across the top of this column there are three tabs that switch between the three main sets of functionality in the Sandbox. The next three sections of this guide will walk you through each one of these. The first tab we will explore is the MESSAGING tab. This is where we can send broadcasts and private messages. Middle column: Preview server code and see response . As you type in the form on the left side of the page, you may notice that the source code in the top middle of the page updates automatically. If you were building a backend app, this is an example of code that your app could use to call the FireFly SDK. The middle column also contains a RUN button to actually send the request. Right column: Events received on the WebSocket . On the right-hand side of the page you can see a stream of events being received on a WebSocket connection that the backend has open to FireFly. For example, as you make requests to send messages, you can see when the messages are asynchronously confirmed. ",
    "url": "/firefly/head/gettingstarted/sandbox.html#sandbox-layout",
    "relUrl": "/gettingstarted/sandbox.html#sandbox-layout"
  },"621": {
    "doc": "③ Use the Sandbox",
    "title": "Messages",
    "content": "The Messages tab is where we can send broadcast and private messages to other members and nodes in the FireFly network. Messages can be a string, any arbitrary JSON object, or a binary file. For more details, please see the tutorial on Broadcasting data and Privately sending data. Things to try out . | Send a broadcast message and view the data payload in every member’s FireFly Explorer | Send a private message to one member, and verify that the data payload is not visible in the third member’s FireFly Explorer | Send an image file and download it from another member’s FireFly Explorer | . ",
    "url": "/firefly/head/gettingstarted/sandbox.html#messages",
    "relUrl": "/gettingstarted/sandbox.html#messages"
  },"622": {
    "doc": "③ Use the Sandbox",
    "title": "Tokens",
    "content": "The Tokens tab is where you can create token pools, and mint, burn, or transfer tokens. This works with both fungible and non-fungible tokens (NFTs). For more details, please see the Tokens tutorials. Things to try out . | Create a fungible token pool and mint some tokens and view your balance in the FireFly Explorer | Transfer some amount of those tokens to another member and view the transfer transaction in the FireFly Explorer | Burn some amount of tokens and view the transaction and updated balances in the FireFly Explorer | Create a non-fungible token pool and mint some NFTs | Transfer an NFT to another member and verify the account balances in the FireFly Explorer | . ",
    "url": "/firefly/head/gettingstarted/sandbox.html#tokens",
    "relUrl": "/gettingstarted/sandbox.html#tokens"
  },"623": {
    "doc": "③ Use the Sandbox",
    "title": "Contracts",
    "content": "The Contracts section of the Sandbox lets you interact with custom smart contracts, right from your web browser! The Sandbox also provides some helpful tips on deploying your smart contract to the blockchain. For more details, please see the tutorial on Working with custom smart contracts. Things to try out . | Create a contract interface and API, then view the Swagger UI for your new API | Create an event listener | Use the Swagger UI to call a smart contract function that emits an event. Verify that the event is received in the Sandbox and shows up in the FireFly Explorer. | . ",
    "url": "/firefly/head/gettingstarted/sandbox.html#contracts",
    "relUrl": "/gettingstarted/sandbox.html#contracts"
  },"624": {
    "doc": "③ Use the Sandbox",
    "title": "Go forth and build!",
    "content": "At this point you should have a pretty good understanding of some of the major features of Hyperledger FireFly. Now, using what you’ve learned, you can go and build your own Web3 app! Don’t forget to join the Hyperledger Discord server and come chat with us in the #firefly channel. ",
    "url": "/firefly/head/gettingstarted/sandbox.html#go-forth-and-build",
    "relUrl": "/gettingstarted/sandbox.html#go-forth-and-build"
  },"625": {
    "doc": "③ Use the Sandbox",
    "title": "③ Use the Sandbox",
    "content": " ",
    "url": "/firefly/head/gettingstarted/sandbox.html",
    "relUrl": "/gettingstarted/sandbox.html"
  },"626": {
    "doc": "② Start your environment",
    "title": "Start your environment",
    "content": " ",
    "url": "/firefly/head/gettingstarted/setup_env.html#start-your-environment",
    "relUrl": "/gettingstarted/setup_env.html#start-your-environment"
  },"627": {
    "doc": "② Start your environment",
    "title": "Table of contents",
    "content": ". | Previous steps: Install the FireFly CLI | A FireFly Stack | System Resources | Creating a new stack . | Stack initialization options | Start your stack | . | Next steps: Use in the Sandbox | . ",
    "url": "/firefly/head/gettingstarted/setup_env.html#table-of-contents",
    "relUrl": "/gettingstarted/setup_env.html#table-of-contents"
  },"628": {
    "doc": "② Start your environment",
    "title": "Previous steps: Install the FireFly CLI",
    "content": "If you haven’t set up the FireFly CLI already, please go back to the previous step and read the guide on how to Install the FireFly CLI. ← ① Install the FireFly CLI . Now that you have the FireFly CLI installed, you are ready to run some Supernodes on your machine! . ",
    "url": "/firefly/head/gettingstarted/setup_env.html#previous-steps-install-the-firefly-cli",
    "relUrl": "/gettingstarted/setup_env.html#previous-steps-install-the-firefly-cli"
  },"629": {
    "doc": "② Start your environment",
    "title": "A FireFly Stack",
    "content": "A FireFly stack is a collection of Supernodes with networking and configuration that are designed to work together on a single development machine. A stack has multiple members (also referred to organizations). Each member has their own Supernode within the stack. This allows developers to build and test data flows with a mix of public and private data between various parties, all within a single development environment. The stack also contains an instance of the FireFly Sandbox for each member. This is an example of an end-user application that uses FireFly’s API. It has a backend and a frontend which are designed to walk developers through the features of FireFly, and provides code snippets as examples of how to build those features into their own application. The next section in this guide will walk you through using the Sandbox. ",
    "url": "/firefly/head/gettingstarted/setup_env.html#a-firefly-stack",
    "relUrl": "/gettingstarted/setup_env.html#a-firefly-stack"
  },"630": {
    "doc": "② Start your environment",
    "title": "System Resources",
    "content": "The FireFly stack will run in a docker-compose project. For systems that run Docker containers inside a virtual machine, like macOS, you need to make sure that you’ve allocated enough memory to the Docker virtual machine. We recommend allocating 1GB per member. In this case, we’re going to set up a stack with 3 members, so please make sure you have at least 3 GB of RAM allocated in your Docker Desktop settings. ",
    "url": "/firefly/head/gettingstarted/setup_env.html#system-resources",
    "relUrl": "/gettingstarted/setup_env.html#system-resources"
  },"631": {
    "doc": "② Start your environment",
    "title": "Creating a new stack",
    "content": "It’s really easy to create a new FireFly stack. The ff init command can create a new stack for you, and will prompt you for a few details such as the name, and how many members you want in your stack. Run: . ff init . Choose a stack name. For this guide, I will choose the name dev, but you can pick whatever you want: . stack name: dev . Chose the number of members for your stack. For this guide, we should pick 3 members, so we can try out both public and private messaging use cases: . number of members: 3 . Stack initialization options . There are quite a few options that you can choose from when creating a new stack. For now, we’ll just stick with the defaults. To see the full list of options, just run ff init --help. $ ff init --help Create a new FireFly local dev stack Usage: ff init [stack_name] [member_count] [flags] Flags: --block-period int Block period in seconds. Default is variable based on selected blockchain provider. (default -1) -b, --blockchain-provider string Blockchain provider to use. Options are: [geth besu fabric corda] (default \"geth\") --contract-address string Do not automatically deploy a contract, instead use a pre-configured address --core-config string The path to a yaml file containing extra config for FireFly Core -d, --database string Database type to use. Options are: [postgres sqlite3] (default \"sqlite3\") --ethconnect-config string The path to a yaml file containing extra config for Ethconnect -e, --external int Manage a number of FireFly core processes outside of the docker-compose stack - useful for development and debugging -p, --firefly-base-port int Mapped port base of FireFly core API (1 added for each member) (default 5000) -h, --help help for init -m, --manifest string Path to a manifest.json file containing the versions of each FireFly microservice to use. Overrides the --release flag. --prometheus-enabled Enables Prometheus metrics exposition and aggregation to a shared Prometheus server --prometheus-port int Port for the shared Prometheus server (default 9090) --prompt-names Prompt for org and node names instead of using the defaults -r, --release string Select the FireFly release version to use (default \"latest\") --sandbox-enabled Enables the FireFly Sandbox to be started with your FireFly stack (default true) -s, --services-base-port int Mapped port base of services (100 added for each member) (default 5100) -t, --token-providers stringArray Token providers to use. Options are: [none erc1155 erc20_erc721] (default [erc1155]) Global Flags: --ansi string control when to print ANSI control characters (\"never\"|\"always\"|\"auto\") (default \"auto\") -v, --verbose verbose log output . Start your stack . To start your stack simply run: . ff start dev . This may take a minute or two and in the background the FireFly CLI will do the following for you: . | Download Docker images for all of the components of the Supernode | Initialize a new blockchain and blockchain node running inside a container | Set up configuration between all the components | Deploy FireFly’s BatchPin smart contract | Deploy an ERC-1155 token smart contract | Register an identity for each member and node | . After your stack finishes starting it will print out the links to each member’s UI and the Sandbox for that node: . ff start dev this will take a few seconds longer since this is the first time you're running this stack... done Web UI for member '0': http://127.0.0.1:5000/ui Sandbox UI for member '0': http://127.0.0.1:5109 Web UI for member '1': http://127.0.0.1:5001/ui Sandbox UI for member '1': http://127.0.0.1:5209 Web UI for member '2': http://127.0.0.1:5002/ui Sandbox UI for member '2': http://127.0.0.1:5309 To see logs for your stack run: ff logs dev . ",
    "url": "/firefly/head/gettingstarted/setup_env.html#creating-a-new-stack",
    "relUrl": "/gettingstarted/setup_env.html#creating-a-new-stack"
  },"632": {
    "doc": "② Start your environment",
    "title": "Next steps: Use in the Sandbox",
    "content": "Now that you have some Supernodes running, it’s time to start playing: in the Sandbox! . ③ Use the Sandbox → . ",
    "url": "/firefly/head/gettingstarted/setup_env.html#next-steps-use-in-the-sandbox",
    "relUrl": "/gettingstarted/setup_env.html#next-steps-use-in-the-sandbox"
  },"633": {
    "doc": "② Start your environment",
    "title": "② Start your environment",
    "content": " ",
    "url": "/firefly/head/gettingstarted/setup_env.html",
    "relUrl": "/gettingstarted/setup_env.html"
  },"634": {
    "doc": "Simple Types",
    "title": "Simple Types",
    "content": " ",
    "url": "/firefly/head/reference/types/simpletypes.html",
    "relUrl": "/reference/types/simpletypes.html"
  },"635": {
    "doc": "Simple Types",
    "title": "Table of contents",
    "content": ". | UUID | FFTime | FFBigInt | JSONAny | JSONObject | . ",
    "url": "/firefly/head/reference/types/simpletypes.html#table-of-contents",
    "relUrl": "/reference/types/simpletypes.html#table-of-contents"
  },"636": {
    "doc": "Simple Types",
    "title": "UUID",
    "content": "IDs are generated as UUID V4 globally unique identifiers . ",
    "url": "/firefly/head/reference/types/simpletypes.html#uuid",
    "relUrl": "/reference/types/simpletypes.html#uuid"
  },"637": {
    "doc": "Simple Types",
    "title": "FFTime",
    "content": "Times are serialized to JSON on the API in RFC 3339 / ISO 8601 nanosecond UTC time for example 2022-05-05T21:19:27.454767543Z. Note that JavaScript can parse this format happily into millisecond time with Date.parse(). Times are persisted as a nanosecond resolution timestamps in the database. On input, and in queries, times can be parsed from RFC3339, or unix timestamps (second, millisecond or nanosecond resolution). ",
    "url": "/firefly/head/reference/types/simpletypes.html#fftime",
    "relUrl": "/reference/types/simpletypes.html#fftime"
  },"638": {
    "doc": "Simple Types",
    "title": "FFBigInt",
    "content": "Large integers of up to 256bits in size are common in blockchain, and handled in FireFly. In JSON output payloads in FireFly, including events, they are serialized as strings (with base 10). On input you can provide JSON string (string with an 0x prefix are parsed at base 16), or a JSON number. Be careful when using JSON numbers, that the largest number that is safe to transfer using a JSON number is 2^53 - 1. ",
    "url": "/firefly/head/reference/types/simpletypes.html#ffbigint",
    "relUrl": "/reference/types/simpletypes.html#ffbigint"
  },"639": {
    "doc": "Simple Types",
    "title": "JSONAny",
    "content": "Any JSON type. An object, array, string, number, boolean or null. FireFly stores object data with the same field order as was provided on the input, but with any whitespace removed. ",
    "url": "/firefly/head/reference/types/simpletypes.html#jsonany",
    "relUrl": "/reference/types/simpletypes.html#jsonany"
  },"640": {
    "doc": "Simple Types",
    "title": "JSONObject",
    "content": "Any JSON Object. Must be an object, rather than an array or a simple type. ",
    "url": "/firefly/head/reference/types/simpletypes.html#jsonobject",
    "relUrl": "/reference/types/simpletypes.html#jsonobject"
  },"641": {
    "doc": "Subscription",
    "title": "Subscription",
    "content": " ",
    "url": "/firefly/head/reference/types/subscription.html",
    "relUrl": "/reference/types/subscription.html"
  },"642": {
    "doc": "Subscription",
    "title": "Table of contents",
    "content": ". | Subscription . | Creating a subscription | Subscriptions and workload balancing | Pluggable Transports | WebSockets . | WebSocket protocol | Using start and ack explicitly | Auto-starting via URL query and autoack | Ephemeral WebSocket subscriptions | . | Webhooks | Example | Field Descriptions | . | SubscriptionFilter | MessageFilter | TransactionFilter | BlockchainEventFilter | SubscriptionOptions | WebhookInputOptions | . ",
    "url": "/firefly/head/reference/types/subscription.html#table-of-contents",
    "relUrl": "/reference/types/subscription.html#table-of-contents"
  },"643": {
    "doc": "Subscription",
    "title": "Subscription",
    "content": "Each Subscription tracks delivery of events to a particular application, and allows FireFly to ensure that messages are delivered reliably to that application. Creating a subscription . Before you can connect to a subscription, you must create it via the REST API. One special case where you do not need to do this, is Ephemeral WebSocket connections (described below). For these you can just connect and immediately start receiving events. When creating a new subscription, you give it a name which is how you will refer to it when you connect. You are also able to specify server-side filtering that should be performed against the event stream, to limit the set of events that are sent to your application. All subscriptions are created within a namespace, and automatically filter events to only those emitted within that namespace. You can create multiple subscriptions for your application, to request different sets of server-side filtering for events. You can then request FireFly to deliver events for both subscriptions over the same WebSocket (if you are using the WebSocket transport). However, delivery order is not assured between two subscriptions. Subscriptions and workload balancing . You can have multiple scaled runtime instances of a single application, all running in parallel. These instances of the application all share a single subscription. Each event is only delivered once to the subscription, regardless of how many instances of your application connect to FireFly. With multiple WebSocket connections active on a single subscription, each event might be delivered to different instance of your application. This means workload is balanced across your instances. However, each event still needs to be acknowledged, so delivery processing order can still be maintained within your application database state. If you have multiple different applications all needing their own copy of the same event, then you need to configure a separate subscription for each application. Pluggable Transports . Hyperledger FireFly has two built-in transports for delivery of events to applications - WebSockets and Webhooks. The event interface is fully pluggable, so you can extend connectivity over an external event bus - such as NATS, Apache Kafka, Rabbit MQ, Redis etc. WebSockets . If your application has a back-end server runtime, then WebSockets are the most popular option for listening to events. WebSockets are well supported by all popular application development frameworks, and are very firewall friendly for connecting applications into your FireFly server. Check out the @hyperledger/firefly-sdk SDK for Node.js applications, and the hyperledger/firefly-common module for Golang applications. These both contain reliable WebSocket clients for your event listeners. A Java SDK is a roadmap item for the community. WebSocket protocol . FireFly has a simple protocol on top of WebSockets: . | Each time you connect/reconnect you need to tell FireFly to start sending you events on a particular subscription. You can do this in two ways (described in detail below): . | Send a WSStart JSON payload | Include a namespace and name query parameter in the URL when you connect, along with query params for other fields of WSStart | . | One you have started your subscription, each event flows from the server, to your application as a JSON Event payload | For each event you receive, you need to send a WSAck payload. | Unless you specified autoack in step (1) | . | . The SDK libraries for FireFly help you ensure you send the start payload each time your WebSocket reconnects. Using start and ack explicitly . Here’s an example websocat command showing an explicit start and ack. $ websocat ws://localhost:5000/ws {\"type\":\"start\",\"namespace\":\"default\",\"name\":\"docexample\"} # ... for each event that arrives here, you send an ack ... {\"type\":\"ack\",\"id\":\"70ed4411-57cf-4ba1-bedb-fe3b4b5fd6b6\"} . When creating your subscription, you can set readahead in order to ask FireFly to stream a number of messages to your application, ahead of receiving the acknowledgements. readahead can be a powerful tool to increase performance, but does require your application to ensure it processes events in the correct order and sends exactly one ack for each event. Auto-starting via URL query and autoack . Here’s an example websocat where we use URL query parameters to avoid the need to send a start JSON payload. We also use autoack so that events just keep flowing from the server. $ websocat \"ws://localhost:5000/ws?namespace=default&amp;name=docexample&amp;autoack\" # ... events just keep arriving here, as the server-side auto-acknowledges # the events as it delivers them to you. Note using autoack means you can miss events in the case of a disconnection, so should not be used for production applications that require at-least-once delivery. Ephemeral WebSocket subscriptions . FireFly WebSockets provide a special option to create a subscription dynamically, that only lasts for as long as you are connected to the server. We call these ephemeral subscriptions. Here’s an example websocat command showing an an ephemeral subscription - notice we don’t specify a name for the subscription, and there is no need to have already created the subscription beforehand. Here we also include an extra query parameter to set a server-side filter, to only include message events. $ websocat \"ws://localhost:5000/ws?namespace=default&amp;ephemeral&amp;autoack&amp;filter.events=message_.*\" {\"type\":\"start\",\"namespace\":\"default\",\"name\":\"docexample\"} # ... for each event that arrives here, you send an ack ... {\"type\":\"ack\",\"id\":\"70ed4411-57cf-4ba1-bedb-fe3b4b5fd6b6\"} . Ephemeral subscriptions are very convenient for experimentation, debugging and monitoring. However, they do not give reliable delivery because you only receive events that occur while you are connected. If you disconnect and reconnect, you will miss all events that happened while your application was not listening. Webhooks . The Webhook transport allows FireFly to make HTTP calls against your application’s API when events matching your subscription are emitted. This means the direction of network connection is from the FireFly server, to the application (the reverse of WebHooks). Conversely it means you don’t need to add any connection management code to your application - just expose and API that FireFly can call to process the events. Webhooks are great for serverless functions (AWS Lambda etc.), integrations with SaaS applications, and calling existing APIs. The FireFly configuration options for a Webhook subscription are very flexible, allowing you to customize your HTTP requests as follows: . | Set the HTTP request details: . | Method, URL, query, headers and input body | . | Wait for a successful 2xx HTTP code from the back-end service, before acknowledging (default). | Use fastack to acknowledge against FireFly immediately and make multiple parallel calls to the HTTP API in a fire-and-forget fashion. | Set the HTTP request details dynamically from message_confirmed events: . | Map data out of the first data element in message events | Requires withData to be set on the subscription, in addition to the input.* configuration options | . | Can automatically generate a “reply” message for message_confirmed events: . | Maps the response body of the HTTP call to data in the reply message | Sets the cid and topic in the reply message to match the request | Sets a tag in the reply message, per the configuration, or dynamically based on a field in the input request data. | . | . Example . { \"id\": \"c38d69fd-442e-4d6f-b5a4-bab1411c7fe8\", \"namespace\": \"ns1\", \"name\": \"app1\", \"transport\": \"websockets\", \"filter\": { \"events\": \"^(message_.*|token_.*)$\", \"message\": { \"tag\": \"^(red|blue)$\" }, \"transaction\": {}, \"blockchainevent\": {} }, \"options\": { \"firstEvent\": \"newest\", \"readAhead\": 50 }, \"created\": \"2022-05-16T01:23:15Z\", \"updated\": null } . Field Descriptions . | Field Name | Description | Type | . | id | The UUID of the subscription | UUID | . | namespace | The namespace of the subscription. A subscription will only receive events generated in the namespace of the subscription | string | . | name | The name of the subscription. The application specifies this name when it connects, in order to attach to the subscription and receive events that arrived while it was disconnected. If multiple apps connect to the same subscription, events are workload balanced across the connected application instances | string | . | transport | The transport plugin responsible for event delivery (WebSockets, Webhooks, JMS, NATS etc.) | string | . | filter | Server-side filter to apply to events | SubscriptionFilter | . | options | Subscription options | SubscriptionOptions | . | ephemeral | Ephemeral subscriptions only exist as long as the application is connected, and as such will miss events that occur while the application is disconnected, and cannot be created administratively. You can create one over over a connected WebSocket connection | bool | . | created | Creation time of the subscription | FFTime | . | updated | Last time the subscription was updated | FFTime | . ",
    "url": "/firefly/head/reference/types/subscription.html",
    "relUrl": "/reference/types/subscription.html"
  },"644": {
    "doc": "Subscription",
    "title": "SubscriptionFilter",
    "content": "| Field Name | Description | Type | . | events | Regular expression to apply to the event type, to subscribe to a subset of event types | string | . | message | Filters specific to message events. If an event is not a message event, these filters are ignored | MessageFilter | . | transaction | Filters specific to events with a transaction. If an event is not associated with a transaction, this filter is ignored | TransactionFilter | . | blockchainevent | Filters specific to blockchain events. If an event is not a blockchain event, these filters are ignored | BlockchainEventFilter | . | topic | Regular expression to apply to the topic of the event, to subscribe to a subset of topics. Note for messages sent with multiple topics, a separate event is emitted for each topic | string | . | topics | Deprecated: Please use ‘topic’ instead | string | . | tag | Deprecated: Please use ‘message.tag’ instead | string | . | group | Deprecated: Please use ‘message.group’ instead | string | . | author | Deprecated: Please use ‘message.author’ instead | string | . ",
    "url": "/firefly/head/reference/types/subscription.html#subscriptionfilter",
    "relUrl": "/reference/types/subscription.html#subscriptionfilter"
  },"645": {
    "doc": "Subscription",
    "title": "MessageFilter",
    "content": "| Field Name | Description | Type | . | tag | Regular expression to apply to the message ‘header.tag’ field | string | . | group | Regular expression to apply to the message ‘header.group’ field | string | . | author | Regular expression to apply to the message ‘header.author’ field | string | . ",
    "url": "/firefly/head/reference/types/subscription.html#messagefilter",
    "relUrl": "/reference/types/subscription.html#messagefilter"
  },"646": {
    "doc": "Subscription",
    "title": "TransactionFilter",
    "content": "| Field Name | Description | Type | . | type | Regular expression to apply to the transaction ‘type’ field | string | . ",
    "url": "/firefly/head/reference/types/subscription.html#transactionfilter",
    "relUrl": "/reference/types/subscription.html#transactionfilter"
  },"647": {
    "doc": "Subscription",
    "title": "BlockchainEventFilter",
    "content": "| Field Name | Description | Type | . | name | Regular expression to apply to the blockchain event ‘name’ field, which is the name of the event in the underlying blockchain smart contract | string | . | listener | Regular expression to apply to the blockchain event ‘listener’ field, which is the UUID of the event listener. So you can restrict your subscription to certain blockchain listeners. Alternatively to avoid your application need to know listener UUIDs you can set the ‘topic’ field of blockchain event listeners, and use a topic filter on your subscriptions | string | . ",
    "url": "/firefly/head/reference/types/subscription.html#blockchaineventfilter",
    "relUrl": "/reference/types/subscription.html#blockchaineventfilter"
  },"648": {
    "doc": "Subscription",
    "title": "SubscriptionOptions",
    "content": "| Field Name | Description | Type | . | firstEvent | Whether your appplication would like to receive events from the ‘oldest’ event emitted by your FireFly node (from the beginning of time), or the ‘newest’ event (from now), or a specific event sequence. Default is ‘newest’ | SubOptsFirstEvent | . | readAhead | The number of events to stream ahead to your application, while waiting for confirmation of consumption of those events. At least once delivery semantics are used in FireFly, so if your application crashes/reconnects this is the maximum number of events you would expect to be redelivered after it restarts | uint16 | . | withData | Whether message events delivered over the subscription, should be packaged with the full data of those messages in-line as part of the event JSON payload. Or if the application should make separate REST calls to download that data. May not be supported on some transports. | bool | . | fastack | Webhooks only: When true the event will be acknowledged before the webhook is invoked, allowing parallel invocations | bool | . | url | Webhooks only: HTTP url to invoke. Can be relative if a base URL is set in the webhook plugin config | string | . | method | Webhooks only: HTTP method to invoke. Default=POST | string | . | json | Webhooks only: Whether to assume the response body is JSON, regardless of the returned Content-Type | bool | . | reply | Webhooks only: Whether to automatically send a reply event, using the body returned by the webhook | bool | . | replytag | Webhooks only: The tag to set on the reply message | string | . | replytx | Webhooks only: The transaction type to set on the reply message | string | . | headers | Webhooks only: Static headers to set on the webhook request | `` | . | query | Webhooks only: Static query params to set on the webhook request | `` | . | input | Webhooks only: A set of options to extract data from the first JSON input data in the incoming message. Only applies if withData=true | WebhookInputOptions | . ",
    "url": "/firefly/head/reference/types/subscription.html#subscriptionoptions",
    "relUrl": "/reference/types/subscription.html#subscriptionoptions"
  },"649": {
    "doc": "Subscription",
    "title": "WebhookInputOptions",
    "content": "| Field Name | Description | Type | . | query | A top-level property of the first data input, to use for query parameters | string | . | headers | A top-level property of the first data input, to use for headers | string | . | body | A top-level property of the first data input, to use for the request body. Default is the whole first body | string | . | path | A top-level property of the first data input, to use for a path to append with escaping to the webhook path | string | . | replytx | A top-level property of the first data input, to use to dynamically set whether to pin the response (so the requester can choose) | string | . ",
    "url": "/firefly/head/reference/types/subscription.html#webhookinputoptions",
    "relUrl": "/reference/types/subscription.html#webhookinputoptions"
  },"650": {
    "doc": "pages.api_spec",
    "title": "API Spec",
    "content": "This is the FireFly OpenAPI Specification document generated by FireFly . Note: The ‘Try it out’ buttons will not work on this page because it’s not running against a live version of FireFly. To actually try it out, we recommend using the FireFly CLI to start an instance on your local machine (which will start the FireFly core on port 5000 by default) and then open the Swagger UI associated with your local node by opening a new tab and visiting http://localhost:5000/api . | ",
    "url": "/firefly/head/swagger/swagger.html#api-spec",
    "relUrl": "/swagger/swagger.html#api-spec"
  },"651": {
    "doc": "pages.api_spec",
    "title": "pages.api_spec",
    "content": " ",
    "url": "/firefly/head/swagger/swagger.html",
    "relUrl": "/swagger/swagger.html"
  },"652": {
    "doc": "TokenApproval",
    "title": "TokenApproval",
    "content": " ",
    "url": "/firefly/head/reference/types/tokenapproval.html",
    "relUrl": "/reference/types/tokenapproval.html"
  },"653": {
    "doc": "TokenApproval",
    "title": "Table of contents",
    "content": ". | TokenApproval . | Example | Field Descriptions | . | TransactionRef | . ",
    "url": "/firefly/head/reference/types/tokenapproval.html#table-of-contents",
    "relUrl": "/reference/types/tokenapproval.html#table-of-contents"
  },"654": {
    "doc": "TokenApproval",
    "title": "TokenApproval",
    "content": "A token approval is a record that an address other than the owner of a token balance, has been granted authority to transfer tokens on the owners behalf. The approved “operator” (or “spender”) account might be a smart contract, or another individual. FireFly provides APIs for initiating and tracking approvals, which token connectors integrate with the implementation of the underlying token. The off-chain index maintained in FireFly for allowance allows you to quickly find the most recent allowance event associated with a pair of keys, using the subject field, combined with the active field. When a new Token Approval event is delivered to FireFly Core by the Token Connector, any previous approval for the same subject is marked \"active\": false, and the new approval is marked with \"active\": true . The token connector is responsible for the format of the subject field to reflect the owner / operator (spender) relationship. Example . { \"localId\": \"1cd3e2e2-dd6a-441d-94c5-02439de9897b\", \"pool\": \"1244ecbe-5862-41c3-99ec-4666a18b9dd5\", \"connector\": \"erc20_erc721\", \"key\": \"0x55860105d6a675dbe6e4d83f67b834377ba677ad\", \"operator\": \"0x30017fd084715e41aa6536ab777a8f3a2b11a5a1\", \"approved\": true, \"info\": { \"owner\": \"0x55860105d6a675dbe6e4d83f67b834377ba677ad\", \"spender\": \"0x30017fd084715e41aa6536ab777a8f3a2b11a5a1\", \"value\": \"115792089237316195423570985008687907853269984665640564039457584007913129639935\" }, \"namespace\": \"ns1\", \"protocolId\": \"000000000032/000000/000000\", \"subject\": \"0x55860105d6a675dbe6e4d83f67b834377ba677ad:0x30017fd084715e41aa6536ab777a8f3a2b11a5a1\", \"active\": true, \"created\": \"2022-05-16T01:23:15Z\", \"tx\": { \"type\": \"token_approval\", \"id\": \"4b6e086d-0e31-482d-9683-cd18b2045031\" } } . Field Descriptions . | Field Name | Description | Type | . | localId | The UUID of this token approval, in the local FireFly node | UUID | . | pool | The UUID the token pool this approval applies to | UUID | . | connector | The name of the token connector, as specified in the FireFly core configuration file. Required on input when there are more than one token connectors configured | string | . | key | The blockchain signing key for the approval request. On input defaults to the first signing key of the organization that operates the node | string | . | operator | The blockchain identity that is granted the approval | string | . | approved | Whether this record grants permission for an operator to perform actions on the token balance (true), or revokes permission (false) | bool | . | info | Token connector specific information about the approval operation, such as whether it applied to a limited balance of a fungible token. See your chosen token connector documentation for details | JSONObject | . | namespace | The namespace for the approval, which must match the namespace of the token pool | string | . | protocolId | An alphanumerically sortable string that represents this event uniquely with respect to the blockchain | string | . | subject | A string identifying the parties and entities in the scope of this approval, as provided by the token connector | string | . | active | Indicates if this approval is currently active (only one approval can be active per subject) | bool | . | created | The creation time of the token approval | FFTime | . | tx | If submitted via FireFly, this will reference the UUID of the FireFly transaction (if the token connector in use supports attaching data) | TransactionRef | . | blockchainEvent | The UUID of the blockchain event | UUID | . | config | Input only field, with token connector specific configuration of the approval. See your chosen token connector documentation for details | JSONObject | . ",
    "url": "/firefly/head/reference/types/tokenapproval.html",
    "relUrl": "/reference/types/tokenapproval.html"
  },"655": {
    "doc": "TokenApproval",
    "title": "TransactionRef",
    "content": "| Field Name | Description | Type | . | type | The type of the FireFly transaction | FFEnum: | . | id | The UUID of the FireFly transaction | UUID | . ",
    "url": "/firefly/head/reference/types/tokenapproval.html#transactionref",
    "relUrl": "/reference/types/tokenapproval.html#transactionref"
  },"656": {
    "doc": "TokenPool",
    "title": "TokenPool",
    "content": " ",
    "url": "/firefly/head/reference/types/tokenpool.html",
    "relUrl": "/reference/types/tokenpool.html"
  },"657": {
    "doc": "TokenPool",
    "title": "Table of contents",
    "content": ". | TokenPool . | Example token pool types | Example | Field Descriptions | . | TransactionRef | . ",
    "url": "/firefly/head/reference/types/tokenpool.html#table-of-contents",
    "relUrl": "/reference/types/tokenpool.html#table-of-contents"
  },"658": {
    "doc": "TokenPool",
    "title": "TokenPool",
    "content": "Token pools are a FireFly construct for describing a set of tokens. The total supply of a particular fungible token, or a group of related non-fungible tokens. The exact definition of a token pool is dependent on the token connector implementation. Check the documentation for your chosen connector implementation to see the detailed options for configuring a new Token Pool. Note that it is very common to use a Token Pool to teach Hyperledger FireFly about an existing token, so that you can start interacting with a token that already exists. Example token pool types . Some examples of how the generic concept of a Token Pool maps to various well-defined Ethereum standards: . | ERC-1155: a single contract instance can efficiently allocate many isolated pools of fungible or non-fungible tokens | ERC-20 / ERC-777: each contract instance represents a single fungible pool of value, e.g. “a coin” | ERC-721: each contract instance represents a single pool of NFTs, each with unique identities within the pool | ERC-1400 / ERC-1410: partially supported in the same manner as ERC-20/ERC-777, but would require new features for working with partitions | . These are provided as examples only - a custom token connector could be backed by any token technology (Ethereum or otherwise) as long as it can support the basic operations described here (create pool, mint, burn, transfer). Other FireFly repos include a sample implementation of a token connector for ERC-20 and ERC-721 as well as ERC-1155. Example . { \"id\": \"90ebefdf-4230-48a5-9d07-c59751545859\", \"type\": \"fungible\", \"namespace\": \"ns1\", \"name\": \"my_token\", \"standard\": \"ERC-20\", \"locator\": \"address=0x056df1c53c3c00b0e13d37543f46930b42f71db0\\u0026schema=ERC20WithData\\u0026type=fungible\", \"decimals\": 18, \"connector\": \"erc20_erc721\", \"message\": \"43923040-b1e5-4164-aa20-47636c7177ee\", \"state\": \"confirmed\", \"created\": \"2022-05-16T01:23:15Z\", \"info\": { \"address\": \"0x056df1c53c3c00b0e13d37543f46930b42f71db0\", \"name\": \"pool8197\", \"schema\": \"ERC20WithData\" }, \"tx\": { \"type\": \"token_pool\", \"id\": \"a23ffc87-81a2-4cbc-97d6-f53d320c36cd\" } } . Field Descriptions . | Field Name | Description | Type | . | id | The UUID of the token pool | UUID | . | type | The type of token the pool contains, such as fungible/non-fungible | FFEnum:\"fungible\"\"nonfungible\" | . | namespace | The namespace for the token pool | string | . | name | The name of the token pool. Note the name is not validated against the description of the token on the blockchain | string | . | standard | The ERC standard the token pool conforms to, as reported by the token connector | string | . | locator | A unique identifier for the pool, as provided by the token connector | string | . | key | The signing key used to create the token pool. On input for token connectors that support on-chain deployment of new tokens (vs. only index existing ones) this determines the signing key used to create the token on-chain | string | . | symbol | The token symbol. If supplied on input for an existing on-chain token, this must match the on-chain information | string | . | decimals | Number of decimal places that this token has | int | . | connector | The name of the token connector, as specified in the FireFly core configuration file that is responsible for the token pool. Required on input when multiple token connectors are configured | string | . | message | The UUID of the broadcast message used to inform the network to index this pool | UUID | . | state | The current state of the token pool | FFEnum:\"unknown\"\"pending\"\"confirmed\" | . | created | The creation time of the pool | FFTime | . | config | Input only field, with token connector specific configuration of the pool, such as an existing Ethereum address and block number to used to index the pool. See your chosen token connector documentation for details | JSONObject | . | info | Token connector specific information about the pool. See your chosen token connector documentation for details | JSONObject | . | tx | Reference to the FireFly transaction used to create and broadcast this pool to the network | TransactionRef | . ",
    "url": "/firefly/head/reference/types/tokenpool.html",
    "relUrl": "/reference/types/tokenpool.html"
  },"659": {
    "doc": "TokenPool",
    "title": "TransactionRef",
    "content": "| Field Name | Description | Type | . | type | The type of the FireFly transaction | FFEnum: | . | id | The UUID of the FireFly transaction | UUID | . ",
    "url": "/firefly/head/reference/types/tokenpool.html#transactionref",
    "relUrl": "/reference/types/tokenpool.html#transactionref"
  },"660": {
    "doc": "TokenTransfer",
    "title": "TokenTransfer",
    "content": " ",
    "url": "/firefly/head/reference/types/tokentransfer.html",
    "relUrl": "/reference/types/tokentransfer.html"
  },"661": {
    "doc": "TokenTransfer",
    "title": "Table of contents",
    "content": ". | TokenTransfer . | FireFly initiated vs. non-FireFly initiated transfers | Message coordinated transfers | Transfer types | Example | Field Descriptions | . | TransactionRef | . ",
    "url": "/firefly/head/reference/types/tokentransfer.html#table-of-contents",
    "relUrl": "/reference/types/tokentransfer.html#table-of-contents"
  },"662": {
    "doc": "TokenTransfer",
    "title": "TokenTransfer",
    "content": "A Token Transfer is created for each transfer of value that happens under a token pool. The transfers form an off-chain audit history (an “index”) of the transactions that have been performed on the blockchain. This historical information cannot be queried directly from the blockchain for most token implementations, because it is inefficient to use the blockchain to store complex data structures like this. So the blockchain simply emits events when state changes, and if you want to be able to query this historical information you need to track it in your own off-chain database. Hyperledger FireFly maintains this index automatically for all Token Pools that are configured. FireFly initiated vs. non-FireFly initiated transfers . There is no requirement at all to use FireFly to initiate transfers in Token Pools that Hyperledger FireFly is aware of. FireFly will listen to and update its audit history and balances for all transfers, regardless of whether they were initiated using a FireFly SuperNode or not. So you could for example use Metamask to initiate a transfer directly against an ERC-20/ERC-721 contract directly on your blockchain, and you will see it appear as a transfer. Or initiate a transfer on-chain via another Smart Contract, such as a Hashed Timelock Contract (HTLC) releasing funds held in digital escrow. Message coordinated transfers . One special feature enabled when using FireFly to initiate transfers, is to coordinate an off-chain data transfer (private or broadcast) with the on-chain transfer of value. This is a powerful tool to allow transfers to have rich metadata associated that is too sensitive (or too large) to include on the blockchain itself. These transfers have a message associated with them, and require a compatible Token Connector and on-chain Smart Contract that allows a data payload to be included as part of the transfer, and to be emitted as part of the transfer event. Examples of how to do this are included in the ERC-20, ERC-721 and ERC-1155 Token Connector sample smart contracts. Transfer types . There are three primary types of transfer: . | Mint - new tokens come into existence, increasing the total supply of tokens within the pool. The from address will be unset for these transfer types. | Burn - existing tokens are taken out of circulation. The to address will be unset for these transfer types. | Transfer - tokens move from ownership by one account, to another account. The from and to addresses are both set for these type of transfers. | . Note that the key that signed the Transfer transaction might be different to the from account that is the owner of the tokens before the transfer. The Approval resource is used to track which signing accounts (other than the owner) have approval to transfer tokens on the owner’s behalf. Example . { \"type\": \"transfer\", \"pool\": \"1244ecbe-5862-41c3-99ec-4666a18b9dd5\", \"uri\": \"firefly://token/1\", \"connector\": \"erc20_erc721\", \"namespace\": \"ns1\", \"key\": \"0x55860105D6A675dBE6e4d83F67b834377Ba677AD\", \"from\": \"0x55860105D6A675dBE6e4d83F67b834377Ba677AD\", \"to\": \"0x55860105D6A675dBE6e4d83F67b834377Ba677AD\", \"amount\": \"1000000000000000000\", \"protocolId\": \"000000000041/000000/000000\", \"message\": \"780b9b90-e3b0-4510-afac-b4b1f2940b36\", \"messageHash\": \"780204e634364c42779920eddc8d9fecccb33e3607eeac9f53abd1b31184ae4e\", \"created\": \"2022-05-16T01:23:15Z\", \"tx\": { \"type\": \"token_transfer\", \"id\": \"62767ca8-99f9-439c-9deb-d80c6672c158\" }, \"blockchainEvent\": \"b57fcaa2-156e-4c3f-9b0b-ddec9ee25933\" } . Field Descriptions . | Field Name | Description | Type | . | type | The type of transfer such as mint/burn/transfer | FFEnum:\"mint\"\"burn\"\"transfer\" | . | localId | The UUID of this token transfer, in the local FireFly node | UUID | . | pool | The UUID the token pool this transfer applies to | UUID | . | tokenIndex | The index of the token within the pool that this transfer applies to | string | . | uri | The URI of the token this transfer applies to | string | . | connector | The name of the token connector, as specified in the FireFly core configuration file. Required on input when there are more than one token connectors configured | string | . | namespace | The namespace for the transfer, which must match the namespace of the token pool | string | . | key | The blockchain signing key for the transfer. On input defaults to the first signing key of the organization that operates the node | string | . | from | The source account for the transfer. On input defaults to the value of ‘key’ | string | . | to | The target account for the transfer. On input defaults to the value of ‘key’ | string | . | amount | The amount for the transfer. For non-fungible tokens will always be 1. For fungible tokens, the number of decimals for the token pool should be considered when inputting the amount. For example, with 18 decimals a fractional balance of 10.234 will be specified as 10,234,000,000,000,000,000 | FFBigInt | . | protocolId | An alphanumerically sortable string that represents this event uniquely with respect to the blockchain | string | . | message | The UUID of a message that has been correlated with this transfer using the data field of the transfer in a compatible token connector | UUID | . | messageHash | The hash of a message that has been correlated with this transfer using the data field of the transfer in a compatible token connector | Bytes32 | . | created | The creation time of the transfer | FFTime | . | tx | If submitted via FireFly, this will reference the UUID of the FireFly transaction (if the token connector in use supports attaching data) | TransactionRef | . | blockchainEvent | The UUID of the blockchain event | UUID | . | config | Input only field, with token connector specific configuration of the transfer. See your chosen token connector documentation for details | JSONObject | . ",
    "url": "/firefly/head/reference/types/tokentransfer.html",
    "relUrl": "/reference/types/tokentransfer.html"
  },"663": {
    "doc": "TokenTransfer",
    "title": "TransactionRef",
    "content": "| Field Name | Description | Type | . | type | The type of the FireFly transaction | FFEnum: | . | id | The UUID of the FireFly transaction | UUID | . ",
    "url": "/firefly/head/reference/types/tokentransfer.html#transactionref",
    "relUrl": "/reference/types/tokentransfer.html#transactionref"
  },"664": {
    "doc": "Transaction",
    "title": "Transaction",
    "content": " ",
    "url": "/firefly/head/reference/types/transaction.html",
    "relUrl": "/reference/types/transaction.html"
  },"665": {
    "doc": "Transaction",
    "title": "Table of contents",
    "content": ". | Transaction . | Example | Field Descriptions | . | . ",
    "url": "/firefly/head/reference/types/transaction.html#table-of-contents",
    "relUrl": "/reference/types/transaction.html#table-of-contents"
  },"666": {
    "doc": "Transaction",
    "title": "Transaction",
    "content": "FireFly Transactions are a grouping construct for a number of Operations and Events that need to complete or fail as unit. FireFly Transactions are not themselves Blockchain transactions, but in many cases there is exactly one Blockchain transaction associated with each FireFly transaction. Exceptions include unpinned transactions, where there is no blockchain transaction at all. The Blockchain native transaction ID is stored in the FireFly transaction object when it is known. However, the FireFly transaction starts before a Blockchain transaction exists - because reliably submitting the blockchain transaction is one of the operations that is performed inside of the FireFly transaction. The below screenshot from the FireFly Explorer nicely illustrates how multiple operations and events are associated with a FireFly transaction. In this example, the transaction tracking is pinning of a batch of messages stored in IPFS to the blockchain. So there is a Blockchain ID for the transaction - as there is just one Blockchain transaction regardless of how many messages in the batch. There are operations for the submission of that transaction, and the upload of the data to IPFS. Then a corresponding Blockchain Event Received event for the detection of the event from the blockchain smart contract when the transaction was mined, and a Message Confirmed event for each message in the batch (in this case 1). Then here the message was a special Definition message that advertised a new Contract API to all members of the network - so there is a Contract API Confirmed event as well. Each FireFly transaction has a UUID. This UUID is propagated through to all participants in a FireFly transaction. For example in a Token Transfer that is coordinated with an off-chain private Message, the transaction ID is propagated to all parties who are part of that transaction. So the same UUID can be used to find the transaction in the FireFly Explorer of any member who has access to the message. This is possible because hash-pinned off-chain data is associated with that on-chain transfer. However, in the case of a raw ERC-20/ERC-721 transfer (without data), or any other raw Blockchain transaction, the FireFly transaction UUID cannot be propagated - so it will be local on the node that initiated the transaction. Example . { \"id\": \"4e7e0943-4230-4f67-89b6-181adf471edc\", \"namespace\": \"ns1\", \"type\": \"contract_invoke\", \"created\": \"2022-05-16T01:23:15Z\", \"blockchainIds\": [ \"0x34b0327567fefed09ac7b4429549bc609302b08a9cbd8f019a078ec44447593d\" ] } . Field Descriptions . | Field Name | Description | Type | . | id | The UUID of the FireFly transaction | UUID | . | namespace | The namespace of the FireFly transaction | string | . | type | The type of the FireFly transaction | FFEnum:\"none\"\"unpinned\"\"batch_pin\"\"network_action\"\"token_pool\"\"token_transfer\"\"contract_invoke\"\"token_approval\"\"data_publish\" | . | created | The time the transaction was created on this node. Note the transaction is individually created with the same UUID on each participant in the FireFly transaction | FFTime | . | blockchainIds | The blockchain transaction ID, in the format specific to the blockchain involved in the transaction. Not all FireFly transactions include a blockchain. FireFly transactions are extensible to support multiple blockchain transactions | string[] | . ",
    "url": "/firefly/head/reference/types/transaction.html",
    "relUrl": "/reference/types/transaction.html"
  },"667": {
    "doc": "Verifier",
    "title": "Verifier",
    "content": " ",
    "url": "/firefly/head/reference/types/verifier.html",
    "relUrl": "/reference/types/verifier.html"
  },"668": {
    "doc": "Verifier",
    "title": "Table of contents",
    "content": ". | Verifier . | Example | Field Descriptions | . | . ",
    "url": "/firefly/head/reference/types/verifier.html#table-of-contents",
    "relUrl": "/reference/types/verifier.html#table-of-contents"
  },"669": {
    "doc": "Verifier",
    "title": "Verifier",
    "content": "A verifier is a cryptographic verification mechanism for an identity in FireFly. FireFly generally defers verification of these keys to the lower layers of technologies in the stack - the blockchain (Fabric, Ethereum etc.) or Data Exchange technology. As such the details of the public key cryptography scheme are not represented in the FireFly verifiers. Only the string identifier of the verifier that is appropriate to the technology. | Ethereum blockchains: The Ethereum address hex string | Hyperledger Fabric: The fully qualified MSP Identifier string | Data exchange: The data exchange “Peer ID”, as determined by the DX plugin | . Example . { \"hash\": \"6818c41093590b862b781082d4df5d4abda6d2a4b71d737779edf6d2375d810b\", \"identity\": \"114f5857-9983-46fb-b1fc-8c8f0a20846c\", \"type\": \"ethereum_address\", \"value\": \"0x30017fd084715e41aa6536ab777a8f3a2b11a5a1\", \"created\": \"2022-05-16T01:23:15Z\" } . Field Descriptions . | Field Name | Description | Type | . | hash | Hash used as a globally consistent identifier for this namespace + type + value combination on every node in the network | Bytes32 | . | identity | The UUID of the parent identity that has claimed this verifier | UUID | . | namespace | The namespace of the verifier | string | . | type | The type of the verifier | FFEnum:\"ethereum_address\"\"fabric_msp_id\"\"dx_peer_id\" | . | value | The verifier string, such as an Ethereum address, or Fabric MSP identifier | string | . | created | The time this verifier was created on this node | FFTime | . ",
    "url": "/firefly/head/reference/types/verifier.html",
    "relUrl": "/reference/types/verifier.html"
  },"670": {
    "doc": "Versioning Scheme",
    "title": "Versioning Scheme",
    "content": " ",
    "url": "/firefly/head/contributors/version_scheme.html",
    "relUrl": "/contributors/version_scheme.html"
  },"671": {
    "doc": "Versioning Scheme",
    "title": "Table of contents",
    "content": ". | Versioning Scheme . | Semantic versioning | Pre-release test versions | Candidate releases | . | . This page describes FireFly’s versioning scheme . ",
    "url": "/firefly/head/contributors/version_scheme.html#table-of-contents",
    "relUrl": "/contributors/version_scheme.html#table-of-contents"
  },"672": {
    "doc": "Versioning Scheme",
    "title": "Semantic versioning",
    "content": "FireFly follows semantic versioning. In summary, this means: . Given a version number MAJOR.MINOR.PATCH, increment the: . | MAJOR version when you make incompatible API changes, | MINOR version when you add functionality in a backwards compatible manner, and | PATCH version when you make backwards compatible bug fixes. | Additional labels for pre-release and build metadata are available as extensions to the MAJOR.MINOR.PATCH format. | . When creating a new release, the release name and tag should be the semantic version should be prefixed with a v . For example, a certain release name/tag could be v0.9.0. ",
    "url": "/firefly/head/contributors/version_scheme.html#semantic-versioning",
    "relUrl": "/contributors/version_scheme.html#semantic-versioning"
  },"673": {
    "doc": "Versioning Scheme",
    "title": "Pre-release test versions",
    "content": "For pre-release versions for testing, we append a date and index to the end of the most recently released version. For example, if we needed to create a pre-release based on v0.9.0 and today’s date is October 22, 2021, the version name/tag would be: v0.9.0-20211022-01. If for some reason you needed to create another pre-release version in the same day (hey, stuff happens), the name/tag for that one would be v0.9.0-20211022-02. ",
    "url": "/firefly/head/contributors/version_scheme.html#pre-release-test-versions",
    "relUrl": "/contributors/version_scheme.html#pre-release-test-versions"
  },"674": {
    "doc": "Versioning Scheme",
    "title": "Candidate releases",
    "content": "For pre-releases that are candidates to become a new major or minor release, the release name/tag will be based on the release that the candidate will become (as opposed to the test releases above, which are based on the previous release). For example, if the current latest release is v0.9.0 but we want to create an alpha release for 1.0, the release name/tag would be v1.0.0-alpha-01. ",
    "url": "/firefly/head/contributors/version_scheme.html#candidate-releases",
    "relUrl": "/contributors/version_scheme.html#candidate-releases"
  },"675": {
    "doc": "WSAck",
    "title": "WSAck",
    "content": " ",
    "url": "/firefly/head/reference/types/wsack.html",
    "relUrl": "/reference/types/wsack.html"
  },"676": {
    "doc": "WSAck",
    "title": "Table of contents",
    "content": ". | WSAck . | Example | Field Descriptions | . | SubscriptionRef | . ",
    "url": "/firefly/head/reference/types/wsack.html#table-of-contents",
    "relUrl": "/reference/types/wsack.html#table-of-contents"
  },"677": {
    "doc": "WSAck",
    "title": "WSAck",
    "content": "An ack must be sent on a WebSocket for each event delivered to an application. Unless autoack is set in the WSStart payload/URL parameters to cause automatic acknowledgement. Your application should specify the id of each event that it acknowledges. If the id is omitted, then FireFly will assume the oldest message delivered to the application that has not been acknowledged is the one the ack is associated with. If multiple subscriptions are started on a WebSocket, then you need to specify the subscription namespace+name as part of each ack. If you send an acknowledgement that cannot be correlated, then a WSError payload will be sent to the application. Example . { \"type\": \"ack\", \"id\": \"f78bf82b-1292-4c86-8a08-e53d855f1a64\", \"subscription\": { \"namespace\": \"ns1\", \"name\": \"app1_subscription\" } } . Field Descriptions . | Field Name | Description | Type | . | type | WSActionBase.type | FFEnum:\"start\"\"ack\"\"protocol_error\" | . | id | WSAck.id | UUID | . | subscription | WSAck.subscription | SubscriptionRef | . ",
    "url": "/firefly/head/reference/types/wsack.html",
    "relUrl": "/reference/types/wsack.html"
  },"678": {
    "doc": "WSAck",
    "title": "SubscriptionRef",
    "content": "| Field Name | Description | Type | . | id | The UUID of the subscription | UUID | . | namespace | The namespace of the subscription. A subscription will only receive events generated in the namespace of the subscription | string | . | name | The name of the subscription. The application specifies this name when it connects, in order to attach to the subscription and receive events that arrived while it was disconnected. If multiple apps connect to the same subscription, events are workload balanced across the connected application instances | string | . ",
    "url": "/firefly/head/reference/types/wsack.html#subscriptionref",
    "relUrl": "/reference/types/wsack.html#subscriptionref"
  },"679": {
    "doc": "WSError",
    "title": "WSError",
    "content": " ",
    "url": "/firefly/head/reference/types/wserror.html",
    "relUrl": "/reference/types/wserror.html"
  },"680": {
    "doc": "WSError",
    "title": "Table of contents",
    "content": ". | WSError . | Example | Field Descriptions | . | . ",
    "url": "/firefly/head/reference/types/wserror.html#table-of-contents",
    "relUrl": "/reference/types/wserror.html#table-of-contents"
  },"681": {
    "doc": "WSError",
    "title": "WSError",
    "content": "Example . { \"type\": \"protocol_error\", \"error\": \"FF10175: Acknowledgment does not match an inflight event + subscription\" } . Field Descriptions . | Field Name | Description | Type | . | type | WSAck.type | FFEnum:\"start\"\"ack\"\"protocol_error\" | . | error | WSAck.error | string | . ",
    "url": "/firefly/head/reference/types/wserror.html",
    "relUrl": "/reference/types/wserror.html"
  },"682": {
    "doc": "WSStart",
    "title": "WSStart",
    "content": " ",
    "url": "/firefly/head/reference/types/wsstart.html",
    "relUrl": "/reference/types/wsstart.html"
  },"683": {
    "doc": "WSStart",
    "title": "Table of contents",
    "content": ". | WSStart . | Example | Field Descriptions | . | SubscriptionFilter | MessageFilter | TransactionFilter | BlockchainEventFilter | SubscriptionOptions | WebhookInputOptions | . ",
    "url": "/firefly/head/reference/types/wsstart.html#table-of-contents",
    "relUrl": "/reference/types/wsstart.html#table-of-contents"
  },"684": {
    "doc": "WSStart",
    "title": "WSStart",
    "content": "The start payload is sent after an application connects to a WebSocket, to start delivery of events over that connection. The start command can refer to a subscription by name in order to reliably receive all matching events for that subscription, including those that were emitted when the application was disconnected. Alternatively the start command can request \"ephemeral\": true in order to dynamically create a new subscription that lasts only for the duration that the connection is active. Example . { \"type\": \"start\", \"autoack\": false, \"namespace\": \"ns1\", \"name\": \"app1_subscription\", \"ephemeral\": false, \"filter\": { \"message\": {}, \"transaction\": {}, \"blockchainevent\": {} }, \"options\": {} } . Field Descriptions . | Field Name | Description | Type | . | type | WSActionBase.type | FFEnum:\"start\"\"ack\"\"protocol_error\" | . | autoack | WSStart.autoack | bool | . | namespace | WSStart.namespace | string | . | name | WSStart.name | string | . | ephemeral | WSStart.ephemeral | bool | . | filter | WSStart.filter | SubscriptionFilter | . | options | WSStart.options | SubscriptionOptions | . ",
    "url": "/firefly/head/reference/types/wsstart.html",
    "relUrl": "/reference/types/wsstart.html"
  },"685": {
    "doc": "WSStart",
    "title": "SubscriptionFilter",
    "content": "| Field Name | Description | Type | . | events | Regular expression to apply to the event type, to subscribe to a subset of event types | string | . | message | Filters specific to message events. If an event is not a message event, these filters are ignored | MessageFilter | . | transaction | Filters specific to events with a transaction. If an event is not associated with a transaction, this filter is ignored | TransactionFilter | . | blockchainevent | Filters specific to blockchain events. If an event is not a blockchain event, these filters are ignored | BlockchainEventFilter | . | topic | Regular expression to apply to the topic of the event, to subscribe to a subset of topics. Note for messages sent with multiple topics, a separate event is emitted for each topic | string | . | topics | Deprecated: Please use ‘topic’ instead | string | . | tag | Deprecated: Please use ‘message.tag’ instead | string | . | group | Deprecated: Please use ‘message.group’ instead | string | . | author | Deprecated: Please use ‘message.author’ instead | string | . ",
    "url": "/firefly/head/reference/types/wsstart.html#subscriptionfilter",
    "relUrl": "/reference/types/wsstart.html#subscriptionfilter"
  },"686": {
    "doc": "WSStart",
    "title": "MessageFilter",
    "content": "| Field Name | Description | Type | . | tag | Regular expression to apply to the message ‘header.tag’ field | string | . | group | Regular expression to apply to the message ‘header.group’ field | string | . | author | Regular expression to apply to the message ‘header.author’ field | string | . ",
    "url": "/firefly/head/reference/types/wsstart.html#messagefilter",
    "relUrl": "/reference/types/wsstart.html#messagefilter"
  },"687": {
    "doc": "WSStart",
    "title": "TransactionFilter",
    "content": "| Field Name | Description | Type | . | type | Regular expression to apply to the transaction ‘type’ field | string | . ",
    "url": "/firefly/head/reference/types/wsstart.html#transactionfilter",
    "relUrl": "/reference/types/wsstart.html#transactionfilter"
  },"688": {
    "doc": "WSStart",
    "title": "BlockchainEventFilter",
    "content": "| Field Name | Description | Type | . | name | Regular expression to apply to the blockchain event ‘name’ field, which is the name of the event in the underlying blockchain smart contract | string | . | listener | Regular expression to apply to the blockchain event ‘listener’ field, which is the UUID of the event listener. So you can restrict your subscription to certain blockchain listeners. Alternatively to avoid your application need to know listener UUIDs you can set the ‘topic’ field of blockchain event listeners, and use a topic filter on your subscriptions | string | . ",
    "url": "/firefly/head/reference/types/wsstart.html#blockchaineventfilter",
    "relUrl": "/reference/types/wsstart.html#blockchaineventfilter"
  },"689": {
    "doc": "WSStart",
    "title": "SubscriptionOptions",
    "content": "| Field Name | Description | Type | . | firstEvent | Whether your appplication would like to receive events from the ‘oldest’ event emitted by your FireFly node (from the beginning of time), or the ‘newest’ event (from now), or a specific event sequence. Default is ‘newest’ | SubOptsFirstEvent | . | readAhead | The number of events to stream ahead to your application, while waiting for confirmation of consumption of those events. At least once delivery semantics are used in FireFly, so if your application crashes/reconnects this is the maximum number of events you would expect to be redelivered after it restarts | uint16 | . | withData | Whether message events delivered over the subscription, should be packaged with the full data of those messages in-line as part of the event JSON payload. Or if the application should make separate REST calls to download that data. May not be supported on some transports. | bool | . | fastack | Webhooks only: When true the event will be acknowledged before the webhook is invoked, allowing parallel invocations | bool | . | url | Webhooks only: HTTP url to invoke. Can be relative if a base URL is set in the webhook plugin config | string | . | method | Webhooks only: HTTP method to invoke. Default=POST | string | . | json | Webhooks only: Whether to assume the response body is JSON, regardless of the returned Content-Type | bool | . | reply | Webhooks only: Whether to automatically send a reply event, using the body returned by the webhook | bool | . | replytag | Webhooks only: The tag to set on the reply message | string | . | replytx | Webhooks only: The transaction type to set on the reply message | string | . | headers | Webhooks only: Static headers to set on the webhook request | `` | . | query | Webhooks only: Static query params to set on the webhook request | `` | . | input | Webhooks only: A set of options to extract data from the first JSON input data in the incoming message. Only applies if withData=true | WebhookInputOptions | . ",
    "url": "/firefly/head/reference/types/wsstart.html#subscriptionoptions",
    "relUrl": "/reference/types/wsstart.html#subscriptionoptions"
  },"690": {
    "doc": "WSStart",
    "title": "WebhookInputOptions",
    "content": "| Field Name | Description | Type | . | query | A top-level property of the first data input, to use for query parameters | string | . | headers | A top-level property of the first data input, to use for headers | string | . | body | A top-level property of the first data input, to use for the request body. Default is the whole first body | string | . | path | A top-level property of the first data input, to use for a path to append with escaping to the webhook path | string | . | replytx | A top-level property of the first data input, to use to dynamically set whether to pin the response (so the requester can choose) | string | . ",
    "url": "/firefly/head/reference/types/wsstart.html#webhookinputoptions",
    "relUrl": "/reference/types/wsstart.html#webhookinputoptions"
  }
}
